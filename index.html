<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>ZA 한글 공략 맵</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height:100%; margin:0; }
    #map { position: relative; z-index: 0; background:#e9eaec; }
    .bar{
      position:fixed; left:10px; top:10px; z-index:1400;
      background:#111a; color:#fff; padding:8px 10px; border-radius:10px; font-size:14px;
      display:flex; gap:8px; align-items:center;
    }
    .bar button{margin:0}
    #adminBadge{display:none;background:#ffd54f;color:#111;padding:2px 6px;border-radius:8px}
    .tbtn{background:#2a2f3a;color:#ddd;border:0;border-radius:8px;padding:6px 10px;cursor:pointer}
    .tbtn.on{background:#3d6cff;color:#fff}
    /* 좌측 검색 사이드 */
    #side{
      position:fixed; z-index:1300; left:10px; top:60px; bottom:10px;
      width:20vw; min-width:240px; max-width:420px;
      display:none; background:#1c1f27; color:#d6d9e0; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.25);
      padding:12px; overflow:auto;
    }
    #side h3{margin:6px 0 10px 4px; font-size:16px; color:#fff}
    .flt-wrap{display:flex; flex-wrap:wrap; gap:8px}
    .flt{
      border:1px solid #303645; background:#202532; color:#c9cfdd; padding:6px 10px;
      border-radius:999px; cursor:pointer; font-size:13px;
    }
    .flt.on{background:#3d6cff; border-color:#3d6cff; color:#fff}
    .hr{height:1px; background:#2a3040; margin:12px 0}
    .inp{width:100%; box-sizing:border-box; background:#1117; color:#eef; border:1px solid #303645; border-radius:10px; padding:8px}
    .row{display:flex; gap:8px; align-items:center}

    /* 신고 관리 모드 전용 리스트 */
    .rlist{display:grid; gap:8px}
    .ritem{background:#1f2430;border:1px solid #2f3647;border-radius:10px;padding:10px}
    .ritem .meta{font-size:12px;color:#9fb0c0;margin-top:4px}
    .ritem .act{display:flex;gap:8px;margin-top:8px}
    .rbtn{background:#2a2f3a;color:#fff;border:0;padding:6px 10px;border-radius:8px;cursor:pointer}
    .rbtn.warn{background:#ff5252}
    .rep-sort{display:flex;gap:6px;flex-wrap:wrap;margin:6px 0 8px}
    .rep-sort .flt{padding:4px 10px}
    .rep-filt{display:flex;gap:6px;flex-wrap:wrap;margin:4px 0 8px}
    .rep-filt .flt{padding:3px 10px}

    /* 우하단 상세 패널 */
    #info{position:fixed; right:10px; bottom:10px; width:420px; max-height:75%;
      overflow:auto; z-index:1500; display:none; background:#1e1e1e; color:#ddd;
      border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.35);}
    #info header{display:flex; align-items:center; gap:8px; padding:10px 12px; border-bottom:1px solid #333}
    #info .thumb{width:100%; max-height:260px; object-fit:cover; background:#000}
    #info .pad{padding:12px}
    #info .meta{font-size:12px; color:#aaa; display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    #info .badge{background:#ff9800;color:#111;padding:2px 6px;border-radius:6px;font-size:11px}
    #info .btns{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px}
    #info button{background:#2a2a2a; color:#fff; border:0; padding:6px 10px; border-radius:8px; cursor:pointer}
    #info button.primary{background:#3d6cff}
    #info button.warn{background:#ff5252}
    #info .media video{width:100%; max-height:260px}
    #info .media img{width:100%; max-height:260px; object-fit:cover}
    #info .idtag{background:#263238; color:#cfd8dc; padding:2px 6px; border-radius:6px; font-size:11px}
    .pk-tags{display:flex; flex-wrap:wrap; gap:6px; margin-top:6px}
    .pk-tags .tag{background:#223; border:1px solid #345; color:#cfe; padding:2px 8px; border-radius:999px; font-size:12px; cursor:pointer}
    /* 캐러셀 */
    .carousel{ position:relative; width:100%; margin-top:12px; background:#141414; border-radius:10px; overflow:hidden }
    .carousel .inner{ display:flex; transition: transform .3s ease }
    .carousel .item{ min-width:100%; display:flex; align-items:center; justify-content:center; background:#000 }
    .carousel .item img, .carousel .item video{ width:100%; max-height:420px; object-fit:contain; background:#000 }
    .carousel .nav{
      position:absolute; top:50%; transform:translateY(-50%);
      background:#000a; color:#fff; border:0; width:38px; height:38px; border-radius:50%; cursor:pointer;
      display:flex; align-items:center; justify-content:center; font-size:18px;
    }
    .carousel .prev{ left:8px } .carousel .next{ right:8px }
    .carousel .dots{ position:absolute; left:0; right:0; bottom:6px; display:flex; justify-content:center; gap:6px }
    .carousel .dot{ width:8px; height:8px; border-radius:50%; background:#6a6a6a; }
    .carousel .dot.on{ background:#fff }
    /* 댓글 */
    #comments{ margin-top:12px; }
    #comments .cform textarea{ width:100%; box-sizing:border-box; background:#111; color:#eee; border:1px solid #333; border-radius:8px; padding:8px }
    #comments .cform .row{ display:flex; gap:8px; margin-top:8px }
    #comments .cform button{ background:#3d6cff; border:0; color:#fff; padding:6px 10px; border-radius:8px }
    #comments .clist{ margin-top:10px; display:grid; gap:10px }
    .citem{ background:#151515; border:1px solid #2a2a2a; border-radius:10px; padding:10px }
    .citem .meta{ font-size:12px; color:#aaa; display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .citem .act{ display:flex; gap:8px; margin-top:6px }
    .citem .btn{ background:#2a2a2a; color:#fff; border:0; padding:4px 8px; border-radius:8px; cursor:pointer }
    .citem .btn.warn{ background:#ff5252 }
    .badge-report{background:#ff9800;color:#111;padding:2px 6px;border-radius:6px;font-size:11px}
    .badge-hidden{background:#90caf9;color:#111;padding:2px 6px;border-radius:6px;font-size:11px}

    /* 입력 모달 */
    #modal{display:none; position:fixed; inset:0; background:#0008; align-items:center; justify-content:center; z-index:1500;}
    #panel{background:#1e1e1e;color:#fff;padding:16px;border-radius:12px;width:380px}
    #panel input,#panel textarea,#panel select{width:100%; box-sizing:border-box}
    small.muted{color:#a0a7b4}

    /* 얌전한 인앱 안내 배너 */
    #inapp-banner {
      position: fixed; top: 0; left: 0; right: 0; z-index: 2999;
      background: linear-gradient(90deg,#0f172aee,#111827ee);
      color: #e5e7eb; font-size: 13px; line-height: 1.4;
      padding: 10px 12px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,.35);
    }
    #inapp-banner strong{ color:#fff; font-weight:600 }
  </style>
</head>
<body>
  <!-- 외부 스크립트 차단 경고 -->
  <div id="blockWarn" style="display:none;position:fixed;inset:0;background:#000a;z-index:3000;
  align-items:center;justify-content:center;color:#fff;padding:20px;text-align:center">
    외부 스크립트가 차단되어 페이지가 작동하지 않습니다.<br>
    광고차단/보안DNS/브라우저 보호기능을 끄고 새로고침 해주세요.
  </div>
  <script> setTimeout(()=>{ if(!window.L){ document.getElementById('blockWarn').style.display='flex'; } }, 1500); </script>

  <!-- ✅ 인앱 브라우저 감지: 안내 문구만 표시 (버튼 없음) -->
  <script>
  (function(){
    const PATTERNS = [/KAKAOTALK/i, /Line\//i, /Instagram/i, /FBAN|FBAV/i, /Twitter/i, /Snapchat/i, /MicroMessenger/i];
    const isInApp = PATTERNS.some(r => r.test(navigator.userAgent||''));
    if (!isInApp) return;

    const banner = document.createElement('div');
    banner.id = 'inapp-banner';
    banner.innerHTML = '<strong>안내</strong> · 앱 내 브라우저에서 접속 중입니다. ' +
      '일부 기능(특히 <strong>Google 로그인/업로드/팝업</strong>)이 제한되거나 동작하지 않을 수 있어요. ' +
      'Chrome/Safari 등 <strong>외부 브라우저 이용</strong>을 권장합니다.';
    document.body.appendChild(banner);
  })();
  </script>

  <div class="bar">
    <span id="who">로그인 안 됨</span>
    <button id="login">Google 로그인</button>
    <button id="logout" style="display:none">로그아웃</button>
    <span id="adminBadge">관리자</span>
    <span style="width:1px;height:20px;background:#2f3545;margin:0 6px"></span>
    <button id="btnSearch" class="tbtn on">검색 모드</button>
    <button id="btnPlace"  class="tbtn">핀 배치 모드</button>
    <button id="btnAdminReport" class="tbtn" style="display:none">신고 관리 모드</button>
  </div>

  <!-- 좌측 사이드 -->
  <aside id="side">
    <div id="sideCats">
      <h3>카테고리 필터</h3>
      <div class="flt-wrap" id="fltList"></div>

      <h3>특수 레이어</h3>
      <div class="flt-wrap">
        <button id="fltWild" class="flt on">와일드 존</button>
        <button id="fltAll" class="flt">전체 선택</button>
        <button id="fltNone" class="flt">전체 해제</button>
        <button id="fltPending" class="flt" style="display:none">승인 대기 핀</button>
      </div>
    </div>

    <!-- 신고 관리 모드 -->
    <div id="sideReports" style="display:none">
      <h3>신고된 댓글</h3>
      <div class="rep-sort" id="repSortBar">
        <button class="flt on" data-sort="mix">종합</button>
        <button class="flt" data-sort="count">누적횟수</button>
        <button class="flt" data-sort="remain">남은숨김시간</button>
        <button class="flt" data-sort="oldest">오래된신고</button>
      </div>
      <div class="rep-filt" id="repFiltBar">
        <button class="flt on" data-filt="all">전체</button>
        <button class="flt" data-filt="eligible">가림조건충족</button>
        <button class="flt" data-filt="ineligible">미충족</button>
      </div>
      <div id="repCommentList" class="rlist"></div>
      <div class="hr"></div>
      <div style="font-size:12px;opacity:.8">관리자용 프록시(`adminReports`)와 댓글/숨김/보류 리포트를 병합해 표시합니다.</div>
    </div>

    <div class="hr"></div>
    <h3>통합 검색</h3>
    <div class="row" style="align-items:stretch">
      <input id="qInput" class="inp" placeholder="제목/내용에서 검색" />
      <button id="qSearch" class="flt">검색</button>
      <button id="qClear" class="flt">초기화</button>
    </div>
    <div style="margin-top:8px; font-size:12px; opacity:.85">최근 7일 인기 검색어</div>
    <div id="qTrending" class="flt-wrap" style="margin-top:6px"></div>
  </aside>

  <div id="map"></div>

  <!-- 우하단 상세 패널 -->
  <aside id="info">
    <header>
      <h3 id="infoTitle">(제목)</h3>
      <span id="infoId" class="idtag">#-</span>
      <button id="infoClose">닫기</button>
    </header>
    <div class="media" id="infoMediaTop"></div>
    <div class="pad">
      <div class="meta" id="infoMeta"></div>
      <div id="infoPk" class="pk-tags"></div>
      <div id="infoBody" style="white-space:pre-wrap; margin-top:8px"></div>

      <div id="infoCarousel" class="carousel" style="display:none">
        <div class="inner" id="carInner"></div>
        <button class="nav prev" id="carPrev">‹</button>
        <button class="nav next" id="carNext">›</button>
        <div class="dots" id="carDots"></div>
      </div>

      <!-- 댓글 -->
      <div id="comments">
        <div class="cform" id="cForm" style="display:none">
          <textarea id="cBody" rows="3" placeholder="댓글을 입력하세요"></textarea>
          <div class="row"><button id="cSubmit">댓글 등록</button></div>
        </div>
        <div class="clist" id="cList"></div>
      </div>

      <div class="btns" id="infoBtns" style="margin-top:12px"></div>
    </div>
  </aside>

  <!-- 마커 입력 모달 -->
  <div id="modal">
    <div id="panel">
      <h3>마커 추가 (검수 대기)</h3>
      <input id="mTitle" class="inp" placeholder="제목" />
      <textarea id="mBody" class="inp" rows="4" placeholder="공략/설명(줄바꿈 가능)"></textarea>

      <label style="display:block;margin-top:6px">닉네임 표시</label>
      <div class="row">
        <select id="mNickSel" class="inp">
          <option value="me">내 구글 닉네임</option>
          <option value="anon">익명</option>
          <option value="custom">커스텀</option>
        </select>
        <input id="mNickCustom" class="inp" placeholder="커스텀 닉네임" style="display:none;"/>
      </div>

      <label style="display:block;margin-top:8px">카테고리</label>
      <select id="mCat" class="inp"></select>
      <small class="muted">카테고리 아이콘은 Firestore <code>categories/{카테고리키}.iconUrl</code>로 전역 변경</small>

      <!-- 포켓몬 지정 -->
      <div id="pkEditor" style="display:none; margin-top:10px">
        <label>포켓몬(여러 개 가능)</label>
        <div class="row" style="align-items:stretch">
          <input id="pkAddInput" class="inp" placeholder="포켓몬 이름 입력 후 추가" />
          <button id="pkAddBtn" class="flt">추가</button>
          <button id="pkAddClear" class="flt">초기화</button>
        </div>
        <div id="pkChips" class="pk-tags" style="margin-top:6px"></div>
      </div>

      <!-- 선택 업로드 -->
      <label style="display:block;margin-top:8px">사진(선택, 여러장 가능)</label>
      <input id="mImgs" class="inp" type="file" accept="image/*" multiple />
      <label style="display:block;margin-top:8px">동영상(선택, 1개 권장)</label>
      <input id="mVideo" class="inp" type="file" accept="video/*" />
      <div style="margin-top:12px; text-align:right">
        <button id="cancelBtn">취소</button>
        <button id="saveBtn">등록</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script type="module">
    /* ---------------- 유틸 ---------------- */
    if (!globalThis.CSS) globalThis.CSS = {};
    if (!CSS.escape) CSS.escape = s => String(s).replace(/["'\\\s]/g, m => '\\' + m);
    const esc = (s)=> (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
    const nowMs = ()=> Date.now();
    const HIDE_MS = 48 * 3600 * 1000;
    const HIDE_DELAY_MS = 2 * 3600 * 1000; // 2시간
    const HIDE_COUNT = 5;                   // 5회
    const toMs = (t)=>{
      if (!t) return null;
      if (t.toMillis) return t.toMillis();
      if (t.seconds)  return t.seconds*1000;
      if (typeof t === 'number') return t;
      const d = new Date(t); return isNaN(d) ? null : d.getTime();
    };
    const norm = s => (s||'').toLowerCase();
    const normName = s => (s||'').trim().toLowerCase();
    const fieldKey = s => normName(s).replace(/[.#$/\[\]\/]/g,'_');

    /* ---------------- Leaflet ---------------- */
    const IMG_URL = "za_world_map_clean_fixed.png";
    const IMG_W = 2048, IMG_H = 2048;
    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -2, maxZoom: 4 });
    const bounds = [[0,0],[IMG_H,IMG_W]];
    L.imageOverlay(IMG_URL, bounds).addTo(map);
    map.fitBounds(bounds);
    const isInside = (latlng)=> map.getBounds().contains(latlng);

    map.createPane('wildPane');
    map.getPane('wildPane').style.zIndex = 450;
    map.getPane('wildPane').style.pointerEvents = 'none';
    const wildLayer = L.layerGroup().addTo(map);
    let wildVisible = true;

    let showPendingOnly = false;
    let adminReportMode = false;

    /* ---------------- Firebase ---------------- */
    let firebaseOk = true;
    let app, auth, db, st;
    let GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, signOut, onAuthStateChanged;
    let collection, collectionGroup, addDoc, serverTimestamp, onSnapshot,
        orderBy, query, doc, updateDoc, deleteDoc, where, getDocs, getDoc, setDoc, increment;
    let ref, getDownloadURL, uploadBytesResumable, uploadBytes;

    try {
      const [appMod, authMod, fsMod, stMod] = await Promise.all([
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js"),
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js"),
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js"),
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-storage.js"),
      ]);
      const firebaseConfig = {
        apiKey: "AIzaSyCam7y7qNINoxBlTeGx7CDlP8Y77pXFMWA",
        authDomain: "za-maps-32982.firebaseapp.com",
        projectId: "za-maps-32982",
        storageBucket: "za-maps-32982.firebasestorage.app",
        messagingSenderId: "804333155537",
        appId: "1:804333155537:web:504bc3ee175e3678bc81f0",
        measurementId: "G-GTRK8JEZFM"
      };
      app = appMod.initializeApp(firebaseConfig);
      auth = authMod.getAuth(app);
      db   = fsMod.getFirestore(app);
      st   = stMod.getStorage(app);
      ({ GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, signOut, onAuthStateChanged } = authMod);
      ({ collection, collectionGroup, addDoc, serverTimestamp, onSnapshot, orderBy, query, doc, updateDoc, deleteDoc, where, getDocs, getDoc, setDoc, increment } = fsMod);
      ({ ref, getDownloadURL, uploadBytesResumable, uploadBytes } = stMod);
    } catch (e) {
      firebaseOk = false;
      console.warn("[Firebase] 동적 import 실패 — 오프라인 모드", e);
    }

    /* ---------------- 업로드 유틸 ---------------- */
    const safeName = (name)=> name.normalize('NFKD').replace(/[^\w.\-]+/g,'_').replace(/_+/g,'_').slice(-80);
    globalThis.uploadSmart = async function uploadSmart(file, folder, onProgress, label='업로드'){
      if (!firebaseOk) throw new Error('Firebase unavailable');
      const uid = (me && me.uid) || 'anon';
      const fname = `${Date.now()}_${safeName(file.name)}`;
      const path  = `${folder}/${uid}/${fname}`;
      const r     = ref(st, path);
      try{
        onProgress?.(`${label}…`);
        await uploadBytes(r, file);
        return await getDownloadURL(r);
      }catch(e1){
        console.warn('[upload] simple 실패 → resumable', e1);
      }
      const task = uploadBytesResumable(r, file);
      await new Promise((resolve, reject)=>{
        task.on('state_changed',
          s=> onProgress?.(`${label}… ${Math.round(s.bytesTransferred/s.totalBytes*100)}%`),
          reject, resolve);
      });
      return await getDownloadURL(r);
    };

    /* ---------------- 카테고리 ---------------- */
    const CATEGORIES = [
      {key:'홀로베이터',     label:'홀로베이터',     defaultIcon:'holovator.png'},
      {key:'와일드 존',       label:'와일드 존',       defaultIcon:'wild_zone.png'},
      {key:'중요한 장소',     label:'중요한 장소',     defaultIcon:'poi.png'},
      {key:'부티크',         label:'부티크',         defaultIcon:'boutique.png'},
      {key:'포켓몬 센터',     label:'포켓몬 센터',     defaultIcon:'pokemon_center.png'},
      {key:'카페',           label:'카페',           defaultIcon:'cafe.png'},
      {key:'레스토랑',       label:'레스토랑',       defaultIcon:'restaurant.png'},
      {key:'헤어 살롱',       label:'헤어 살롱',       defaultIcon:'hair_salon.png'},
      {key:'컬러풀한 나사',   label:'컬러풀한 나사',   defaultIcon:'colorful_screw.png'},
      {key:'기술머신',       label:'기술머신',       defaultIcon:'tm.png'},
      {key:'메가스톤',       label:'메가스톤',       defaultIcon:'mega_stone.png'},
      {key:'중요 아이템',     label:'중요 아이템',     defaultIcon:'key_item.png'},
      {key:'포켓몬 볼',       label:'포켓몬 볼',       defaultIcon:'poke_ball.png'},
      {key:'회복 아이템',     label:'회복 아이템',     defaultIcon:'medicine.png'},
      {key:'보물',           label:'보물',           defaultIcon:'treasure.png'},
      {key:'기타 아이템',     label:'기타 아이템',     defaultIcon:'other_item.png'},
      {key:'메인 임무',       label:'메인 임무',       defaultIcon:'main_mission.png'},
      {key:'사이드 임무',     label:'사이드 임무',       defaultIcon:'side_mission.png'},
      {key:'승급전',         label:'승급전',         defaultIcon:'promotion_match.png'},
      {key:'사다리',         label:'사다리',         defaultIcon:'ladder.png'},
      {key:'NPC',            label:'NPC',            defaultIcon:'npc.png'},
      {key:'기타',           label:'기타',           defaultIcon:'misc.png'},
      {key:'우두머리 포켓몬', label:'우두머리 포켓몬', defaultIcon:'alpha_pokemon.png'},
      {key:'메가 포켓몬',     label:'메가 포켓몬',     defaultIcon:'mega_pokemon.png'},
    ];
    const catSel = document.getElementById('mCat');
    catSel.innerHTML = CATEGORIES.map(c=>`<option value="${c.key}">${c.label}</option>`).join('');

    const categoryIconOverride = new Map();
    if (firebaseOk){
      onSnapshot(collection(db,'categories'), snap=>{
        categoryIconOverride.clear();
        snap.forEach(d=>{ const v=d.data()?.iconUrl; if (v) categoryIconOverride.set(d.id, v); });
      });
    }
    const labelFor=(key)=> CATEGORIES.find(c=>c.key===key)?.label || key;
    const defaultIconFor=(key)=> {
      const def = CATEGORIES.find(c=>c.key===key)?.defaultIcon;
      return def ? `icons/${def}` : `icons/default.png`;
    };

    /* ---------------- 로그인/관리자 상태 ---------------- */
    const $who = document.getElementById('who');
    const $login = document.getElementById('login');
    const $logout = document.getElementById('logout');
    const $adminBadge = document.getElementById('adminBadge');
    const $btnPendingOnly = document.getElementById('fltPending');
    const $btnAdminReport = document.getElementById('btnAdminReport');
    let me=null, isAdmin=false, unsubAdminDoc=null;

    $login.onclick = async () => {
      if (!firebaseOk) { alert('네트워크 차단으로 로그인 불가'); return; }
      try{ await signInWithPopup(auth, new GoogleAuthProvider()); }
      catch{ await signInWithRedirect(auth, new GoogleAuthProvider()); }
    };
    $logout.onclick = ()=>{ if(firebaseOk) signOut(auth); };

    if (firebaseOk) getRedirectResult(auth).catch(()=>{});

    function applyAdminUI() {
      $adminBadge.style.display = isAdmin ? 'inline-block' : 'none';
      $btnPendingOnly.style.display = isAdmin ? 'inline-block' : 'none';
      $btnAdminReport.style.display = isAdmin ? 'inline-block' : 'none';
      if (!isAdmin) {
        showPendingOnly = false;
        $btnPendingOnly.classList.remove('on');
        if (adminReportMode) setAdminReportMode(false);
      }
      applyAllVisibility();
      subscribeMarkers();
      subscribeReportedCommentsAdmin();
    }

    if (firebaseOk){
      onAuthStateChanged(auth, async (user)=>{
        me=user||null;
        document.getElementById('who').textContent=me?(me.displayName || '로그인됨'):'로그인 안 됨';
        document.getElementById('login').style.display=me?'none':'inline-block';
        document.getElementById('logout').style.display=me?'inline-block':'none';

        try { if (unsubAdminDoc) { unsubAdminDoc(); } } catch {}
        isAdmin = false;
        applyAdminUI();

        if (me){
          try{
            const r = doc(db,'admins', me.uid);
            unsubAdminDoc = onSnapshot(r, s=>{
              isAdmin = s.exists();
              applyAdminUI();
            }, err=>{
              console.warn('[admins/{uid}] listen error', err);
              isAdmin = false; applyAdminUI();
            });
          }catch(e){
            console.warn('[admins/{uid}] build error', e);
            isAdmin = false; applyAdminUI();
          }
        }
      });
    }

    /* ---------------- 아이콘 캐시 ---------------- */
    const iconCache = new Map();
    function iconUrlForCat(cat){ return categoryIconOverride.get(cat) || defaultIconFor(cat); }
    function iconFor(cat){
      const url = iconUrlForCat(cat);
      const key = `${url}|32x42`;
      if (!iconCache.has(key)) iconCache.set(key, L.icon({ iconUrl: url, iconSize:[32,42], iconAnchor:[16,42] }));
      return iconCache.get(key);
    }

    /* ---------------- 카테고리 그룹 & 토글 ---------------- */
    const catGroups = new Map();
    const catVisible = new Map();
    function ensureCatGroup(key){
      if (!catGroups.has(key)) {
        catGroups.set(key, L.layerGroup().addTo(map));
        catVisible.set(key, true);
      }
      return catGroups.get(key);
    }
    function setCategoryVisible(key, visible){
      catVisible.set(key, visible);
      const g = ensureCatGroup(key);
      if (visible) { if (!map.hasLayer(g)) g.addTo(map); }
      else { if (map.hasLayer(g)) map.removeLayer(g); }
      const btn = document.querySelector(`.flt[data-cat="${CSS.escape(key)}"]`);
      if (btn){ btn.classList.toggle('on', visible); }
      applyAllVisibility();
      recomputeSeqs();
    }
    function setAllCats(v){ CATEGORIES.forEach(c=> setCategoryVisible(c.key, v)); }
    function setOnlyPokemonCats(){
      setAllCats(false);
      ['와일드 존','우두머리 포켓몬','메가 포켓몬'].forEach(k=> setCategoryVisible(k, true));
    }
    function setWildVisible(v){
      wildVisible = v;
      if (v){ if (!map.hasLayer(wildLayer)) wildLayer.addTo(map); }
      else { if (map.hasLayer(wildLayer)) map.removeLayer(wildLayer); }
      document.getElementById('fltWild').classList.toggle('on', v);
    }

    // 좌측 필터 UI
    const side = document.getElementById('side');
    const sideCats = document.getElementById('sideCats');
    const sideReports = document.getElementById('sideReports');
    const repCommentList = document.getElementById('repCommentList');
    const fltList = document.getElementById('fltList');
    const repSortBar = document.getElementById('repSortBar');
    const repFiltBar = document.getElementById('repFiltBar');
    let repSortMode = 'mix';
    let repFilterMode = 'all';

    repSortBar.onclick = (e)=>{
      const b=e.target.closest('[data-sort]'); if(!b) return;
      repSortMode = b.getAttribute('data-sort');
      [...repSortBar.children].forEach(x=> x.classList.toggle('on', x===b));
      renderReportedComments();
    };
    repFiltBar.onclick = (e)=>{
      const b=e.target.closest('[data-filt]'); if(!b) return;
      repFilterMode = b.getAttribute('data-filt');
      [...repFiltBar.children].forEach(x=> x.classList.toggle('on', x===b));
      renderReportedComments();
    };

    function buildFilters(){
      fltList.innerHTML = CATEGORIES.map(c=>`<button class="flt on" data-cat="${c.key}">${c.label}</button>`).join('');
      fltList.onclick = (e)=>{
        const b = e.target.closest('.flt[data-cat]');
        if (!b) return;
        const key = b.getAttribute('data-cat');
        const next = !catVisible.get(key);
        setCategoryVisible(key, next);
      };
      document.getElementById('fltWild').onclick = ()=> setWildVisible(!wildVisible);
      document.getElementById('fltAll').onclick  = ()=> setAllCats(true);
      document.getElementById('fltNone').onclick = ()=> setAllCats(false);

      $btnPendingOnly.onclick = ()=>{
        if (!isAdmin) return;
        showPendingOnly = !showPendingOnly;
        $btnPendingOnly.classList.toggle('on', showPendingOnly);
        applyAllVisibility(); recomputeSeqs();
      };

      $btnAdminReport.onclick = ()=>{
        if (!isAdmin) return;
        setAdminReportMode(!adminReportMode);
      };
    }
    buildFilters();

    function setAdminReportMode(v){
      adminReportMode = !!v;
      side.style.display = 'block';
      sideCats.style.display = adminReportMode ? 'none' : 'block';
      sideReports.style.display = adminReportMode ? 'block' : 'none';
      document.getElementById('btnAdminReport').classList.toggle('on', adminReportMode);
      applyAllVisibility();
      recomputeSeqs();
    }

    /* ---------------- 통합 검색 ---------------- */
    const qInput   = document.getElementById('qInput');
    const qSearch  = document.getElementById('qSearch');
    const qClear   = document.getElementById('qClear');
    const qTrendEl = document.getElementById('qTrending');

    let textFilter = '';
    function applyTextFilter(q){
      textFilter = norm(q||'');
      applyAllVisibility();
      recomputeSeqs();
    }
    qSearch.onclick = ()=> { const q = qInput.value.trim(); applyTextFilter(q); if (q) logQuery(q).catch(()=>{}); };
    qInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ qSearch.click(); }});
    qClear.onclick = ()=>{ qInput.value=''; applyTextFilter(''); };

    function dateKey(d=new Date()){
      const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), da=String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${da}`;
    }
    async function logQuery(q){
      if (!firebaseOk) return;
      const normed = fieldKey(q);
      const refD = doc(db,'searchDaily', dateKey());
      await setDoc(refD, {
        updatedAt: serverTimestamp(),
        [`counts.${normed}`]: increment(1),
        [`labels.${normed}`]: q
      }, { merge:true });
    }
    function lastNDaysKeys(n){
      const arr=[]; const now=new Date();
      for(let i=0;i<n;i++){ const d=new Date(now.getTime()-i*24*3600*1000); arr.push(dateKey(d)); }
      return arr;
    }
    async function refreshTrending(){
      if (!firebaseOk) { qTrendEl.innerHTML=''; return; }
      const keys = lastNDaysKeys(7);
      const counts = new Map(); const labels = new Map();
      for (const k of keys){
        const s = await getDoc(doc(db,'searchDaily', k));
        if (!s.exists()) continue;
        const data = s.data();
        const cs = data?.counts || {}; const ls = data?.labels || {};
        for (const [normKey, c] of Object.entries(cs)){
          counts.set(normKey, (counts.get(normKey)||0) + (c||0));
          if (ls[normKey]) labels.set(normKey, ls[normKey]);
        }
      }
      const tops = [...counts.entries()].sort((a,b)=>b[1]-a[1]).slice(0,5).map(([n])=> labels.get(n) || n);
      qTrendEl.innerHTML = tops.map(t=>`<button class="flt" data-sug="${esc(t)}">${esc(t)}</button>`).join('');
    }
    qTrendEl.onclick = (e)=>{
      const b=e.target.closest('[data-sug]'); if(!b) return;
      const q=b.getAttribute('data-sug'); qInput.value = q; qSearch.click();
    };
    refreshTrending(); setInterval(refreshTrending, 3600*1000);

    /* ---------------- 신고: 정책/프록시 ---------------- */
    let reportedComments = []; // 관리자 패널 표시용
    let unsubRepComments = null;

    const msToHuman = (ms)=>{
      if (!ms || ms<=0) return '해제됨';
      const h = Math.floor(ms/3600000);
      const m = Math.floor((ms%3600000)/60000);
      return h>0 ? `${h}시간 ${m}분 남음` : `${m}분 남음`;
    };

    const statusTextOf=(rc)=>{
      if (rc.hidden) return `가림 적용중 · ${msToHuman(rc.remainMs||0)}`;
      const age = nowMs() - (rc.firstReportAt||nowMs());
      const h = Math.floor(age/3600000), m = Math.floor((age%3600000)/60000);
      if (rc.eligible) return `가림 조건 충족(적용 대기) · 경과 ${h}시간 ${m}분 · 누적 ${rc.count}`;
      return `가림 조건 미충족 · 누적 ${rc.count||0}/${HIDE_COUNT} · 경과 ${h}시간 ${m}분`;
    };

    function sortReported(a,b){
      if (b.count!==a.count) return b.count - a.count;
      if (b.remainMs!==a.remainMs) return b.remainMs - a.remainMs;
      return a.firstReportAt - b.firstReportAt;
    }

    async function ensureCommentHidePolicy(markerId, commentId){
      try{
        const cs = await getDoc(doc(db,'markers', markerId, 'comments', commentId));
        if (!cs.exists()) return { hidden:false, count:0, first:null, eligible:false };
        const c = cs.data()||{};
        const count = c.reportPendingCount||0;
        const first = toMs(c.firstReportAt)||null;
        const eligible = (count>=HIDE_COUNT) || (!!first && (nowMs()-first)>=HIDE_DELAY_MS);
        if (eligible){
          const until = new Date(Date.now()+HIDE_MS);
          await updateDoc(cs.ref, { hiddenUntil: until });
          return { hidden:true, count, first, eligible };
        }else{
          await updateDoc(cs.ref, { hiddenUntil: null });
          return { hidden:false, count, first, eligible };
        }
      }catch(e){
        console.warn('[ensureCommentHidePolicy] error', e);
        return { hidden:false, error:e };
      }
    }

    async function ensureMarkerHidePolicy(markerId){
      try{
        const ms = await getDoc(doc(db,'markers', markerId));
        if (!ms.exists()) return { hidden:false, count:0, first:null, eligible:false };
        const m = ms.data()||{};
        const count = m.reportPendingCount||0;
        const first = toMs(m.firstReportAt)||null;
        const eligible = (count>=HIDE_COUNT) || (!!first && (nowMs()-first)>=HIDE_DELAY_MS);
        if (eligible){
          const until = new Date(Date.now()+HIDE_MS);
          await updateDoc(ms.ref, { hiddenUntil: until });
          const rec = markerMap.get(markerId);
          if (rec){ rec.data.hiddenUntil = until; applyVisibility(markerId); }
          return { hidden:true, count, first, eligible };
        }else{
          await updateDoc(ms.ref, { hiddenUntil: null });
          const rec = markerMap.get(markerId);
          if (rec){ rec.data.hiddenUntil = null; applyVisibility(markerId); }
          return { hidden:false, count, first, eligible };
        }
      }catch(e){
        console.warn('[ensureMarkerHidePolicy] error', e);
        return { hidden:false, error:e };
      }
    }

    // 관리자용 프록시: adminReports 컬렉션 구독 추가
    async function subscribeReportedCommentsAdmin(){
      if (unsubRepComments){unsubRepComments();unsubRepComments=null;}
      if (!firebaseOk || !isAdmin){
        reportedComments = []; renderReportedComments(); return;
      }

      const stops = [];

      // 1) 댓글의 reportPendingCount > 0
      stops.push(onSnapshot(query(collectionGroup(db,'comments'), where('reportPendingCount','>',0)),
        (snap)=> ingestCommentGroupSnap(snap),
        (err)=> console.warn('[rep-list count]', err)
      ));

      // 2) 숨김 상태 기준
      stops.push(onSnapshot(query(collectionGroup(db,'comments'), where('hiddenUntil','>', new Date())),
        (snap)=> ingestCommentGroupSnap(snap),
        (err)=> console.warn('[rep-list hidden]', err)
      ));

      // 3) 보류 report 기준
      stops.push(onSnapshot(query(collectionGroup(db,'reports'), where('status','==','pending')),
        async (snap)=>{
          const tasks = [];
          snap.forEach(d=>{
            const parentCommentRef = d.ref.parent.parent; // .../comments/{cid}
            if (!parentCommentRef) return;
            tasks.push(getDoc(parentCommentRef));
          });
          const parents = await Promise.all(tasks);
          const fakeSnap = { forEach: (fn)=> parents.forEach(ps=> { if(ps && ps.exists()) fn(ps); }) };
          ingestCommentGroupSnap(fakeSnap);
        },
        (err)=> console.warn('[rep-list reports]', err)
      ));

      // 4) 관리자 프록시 컬렉션 직접 구독
      stops.push(onSnapshot(collection(db,'adminReports'), snap=>{
        const now = nowMs();
        const idx = new Map(reportedComments.map(x=> [`${x.markerId}|${x.commentId}`, x]));
        snap.forEach(d=>{
          const docData = d.data()||{};
          const markerId = docData.markerId;
          const commentId = docData.commentId || null;
          const body = docData.body || '';
          const first = toMs(docData.createdAt) || now;
          const key = `${markerId}|${commentId}`;
          const merged = {
            markerId, commentId,
            body,
            firstReportAt:first,
            remainMs: 0,
            hidden: false,
            count: docData.reportPendingCount || 1,
            eligible: false,
            adminProxyId: d.id
          };
          idx.set(key, merged);
        });
        reportedComments = [...idx.values()].sort(sortReported);
        renderReportedComments();
      }, err=> console.warn('[adminReports]', err)));

      unsubRepComments = ()=> stops.forEach(s=> s());
    }

    // 그룹 스냅을 reportedComments(Map)로 병합
    function ingestCommentGroupSnap(snap){
      const now = nowMs();
      const idx = new Map(reportedComments.map(x=> [`${x.markerId}|${x.commentId}`, x]));
      snap.forEach(d=>{
        const p = d.ref.path.split('/'); // markers/{mid}/comments/{cid}
        if (!(p[0]==='markers' && p[2]==='comments')) return;
        const markerId = p[1], commentId = p[3];
        const c = d.data()||{};
        const first = toMs(c.firstReportAt)||now;
        const hidden = toMs(c.hiddenUntil) > now;
        const remainMs = hidden ? (toMs(c.hiddenUntil)-now) : 0;
        const count = c.reportPendingCount||0;
        const eligible = (count>=HIDE_COUNT) || (!!first && (now-first)>=HIDE_DELAY_MS);

        const key = `${markerId}|${commentId}`;
        const prev = idx.get(key)||{};
        const merged = {
          markerId, commentId,
          body: c.body || prev.body || '(본문 없음)',
          firstReportAt:first, remainMs, hidden, count, eligible
        };
        idx.set(key, merged);
      });
      reportedComments = [...idx.values()].sort(sortReported);
      renderReportedComments();
    }

    function renderReportedComments(){
      const repCommentList = document.getElementById('repCommentList');
      if (!adminReportMode){ repCommentList.innerHTML=''; return; }
      if (!reportedComments.length){
        repCommentList.innerHTML = `<div style="opacity:.7">신고 접수된 댓글이 없습니다.</div>`;
        return;
      }
      let list = Array.isArray(reportedComments) ? [...reportedComments] : [];
      if (repFilterMode==='eligible')   list = list.filter(x=> x.eligible);
      if (repFilterMode==='ineligible') list = list.filter(x=> !x.eligible);
      list.sort(sortReported);

      repCommentList.innerHTML = list.map(rc=>{
        const midSafe = rc && rc.markerId ? String(rc.markerId).slice(0,6) : '??????';
        const cidSafe = rc && rc.commentId ? rc.commentId : '';
        const bodySafe = rc && rc.body ? rc.body : '(본문 없음)';
        return `
          <div class="ritem" data-mid="${esc(rc?.markerId||'')}" data-cid="${esc(cidSafe)}" data-adminproxy="${esc(rc?.adminProxyId||'')}">
            <div style="font-weight:600">#${midSafe}… · 댓글</div>
            <div style="white-space:pre-wrap;margin-top:6px">${esc(bodySafe)}</div>
            <div class="meta">${esc(statusTextOf(rc||{}))}</div>
            <div class="act">
              <button class="rbtn" data-jump>해당 핀 보기</button>
              <button class="rbtn" data-dismiss>신고 반려</button>
              <button class="rbtn warn" data-delete>원문 삭제</button>
            </div>
          </div>
        `;
      }).join('');

      repCommentList.onclick = async (e)=>{
        const card = e.target.closest('.ritem'); if (!card) return;
        const markerId = card.getAttribute('data-mid');
        const commentId= card.getAttribute('data-cid') || null;
        const proxyId  = card.getAttribute('data-adminproxy') || null;

        if (e.target.matches('[data-jump]')){
          const rec = markerMap.get(markerId);
          if (rec){
            openInfoWithSeq(rec.data);
            setTimeout(()=>{
              if (commentId){
                const el = document.getElementById('c-'+commentId);
                if (el) el.scrollIntoView({behavior:'smooth', block:'center'});
              }
            }, 400);
          } else alert('해당 핀을 지도에서 찾을 수 없습니다.');
          return;
        }

        if (e.target.matches('[data-dismiss]')){
          try{
            if (proxyId){
              await deleteDoc(doc(db,'adminReports', proxyId));
            } else {
              try{
                const q = query(collection(db,'adminReports'), where('markerId','==', markerId), where('commentId','==', commentId));
                const s = await getDocs(q);
                await Promise.all(s.docs.map(d=> deleteDoc(d.ref)));
              }catch(_e){}
            }
            try{
              const q = query(collection(db,'markers', markerId, 'comments', commentId, 'reports'), where('status','==','pending'));
              const s = await getDocs(q);
              await Promise.all(s.docs.map(d=> updateDoc(d.ref, { status:'rejected', reviewedAt: serverTimestamp() })));
            }catch(_e){}
            await updateDoc(doc(db,'markers', markerId, 'comments', commentId), {
              hiddenUntil: null,
              reportPendingCount: 0,
              reportsBlocked: true
            });
            try{ await updateDoc(doc(db,'markers', markerId), { reportPendingCount: 0 }); }catch(_e){}
            alert('신고 반려 완료 — 원본 댓글의 신고 카운트/뱃지를 제거하고 추가 신고를 차단했습니다.');
          }catch(err){
            alert('반려 처리 실패: ' + (err?.message||err));
          }
        }

        if (e.target.matches('[data-delete]')){
          if (!confirm('관리자 권한으로 원본 댓글을 삭제하시겠습니까?')) return;
          try{
            await updateDoc(doc(db,'markers', markerId, 'comments', commentId), { deleted:true });
            if (proxyId) await deleteDoc(doc(db,'adminReports', proxyId));
            else {
              try{
                const q = query(collection(db,'adminReports'), where('markerId','==', markerId), where('commentId','==', commentId));
                const s = await getDocs(q);
                await Promise.all(s.docs.map(d=> deleteDoc(d.ref)));
              }catch(_e){}
            }
            alert('원본 댓글을 삭제했습니다.');
          }catch(err){ alert('삭제 실패: ' + (err?.message||err)); }
        }
      };
    }

    /* ---------------- 마커 구독/렌더 ---------------- */
    const markerMap=new Map(); // id -> {group, marker, data, seq}
    let unsubMain=null, unsubPending=null;

    function subscribeMarkers(){
      if (!firebaseOk) return;
      if (unsubMain){unsubMain();} if (unsubPending){unsubPending();}
      markerMap.forEach(({group, marker})=> group.removeLayer(marker));
      markerMap.clear();

      const qApproved=query(collection(db,'markers'), where('status','==','approved'));
      unsubMain=onSnapshot(qApproved, s=>{
        s.docChanges().forEach(renderChange);
        recomputeSeqs();
      });

      if (isAdmin){
        const qPending=query(collection(db,'markers'), where('status','==','pending'));
        unsubPending=onSnapshot(qPending, s=>{
          s.docChanges().forEach(renderChange);
          recomputeSeqs();
        });
      }
    }

    function renderChange(ch){
      const id=ch.doc.id;
      if (ch.type==='removed'){
        const prev=markerMap.get(id);
        if(prev){ prev.group.removeLayer(prev.marker); markerMap.delete(id); }
        return;
      }
      const m={id, ...ch.doc.data()};
      if (Array.isArray(m.pokemon) && !Array.isArray(m.pokemonNorm)) m.pokemonNorm = m.pokemon.map(normName);

      if (markerMap.has(id)){
        const prev=markerMap.get(id);
        prev.group.removeLayer(prev.marker);
        markerMap.delete(id);
      }
      const group = ensureCatGroup(m.category);
      const mk=L.marker([m.y, m.x], { icon: iconFor(m.category) }).addTo(group);
      mk.on('click', ()=>openInfoWithSeq(m));
      markerMap.set(id, {group, marker: mk, data:m, seq:null});
      applyVisibility(id);
    }

    function isHiddenByReport(m){ return toMs(m.hiddenUntil) > nowMs(); }
    function applyVisibility(id){
      const rec = markerMap.get(id); if (!rec) return;
      const {group, marker, data:m} = rec;

      if (adminReportMode){
        const ok = isHiddenByReport(m);
        if (ok){ if (!group.hasLayer(marker)) marker.addTo(group); }
        else   { if (group.hasLayer(marker)) group.removeLayer(marker); }
        return;
      }

      const catOn = catVisible.get(m.category) !== false;
      const hiddenForUser = isHiddenByReport(m) && !isAdmin;
      const txtOk = matchText(m);
      const statusOk = isAdmin ? (showPendingOnly ? m.status==='pending' : true) : (m.status==='approved');

      const ok = catOn && !hiddenForUser && txtOk && statusOk;
      if (ok){ if (!group.hasLayer(marker)) marker.addTo(group); }
      else   { if (group.hasLayer(marker)) group.removeLayer(marker); }
    }
    function applyAllVisibility(){ markerMap.forEach((_, id)=> applyVisibility(id)); }

    // 48시간 경과 자동 복귀(1분마다 재평가)
    setInterval(()=> { applyAllVisibility(); recomputeSeqs(); }, 60*1000);

    /* ---------------- 신고 흐름 변경: 프록시 생성 ---------------- */
    async function _touchFirstAtIfEmpty(refPath){
      const r = doc(db, ...refPath);
      const s = await getDoc(r);
      if (!s.exists()) return null;
      const d = s.data()||{};
      if (!d.firstReportAt) await updateDoc(r, { firstReportAt: serverTimestamp() });
      return r;
    }

    // 댓글 신고 제출 (유저)
    async function submitCommentReport(markerId, commentId, reason){
      const cref = doc(db,'markers', markerId, 'comments', commentId);
      const cs = await getDoc(cref);
      if (!cs.exists()){ alert('댓글이 삭제되었습니다.'); return; }
      const cd = cs.data()||{};
      if (cd.reportsBlocked){ alert('관리자에 의해 이 댓글은 신고가 차단되었습니다.'); return; }

      await addDoc(collection(db,'markers', markerId, 'comments', commentId, 'reports'), {
        type:'comment', markerId, commentId, uid: me?.uid||null, reason,
        status:'pending', createdAt: serverTimestamp()
      });

      await _touchFirstAtIfEmpty(['markers', markerId, 'comments', commentId]);
      await updateDoc(cref, { reportPendingCount: increment(1) });

      try{
        const body = cd.body || '(본문 없음)';
        await addDoc(collection(db,'adminReports'), {
          proxyType: 'comment',
          markerId, commentId,
          body,
          reporterUid: me?.uid || null,
          createdAt: serverTimestamp(),
          reportPendingCount: 1
        });
      }catch(_e){
        console.warn('[admin proxy create] failed', _e);
      }

      const res = await ensureCommentHidePolicy(markerId, commentId);
      if (res.hidden) alert('신고 누적/경과시간으로 댓글이 임시 숨김 처리되었습니다.');
      else alert('신고가 접수되었습니다. 조건 충족 시 자동으로 가려집니다.');
    }

    // 핀 신고 제출 (유저)
    async function reportMarker(m, reason){
      if (!firebaseOk) return { ok:false, hid:false };
      const mref = doc(db,'markers', m.id);
      const ms = await getDoc(mref);
      const md = ms.data()||{};
      if (md.reportsBlocked){ alert('관리자에 의해 이 핀은 신고가 차단되었습니다.'); return {ok:false, hid:false}; }

      try{
        await addDoc(collection(db,'markers', m.id, 'reports'), {
          type:'marker', markerId: m.id, uid: me?.uid||null, reason,
          status:'pending', createdAt: serverTimestamp()
        });
      }catch(_e){}

      await _touchFirstAtIfEmpty(['markers', m.id]);
      await updateDoc(mref, { reportPendingCount: increment(1) });

      try{
        await addDoc(collection(db,'adminReports'), {
          proxyType: 'marker',
          markerId: m.id,
          commentId: null,
          body: m.title || '(핀 신고)',
          reporterUid: me?.uid || null,
          createdAt: serverTimestamp(),
          reportPendingCount: 1
        });
      }catch(_e){ console.warn('[admin proxy create] failed', _e); }

      const res = await ensureMarkerHidePolicy(m.id);
      if (res.hidden) alert('신고 누적/경과시간으로 핀이 임시 숨김 처리되었습니다.');
      else alert('신고가 접수되었습니다. 조건 충족 시 자동으로 가려집니다.');
      return { ok:true, hid:!!res.hidden };
    }

    /* ---------- 동적 시퀀스 ---------- */
    function visibleForSeq(m){
      if (!m) return false;
      if (adminReportMode) return isHiddenByReport(m);
      if (isHiddenByReport(m) && !isAdmin) return false;
      if (catVisible.get(m.category) === false) return false;
      if (!matchText(m)) return false;
      const statusOk = isAdmin ? (showPendingOnly ? m.status==='pending' : true) : (m.status==='approved');
      return !!statusOk;
    }

    function recomputeSeqs(){
      const items = [];
      markerMap.forEach(({data}, id)=>{
        if (visibleForSeq(data)){
          const created = toMs(data.createdAt) ?? 0;
          items.push({ id, created });
        }
      });
      items.sort((a,b)=> (a.created||0) - (b.created||0));
      const seqById = new Map();
      for (let i=0;i<items.length;i++) seqById.set(items[i].id, i+1);

      markerMap.forEach((rec, id)=>{ rec.seq = seqById.get(id) ?? null; });
      if (currentOpenId && markerMap.has(currentOpenId)){
        const rec = markerMap.get(currentOpenId);
        document.getElementById('infoId').textContent = rec.seq ? '#'+rec.seq : '#-';
      }
    }

    /* ---------------- 상세 패널 + 캐러셀 + 댓글 ---------------- */
    const $info=document.getElementById('info');
    const $infoTitle=document.getElementById('infoTitle');
    const $infoId=document.getElementById('infoId');
    const $infoMeta=document.getElementById('infoMeta');
    const $infoBody=document.getElementById('infoBody');
    const $infoMediaTop=document.getElementById('infoMediaTop');
    const $infoBtns=document.getElementById('infoBtns');
    const $infoPk=document.getElementById('infoPk');

    const $carousel=document.getElementById('infoCarousel');
    const $carInner=document.getElementById('carInner');
    const $carPrev=document.getElementById('carPrev');
    const $carNext=document.getElementById('carNext');
    const $carDots=document.getElementById('carDots');
    let carIdx = 0, carItems = [];
    function buildCarousel(media){
      const rest = (media||[]).slice(1);
      if (!rest.length){ $carousel.style.display='none'; return; }
      $carousel.style.display='block';
      carItems = rest; carIdx = 0;
      $carInner.innerHTML = rest.map(m=>`<div class="item">${ m.type==='video' ? `<video controls src="${m.url}"></video>` : `<img src="${m.url}" alt="">` }</div>`).join('');
      $carDots.innerHTML = rest.map((_,i)=>`<div class="dot ${i===0?'on':''}" data-i="${i}"></div>`).join('');
      updateCarousel();
    }
    function updateCarousel(){
      const w = $carousel.clientWidth || 1;
      $carInner.style.transform = `translateX(${-carIdx * w}px)`;
      [...$carDots.children].forEach((d,i)=> d.classList.toggle('on', i===carIdx));
    }
    window.addEventListener('resize', updateCarousel);
    $carPrev.onclick = ()=>{ if (carItems.length){ carIdx = (carIdx - 1 + carItems.length) % carItems.length; updateCarousel(); } };
    $carNext.onclick = ()=>{ if (carItems.length){ carIdx = (carIdx + 1) % carItems.length; updateCarousel(); } };
    $carDots.onclick = (e)=>{ const d = e.target.closest('.dot'); if (!d) return; carIdx = +d.getAttribute('data-i') || 0; updateCarousel(); };

    // ===== 댓글 =====
    const $cForm = document.getElementById('cForm');
    const $cBody = document.getElementById('cBody');
    const $cSubmit = document.getElementById('cSubmit');
    const $cList = document.getElementById('cList');
    let unsubComments = null;

    function openComments(marker){
      if (!firebaseOk) { $cForm.style.display='none'; $cList.innerHTML=''; return; }
      if (unsubComments){unsubComments();unsubComments=null; }
      $cForm.style.display = me ? 'block':'none';
      $cBody.value='';
      const qC = query(collection(db,'markers', marker.id, 'comments'), orderBy('createdAt','asc'));
      unsubComments = onSnapshot(qC, async snap=>{
        const now = nowMs();
        const raw = [];
        snap.forEach(d=>{
          const c = { id:d.id, ...d.data() };
          const hidden = c.hiddenUntil ? (toMs(c.hiddenUntil) > now) : false;
          if (c.deleted) return;
          if (!isAdmin && hidden) return;   // 관리자는 숨김 댓글도 본다
          raw.push({ ...c, _hidden:hidden });
        });

        // 신고 배지/카운터
        const items = await Promise.all(raw.map(async c=>{
          let cnt = c.reportPendingCount || 0;
          try{
            if (!cnt){
              const q = query(collection(db,'markers', marker.id, 'comments', c.id, 'reports'), where('status','==','pending'));
              const s = await getDocs(q); cnt = s.size || 0;
            }
          }catch(_e){}
          return { ...c, _repCnt: cnt };
        }));

        $cList.innerHTML = items.map(c => `
          <div class="citem" id="c-${c.id}">
            <div class="meta">
              ${c.displayName || '익명'} · ${new Date(toMs(c.createdAt||Date.now())).toLocaleString()}
              ${c._repCnt>0 ? `<span class="badge-report">신고 ${c._repCnt}</span>`:''}
              ${c._hidden ? `<span class="badge-hidden">가림중</span>`:''}
            </div>
            <div class="body" style="white-space:pre-wrap; margin-top:6px">${esc(c.body||'')}</div>
            <div class="act">
              <button class="btn" data-crep="${c.id}">신고</button>
              ${(isAdmin || me?.uid===c.uid) ? `<button class="btn warn" data-cdel="${c.id}">삭제</button>`:''}
            </div>
          </div>`).join('');

        $cList.querySelectorAll('[data-crep]').forEach(btn=>{
          btn.onclick = async ()=>{
            if (!me){ alert('로그인이 필요합니다'); return; }
            const cid = btn.getAttribute('data-crep');
            const reason = prompt('댓글 신고 사유를 입력해주세요'); if (!reason) return;
            await submitCommentReport(marker.id, cid, reason);
          };
        });
        $cList.querySelectorAll('[data-cdel]').forEach(btn=>{
          btn.onclick = async ()=>{
            const cid = btn.getAttribute('data-cdel');
            if (!confirm('댓글을 삭제할까요?')) return;
            await updateDoc(doc(db,'markers', marker.id, 'comments', cid), { deleted:true });
          };
        });
      });

      $cSubmit.onclick = async ()=>{
        if (!me) { alert('로그인 후 작성할 수 있어요.'); return; }
        const body = ($cBody.value||'').trim();
        if (!body) return;
        await addDoc(collection(db,'markers', marker.id, 'comments'), {
          body, uid: me.uid, displayName: me.displayName || '익명',
          createdAt: serverTimestamp(), deleted:false,
          reportPendingCount: 0, reportsBlocked: false
        });
        $cBody.value='';
      };
    }

    function mediaTopEl(m){
      if (!m.media?.length) return '';
      const first=m.media[0];
      return (first.type==='video')
        ? `<video class="thumb" controls src="${first.url}"></video>`
        : `<img class="thumb" src="${first.url}" alt="thumb">`;
    }

    async function fetchMarkerPendingCount(markerId){
      try{
        const ms = await getDoc(doc(db,'markers', markerId));
        let cnt = (ms.exists() ? (ms.data().reportPendingCount||0) : 0);
        if (!cnt){
          const q = query(collection(db,'markers', markerId, 'reports'), where('status','==','pending'));
          const s = await getDocs(q); cnt = s.size||0;
        }
        return cnt;
      }catch(_e){ return 0; }
    }

    function openInfoWithSeq(m){
      const rec = markerMap.get(m.id);
      const seqNum = rec?.seq ?? null;
      openInfo(m, seqNum);
    }

    async function adminEditOrDelete(marker){
      const choice = prompt('관리자 작업을 선택하세요: edit / delete', 'edit');
      if (!choice) return;
      if (choice.toLowerCase()==='delete'){
        if (!confirm('이 핀을 완전히 삭제할까요?')) return;
        await deleteDoc(doc(db,'markers', marker.id));
        $info.style.display='none'; currentOpenId=null;
        return;
      }
      if (choice.toLowerCase()==='edit'){
        const newTitle = prompt('제목 수정', marker.title||'');
        if (newTitle===null) return;
        const newBody  = prompt('내용 수정', marker.body||'');
        if (newBody===null) return;
        try{
          await updateDoc(doc(db,'markers', marker.id), { title:newTitle, body:newBody });
          alert('수정되었습니다.');
        }catch(e){
          alert('수정 실패: ' + (e?.message||e));
        }
      }
    }

    async function openInfo(m, seqNum){
      currentOpenId=m.id;
      const $infoTitle=document.getElementById('infoTitle');
      const $infoId=document.getElementById('infoId');
      const $infoMeta=document.getElementById('infoMeta');
      const $infoMediaTop=document.getElementById('infoMediaTop');
      const $infoBody=document.getElementById('infoBody');
      const $infoPk=document.getElementById('infoPk');
      const $infoBtns=document.getElementById('infoBtns');

      $infoTitle.textContent=m.title||'(제목 없음)';
      $infoId.textContent = seqNum ? '#'+seqNum : '#-';
      const statusText = m.status || 'pending';

      // 핀 신고 뱃지(누적)
      const pinRepCnt = await fetchMarkerPendingCount(m.id);
      $infoMeta.innerHTML = `
        <span>${labelFor(m.category)} · by ${esc(m.displayName||'익명')} · ${statusText}</span>
        ${pinRepCnt>0 ? `<span class="badge">신고 ${pinRepCnt}</span>`:''}
      `;

      $infoMediaTop.innerHTML = mediaTopEl(m);
      $infoBody.textContent = m.body||'';

      const pokemonCats = ['와일드 존','우두머리 포켓몬','메가 포켓몬'];
      if (pokemonCats.includes(m.category) && Array.isArray(m.pokemon) && m.pokemon.length){
        $infoPk.style.display='flex';
        $infoPk.innerHTML = m.pokemon.map(n=>`<span class="tag" data-pk="${esc(n)}">${esc(n)}</span>`).join('');
        $infoPk.onclick = (e)=>{
          const t = e.target.closest('.tag[data-pk]'); if(!t) return;
          const name = t.getAttribute('data-pk');
          document.getElementById('qInput').value = name;
          setOnlyPokemonCats();
          applyTextFilter(name);
          alert(`"${name}" 출현 보고 핀만 표시합니다. (와일드/우두머리/메가)`);
        };
      } else { $infoPk.style.display='none'; $infoPk.innerHTML=''; }

      buildCarousel(m.media || []);

      const isMine = me && me.uid===m.authorUid;
      const canEdit = isMine && (m.status==='pending'||m.status===undefined);
      const hiddenNow = isHiddenByReport(m);

      $infoBtns.innerHTML = `
        <button id="btnReport" class="primary">핀 신고</button>
        ${canEdit ? `<button id="btnEdit">수정</button><button id="btnDel" class="warn">삭제</button>`:''}
        ${isAdmin ? `
            ${m.status==='pending'
              ? `<button id="btnAppr" class="primary">승인</button><button id="btnReject" class="warn">반려</button>`
              : ``}
            <button id="btnAdminDel" class="warn">관리자 삭제</button>
            <button id="btnReportDismiss" class="">신고 반려/차단</button>
            ${hiddenNow ? `<button id="btnUnhideNow">숨김 해제</button>`:''}
          ` : ``}
      `;

      const btnR=document.getElementById('btnReport');
      if (btnR) btnR.onclick = async ()=>{
        if (!me){ alert('로그인이 필요합니다'); return; }
        const reason = prompt('신고 사유를 입력해주세요'); if(!reason) return;
        try{
          const res = await reportMarker(m, reason);
          if (res.ok && !res.hid){ /* 안내는 reportMarker에서 */ }
          $info.style.display='none'; currentOpenId=null;
        }catch(err){ alert('신고 처리 중 오류: ' + (err?.message||err)); }
      };

      const btnE=document.getElementById('btnEdit');
      if (btnE) btnE.onclick=async()=>{
        if (!firebaseOk) return;
        const nt=prompt('제목 수정', m.title||''); if (nt===null) return;
        const nb=prompt('내용 수정', m.body||''); if (nb===null) return;
        await updateDoc(doc(db,'markers', m.id), { title:nt, body:nb });
      };

      const btnD=document.getElementById('btnDel');
      if (btnD) btnD.onclick=async()=>{
        if (!firebaseOk) return;
        if (!confirm('삭제할까요?')) return;
        await deleteDoc(doc(db,'markers', m.id));
        $info.style.display='none'; currentOpenId=null;
      };

      const btnAdminDel=document.getElementById('btnAdminDel');
      if (btnAdminDel) btnAdminDel.onclick = async ()=>{
        if (!firebaseOk) return;
        if (!confirm('이 핀을 완전히 삭제할까요?')) return;
        await deleteDoc(doc(db,'markers', m.id));
        $info.style.display='none'; currentOpenId=null;
      };

      const btnA=document.getElementById('btnAppr');
      if (btnA) btnA.onclick=async()=>{
        if (!firebaseOk) return;
        btnA.disabled=true; btnA.textContent='승인중...';
        try{ await updateDoc(doc(db,'markers', m.id), { status:'approved' }); }
        finally{ btnA.disabled=false; btnA.textContent='승인'; }
      };

      const btnRe=document.getElementById('btnReject');
      if (btnRe) btnRe.onclick=async()=>{
        if (!firebaseOk) return;
        btnRe.disabled=true; btnRe.textContent='반려중...';
        try{ await updateDoc(doc(db,'markers', m.id), { status:'rejected' }); }
        finally{ btnRe.disabled=false; btnRe.textContent='반려'; }
      };

      const btnReportDismiss = document.getElementById('btnReportDismiss');
      if (btnReportDismiss) btnReportDismiss.onclick = async ()=>{
        try{
          try{
            const q = query(collection(db,'markers', m.id, 'reports'), where('status','==','pending'));
            const s = await getDocs(q);
            await Promise.all(s.docs.map(d=> updateDoc(d.ref, { status:'rejected', reviewedAt: serverTimestamp() })));
          }catch(_e){}
          await updateDoc(doc(db,'markers', m.id), { hiddenUntil: null, reportPendingCount: 0, reportsBlocked: true });
          try{
            const q2 = query(collection(db,'adminReports'), where('markerId','==', m.id));
            const s2 = await getDocs(q2);
            await Promise.all(s2.docs.map(d=> deleteDoc(d.ref)));
          }catch(_e){}
          const rec = markerMap.get(m.id);
          if (rec){ rec.data.hiddenUntil = null; rec.data.reportPendingCount=0; rec.data.reportsBlocked=true; applyVisibility(m.id); }
          alert('핀 신고를 반려하고, 추가 신고를 차단했습니다.');
        }catch(e){
          alert('처리 실패: ' + (e?.message||e));
        }
      };

      const btnUnhideNow = document.getElementById('btnUnhideNow');
      if (btnUnhideNow) btnUnhideNow.onclick = async ()=>{
        try{
          await updateDoc(doc(db,'markers', m.id), { hiddenUntil: null });
          const rec = markerMap.get(m.id);
          if (rec){ rec.data.hiddenUntil = null; applyVisibility(m.id); }
          alert('숨김을 해제했습니다.');
        }catch(e){
          alert('해제 실패: ' + (e?.message||e));
        }
      };

      $info.style.display='block';
      openComments(m);
    }

    const $infoClose=document.getElementById('infoClose');
    let currentOpenId=null;
    $infoClose.onclick=()=>{ $info.style.display='none'; currentOpenId=null; if (unsubComments){unsubComments();unsubComments=null;} };

    /* ---------------- 모드 전환 ---------------- */
    let mode='search';
    const btnSearch=document.getElementById('btnSearch');
    const btnPlace =document.getElementById('btnPlace');
    function setMode(m){
      mode=m;
      btnSearch.classList.toggle('on', m==='search');
      btnPlace.classList.toggle('on',  m==='place');
      if (!adminReportMode) side.style.display = (m==='search') ? 'block':'none';
    }
    btnSearch.onclick=()=> setMode('search');
    btnPlace.onclick =()=> {
      const msg = '핀 배치모드에서 배치하게 된 핀은 심사를 거쳐 모두에게 공개됩니다.\n신중히, 사실만을 작성하여 주세요.\n\n핀 배치모드로 전환하시겠습니까?';
      if (confirm(msg)) setMode('place');
    };
    setMode('search');

    /* ---------------- 입력/저장 ---------------- */
    const modal=document.getElementById('modal');
    const t=document.getElementById('mTitle');
    const b=document.getElementById('mBody');
    const nickSel=document.getElementById('mNickSel');
    const nickCus=document.getElementById('mNickCustom');
    const imgsInp=document.getElementById('mImgs');
    const videoInp=document.getElementById('mVideo');

    document.getElementById('cancelBtn').onclick=()=>{ modal.style.display='none'; pending=null; };
    modal.addEventListener('click', (e)=>{ if(e.target===modal){ modal.style.display='none'; pending=null; } });
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal.style.display==='flex'){ modal.style.display='none'; pending=null; } });

    // ❗ 문법 오류 수정: 흰 화면 방지
    nickSel.onchange = () => {
      nickCus.style.display = (nickSel.value==='custom') ? 'block' : 'none';
    };

    // 포켓몬 편집기
    const pkEditor = document.getElementById('pkEditor');
    const pkAddInput = document.getElementById('pkAddInput');
    const pkAddBtn = document.getElementById('pkAddBtn');
    const pkAddClear = document.getElementById('pkAddClear');
    const pkChips = document.getElementById('pkChips');
    let pkList = [];
    function redrawPkChips(){ pkChips.innerHTML = pkList.map((n,i)=>`<span class="tag" data-i="${i}">${esc(n)} ✕</span>`).join(''); }
    function addPk(){ const v=(pkAddInput.value||'').trim(); if(!v) return; if(!pkList.some(x=>normName(x)===normName(v))) pkList.push(v); pkAddInput.value=''; redrawPkChips(); }
    pkAddBtn.onclick = addPk;
    pkAddInput.addEventListener('keydown', e=>{ if(e.key==='Enter') addPk(); });
    pkAddClear.onclick = ()=>{ pkList=[]; redrawPkChips(); };

    const pokemonCats = ['와일드 존','우두머리 포켓몬','메가 포켓몬'];
    catSel.addEventListener('change', ()=>{ pkEditor.style.display = pokemonCats.includes(catSel.value) ? 'block' : 'none'; });

    let pending=null;
    map.on('click', (e)=>{
      if (mode!=='place') return;
      if(!me){ alert('로그인 후 등록할 수 있어요.'); return; }
      if(!isInside(e.latlng)){ alert('맵 바깥에는 등록할 수 없습니다'); return; }
      pending=e.latlng;
      t.value=''; b.value=''; imgsInp.value=''; videoInp.value='';
      pkList=[]; redrawPkChips();
      if (!catSel.value) catSel.value=CATEGORIES[0].key;
      pkEditor.style.display = pokemonCats.includes(catSel.value) ? 'block' : 'none';
      modal.style.display='flex';
    });

    document.getElementById('saveBtn').onclick = async () => {
      if (!me || !pending) return;
      if (!firebaseOk) { alert('네트워크 차단으로 저장 불가'); return; }

      const imgFiles = imgsInp.files ? Array.from(imgsInp.files) : [];
      const vidFile  = (videoInp.files && videoInp.files[0]) ? videoInp.files[0] : null;

      const saveBtn = document.getElementById('saveBtn');
      const setBtn  = (t)=> saveBtn.textContent = t;
      const prevTxt = saveBtn.textContent;
      saveBtn.disabled = true;
      try {
        let displayName='익명';
        if (nickSel.value==='me') displayName = me.displayName || '익명';
        else if (nickSel.value==='custom') displayName = (nickCus.value||'').trim() || '익명';

        const media=[];
        for (let i=0;i<imgFiles.length;i++){
          const url = await globalThis.uploadSmart(imgFiles[i], 'markerMedia', setBtn, `이미지 ${i+1}/${imgFiles.length}`);
          media.push({type:'image', url});
        }
        if (vidFile){
          const url = await globalThis.uploadSmart(vidFile, 'markerMedia', setBtn, '동영상');
          media.push({type:'video', url});
        }

        const thumbUrl = media.length ? media[0].url : null;

        setBtn('저장 중…');
        const inPkCat = pokemonCats.includes(catSel.value);
        await addDoc(collection(db,'markers'), {
          x: pending.lng, y: pending.lat,
          title: t.value, body: b.value,
          category: catSel.value,
          media, thumbUrl, // null 가능
          displayName, authorUid: me.uid,
          createdAt: serverTimestamp(),
          status: 'pending',
          hiddenUntil: null,
          reportPendingCount: 0, reportsBlocked: false,
          ...(inPkCat ? { pokemon: pkList, pokemonNorm: pkList.map(normName) } : {})
        });
        modal.style.display='none'; pending=null;
        setBtn('등록 완료!'); setTimeout(()=>{ saveBtn.disabled=false; setBtn(prevTxt); }, 700);
      } catch (err) {
        alert('저장 실패: ' + (err?.message||err));
        saveBtn.disabled=false; setBtn(prevTxt);
      }
    };

    /* ---------------- 텍스트 매칭 ---------------- */
    function matchText(m){
      if (!textFilter) return true;
      const q = textFilter;
      const base = norm(`${m.title||''} ${m.body||''}`);
      if (base.includes(q)) return true;
      const qn = normName(q);
      if (Array.isArray(m.pokemonNorm) && m.pokemonNorm.some(p => p.includes(qn))) return true;
      return false;
    }

    // 초기 구독
    subscribeMarkers();
    subscribeReportedCommentsAdmin();
  </script>
</body>
  </html>
