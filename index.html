<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />  
  <title>ZA 한글 공략 맵</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height:100%; margin:0; }
    #map { position: relative; z-index: 0; background:#e9eaec; }
    .bar{
      position:fixed; left:10px; top:10px; z-index:1400;
      background:#111a; color:#fff; padding:8px 10px; border-radius:10px; font-size:14px;
      display:flex; gap:8px; align-items:center;
      -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);
    }
    .bar button{margin:0}
    #adminBadge{display:none;background:#ffd54f;color:#111;padding:2px 6px;border-radius:8px}
    .tbtn{background:#2a2f3a;color:#ddd;border:0;border-radius:8px;padding:6px 10px;cursor:pointer}
    .tbtn.on{background:#3d6cff;color:#fff}

    /* 우측 상단 컨트롤 (건의/공지/메신저) */
    .top-right {
      position: fixed; right:10px; top:10px; z-index: 1400;
      display:flex; gap:8px; align-items:center;
    }
    .pill-btn { position:relative; background:#2a2f3a; color:#ddd; border:0; border-radius:999px; padding:6px 12px; cursor:pointer }
    .pill-btn.on { background:#3d6cff; color:#fff }
    .pill-btn .bang { position:absolute; left:-6px; top:-6px; width:16px; height:16px; border-radius:50%; background:#ff5252; color:#fff; font-size:11px; display:none; align-items:center; justify-content:center }
    .pill-btn .bang.show { display:flex }

    /* 좌측 검색 사이드 */
    #side{
      position:fixed; z-index:1300; left:10px; top:60px; bottom:10px;
      width:20vw; min-width:240px; max-width:420px;
      display:none; background:#1c1f27; color:#d6d9e0; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.25);
      padding:12px; overflow:auto;
    }
    #side h3{margin:6px 0 10px 4px; font-size:16px; color:#fff}
    .flt-wrap{display:flex; flex-wrap:wrap; gap:8px}
    .flt{
      border:1px solid #303645; background:#202532; color:#c9cfdd; padding:6px 10px;
      border-radius:999px; cursor:pointer; font-size:13px; position:relative;
    }
    .flt.on{background:#3d6cff; border-color:#3d6cff; color:#fff}
    /* 진행도: 더 작게, 기본은 숨김 */
    .flt .progress{
      position:absolute;
      bottom:2px; left:50%; transform:translateX(-50%);
      font-size:9px; opacity:.75; display:none;
    }
    /* 해당 카테고리가 ON일 때만 표시 */
    .flt.on .progress{ display:block }

    .hr{height:1px; background:#2a3040; margin:12px 0}
    .inp{width:100%; box-sizing:border-box; background:#1117; color:#eef; border:1px solid #303645; border-radius:10px; padding:8px}
    .row{display:flex; gap:8px; align-items:center}

    /* 신고 관리 모드 전용 리스트 */
    .rlist{display:grid; gap:8px}
    .ritem{background:#1f2430;border:1px solid #2f3647;border-radius:10px;padding:10px}
    .ritem .meta{font-size:12px;color:#9fb0c0;margin-top:4px}
    .ritem .act{display:flex;gap:8px;margin-top:8px}
    .rbtn{background:#2a2f3a;color:#fff;border:0;padding:6px 10px;border-radius:8px;cursor:pointer}
    .rbtn.warn{background:#ff5252}
    .rep-sort{display:flex;gap:6px;flex-wrap:wrap;margin:6px 0 8px}
    .rep-sort .flt{padding:4px 10px}
    .rep-filt{display:flex;gap:6px;flex-wrap:wrap;margin:4px 0 8px}
    .rep-filt .flt{padding:3px 10px}

    /* 우하단 상세 패널 */
    #info{position:fixed; right:10px; bottom:10px; width:420px; max-height:75%;
      overflow:auto; z-index:1500; display:none; background:#1e1e1e; color:#ddd;
      border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.35);}
    #info header{display:flex; align-items:center; gap:8px; padding:10px 12px; border-bottom:1px solid #333; flex-wrap:wrap}
    #info .thumb{width:100%; max-height:260px; object-fit:cover; background:#000}
    #info .pad{padding:12px}
    #info .meta{font-size:12px; color:#aaa; display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    #info .badge{background:#ff9800;color:#111;padding:2px 6px;border-radius:6px;font-size:11px}
    #info .btns{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px}
    #info button{background:#2a2a2a; color:#fff; border:0; padding:6px 10px; border-radius:8px; cursor:pointer}
    #info button.primary{background:#3d6cff}
    #info button.warn{background:#ff5252}
    #info .media video{width:100%; max-height:260px}
    #info .media img{width:100%; max-height:260px; object-fit:cover}
    #info .idtag{background:#263238; color:#cfd8dc; padding:2px 6px; border-radius:6px; font-size:11px}
    #info .view-count{font-size:11px; color:#888; margin-left:auto}
    .pk-tags{display:flex; flex-wrap:wrap; gap:6px; margin-top:6px}
    .pk-tags .tag{background:#223; border:1px solid #345; color:#cfe; padding:2px 8px; border-radius:999px; font-size:12px; cursor:pointer}
    
    /* 캐러셀 */
    .carousel{ position:relative; width:100%; margin-top:12px; background:#141414; border-radius:10px; overflow:hidden }
    .carousel .inner{ display:flex; transition: transform .3s ease }
    .carousel .item{ min-width:100%; display:flex; align-items:center; justify-content:center; background:#000 }
    .carousel .item img, .carousel .item video{ width:100%; max-height:420px; object-fit:contain; background:#000 }
    .carousel .nav{
      position:absolute; top:50%; transform:translateY(-50%);
      background:#000a; color:#fff; border:0; width:38px; height:38px; border-radius:50%; cursor:pointer;
      display:flex; align-items:center; justify-content:center; font-size:18px;
    }
    .carousel .prev{ left:8px } .carousel .next{ right:8px }
    .carousel .dots{ position:absolute; left:0; right:0; bottom:6px; display:flex; justify-content:center; gap:6px }
    .carousel .dot{ width:8px; height:8px; border-radius:50%; background:#6a6a6a; }
    .carousel .dot.on{ background:#fff }
    
    /* 댓글 */
    #comments{ margin-top:12px; }
    #comments .cform textarea{ width:100%; box-sizing:border-box; background:#111; color:#eee; border:1px solid #333; border-radius:8px; padding:8px }
    #comments .cform .row{ display:flex; gap:8px; margin-top:8px }
    #comments .cform button{ background:#3d6cff; border:0; color:#fff; padding:6px 10px; border-radius:8px }
    #comments .clist{ margin-top:10px; display:grid; gap:10px }
    .citem{ background:#151515; border:1px solid #2a2a2a; border-radius:10px; padding:10px; opacity:1; transition:opacity .2s }
    .citem.inactive{ opacity:0.4 }
    .citem .meta{ font-size:12px; color:#aaa; display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .citem .meta .clickable{ cursor:pointer; text-decoration:underline }
    .citem .act{ display:flex; gap:8px; margin-top:6px }
    .citem .btn{ background:#2a2a2a; color:#fff; border:0; padding:4px 8px; border-radius:8px; cursor:pointer }
    .citem .btn.warn{ background:#ff5252 }
    .citem .reactions{display:flex; gap:4px; margin-top:6px; font-size:11px}
    .citem .reactions span{background:#2a2a2a; padding:2px 6px; border-radius:4px}
    .badge-report{background:#ff9800;color:#111;padding:2px 6px;border-radius:6px;font-size:11px}
    .badge-hidden{background:#90caf9;color:#111;padding:2px 6px;border-radius:6px;font-size:11px}

    /* 반응 컨텍스트 메뉴 */
    .reaction-menu{
      position:fixed; background:#1e1e1e; border:1px solid #333; border-radius:8px; padding:8px;
      display:none; z-index:2000; box-shadow:0 4px 12px rgba(0,0,0,.5)
    }
    .reaction-menu button{
      background:transparent; border:0; color:#fff; padding:4px 8px; cursor:pointer;
      font-size:16px; border-radius:4px
    }
    .reaction-menu button:hover{background:#2a2a2a}

    /* 입력/설정 모달 (기본 숨김 대상 전체 명시) */
    #modal,#profileModal,#messengerModal,#noticeModal,#noticeListModal,#suggestModal,#suggestListModal,#achievementModal,#missionsModal,#otherProfileModal,#trustHistoryModal,#achievementListModal{
      display:none; position:fixed; inset:0; background:#0008; align-items:center; justify-content:center; z-index:1500;
    }
    .panel{background:#1e1e1e;color:#fff;padding:16px;border-radius:12px;width:380px; max-height:85vh; overflow:auto}
    .panel.wide{width:min(720px, 96vw)}
    .panel input,.panel textarea,.panel select{width:100%; box-sizing:border-box}
    small.muted{color:#a0a7b4}

    /* XP 바 */
    .xp-bar{
      background:#2a2a2a; border-radius:8px; height:20px; position:relative; overflow:hidden; margin:8px 0
    }
    .xp-bar-fill{
      background:linear-gradient(90deg, #3d6cff, #5d8cff); height:100%; transition:width .3s ease
    }
    .xp-bar-text{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      font-size:11px; font-weight:600; color:#fff; text-shadow:0 1px 2px rgba(0,0,0,.5)
    }

    /* 업적 배지 */
    .achievement-badge{
      display:inline-block; padding:4px 8px; border-radius:6px; font-size:11px; margin:2px;
      background:#2a2a2a; border:1px solid #444
    }
    .achievement-badge.normal{border-color:#888; background:#333}
    .achievement-badge.rare{border-color:#4a9eff; background:#1a3a5f}
    .achievement-badge.epic{border-color:#a335ee; background:#3a1a5f}
    .achievement-badge.legend{border-color:#ff8000; background:#5f3a1a}

    /* 미션 */
    .mission-item{
      background:#2a2a2a; border:1px solid #444; border-radius:8px; padding:10px; margin:8px 0;
      display:flex; justify-content:space-between; align-items:center
    }
    .mission-item.completed{opacity:.5}
    .mission-item .mission-reward{color:#4a9eff; font-size:11px}

    /* 신뢰도 색상 */
    .trust-negative{color:#ff5252}
    .trust-positive{color:#4caf50}

    /* 얌전한 인앱 안내 배너 */
    #inapp-banner {
      position: fixed; top: 0; left: 0; right: 0; z-index: 2999;
      background: linear-gradient(90deg,#0f172aee,#111827ee);
      color: #e5e7eb; font-size: 13px; line-height: 1.4;
      padding: 10px 12px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,.35);
    }
    #inapp-banner strong{ color:#fff; font-weight:600 }

    /* 공지 특수 메시지 */
    .sys-notice {
      background:#0b3a70; color:#e6f1ff; border-radius:12px; padding:16px; margin:8px 0;
    }
    .sys-notice h4{ margin:0 0 6px 0; font-size:16px }
    .sys-notice p{ margin:0; opacity:.9; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
    .sys-notice .view-count{font-size:11px; opacity:.8; margin-top:4px}

    /* 메신저 채팅 버블 */
    .chat-wrap { max-height:60vh; overflow:auto; background:#0f1116; border:1px solid #2b3143; border-radius:12px; padding:12px }
    .chat-row { display:flex; margin:6px 0 }
    .chat-row.me { justify-content:flex-start }
    .chat-row.other { justify-content:flex-end }
    .bubble { max-width:70%; background:#1f2430; color:#e5e7eb; padding:8px 10px; border-radius:12px }
    .chat-row.other .bubble { background:#293146 }
    .chat-meta { font-size:11px; color:#aab; margin-top:4px }

    /* 요주의 유저 섹션 */
    .warning-users{background:#3a1f1f; border:1px solid #5f2f2f; border-radius:8px; padding:10px; margin:10px 0}
    .warning-users h4{margin:0 0 8px 0; color:#ff8a80}
    
    /* 업적 팝업 */
    .achievement-popup{
      position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
      background:#1e1e1e; border:2px solid #ffd700; border-radius:12px; padding:20px;
      z-index:3000; min-width:300px; text-align:center; animation:popIn .3s ease
    }
    @keyframes popIn{
      from{transform:translate(-50%,-50%) scale(.8); opacity:0}
      to{transform:translate(-50%,-50%) scale(1); opacity:1}
    }
  </style>
</head>
<body>
  <!-- 외부 스크립트 차단 경고 -->
  <div id="blockWarn" style="display:none;position:fixed;inset:0;background:#000a;z-index:3000;
  align-items:center;justify-content:center;color:#fff;padding:20px;text-align:center">
    외부 스크립트가 차단되어 페이지가 작동하지 않습니다.<br>
    광고차단/보안DNS/브라우저 보호기능을 끄고 새로고침 해주세요.
  </div>
  <script> setTimeout(()=>{ if(!window.L){ document.getElementById('blockWarn').style.display='flex'; } }, 1500); </script>

  <!-- 인앱 브라우저 감지 -->
  <script>
  (function(){
    const PATTERNS = [/KAKAOTALK/i, /Line\//i, /Instagram/i, /FBAN|FBAV/i, /Twitter/i, /Snapchat/i, /MicroMessenger/i];
    const isInApp = PATTERNS.some(r => r.test(navigator.userAgent||''));
    if (!isInApp) return;
    const banner = document.createElement('div');
    banner.id = 'inapp-banner';
    banner.innerHTML = '<strong>안내</strong> · 앱 내 브라우저에서 접속 중입니다. ' +
      '일부 기능(특히 <strong>Google 로그인/업로드/팝업</strong>)이 제한되거나 동작하지 않을 수 있어요. ' +
      'Chrome/Safari 등 <strong>외부 브라우저 이용</strong>을 권장합니다.';
    document.body.appendChild(banner);
  })();
  </script>

  <div class="bar" role="toolbar" aria-label="상단 도구막대">
    <span id="who">로그인 안 됨</span>
    <button id="login" title="Google 로그인">Google 로그인</button>
    <button id="logout" style="display:none" title="로그아웃">로그아웃</button>
    <button id="btnProfile" class="tbtn" style="display:none" title="프로필 설정">프로필</button>
    <span id="adminBadge" aria-label="관리자">관리자</span>
    <span style="width:1px;height:20px;background:#2f3545;margin:0 6px"></span>
    <button id="btnSearch" class="tbtn on" title="검색 모드(S)">검색 모드</button>
    <button id="btnPlace"  class="tbtn" title="핀 배치 모드(M)">핀 배치 모드</button>
    <button id="btnAdminReport" class="tbtn" style="display:none" title="신고 관리 모드">신고 관리 모드</button>
    <button id="btnPendingOnly" class="tbtn" style="display:none" title="승인 대기 핀">승인 대기 핀</button>
  </div>

  <!-- 우측 상단: 건의 / 공지 / 메신저 -->
  <div class="top-right">
    <button id="btnSuggestList" class="pill-btn" title="건의 및 문의">건의 및 문의</button>
    <button id="btnNoticeList" class="pill-btn" title="공지 목록">공지</button>
    <button id="btnMsg" class="pill-btn" style="display:none" title="관리진 메신저">메세지 <span class="bang" id="msgBang">!</span></button>
  </div>

  <!-- 좌측 사이드 -->
  <aside id="side" aria-label="검색 사이드바">
    <div id="sideCats">
      <h3>카테고리 필터</h3>
      <div class="flt-wrap" id="fltList"></div>

      <h3>특수 레이어</h3>
      <div class="flt-wrap">
        <button id="fltWild" class="flt on" title="와일드 존 레이어 토글">와일드 존</button>
        <button id="fltAll" class="flt" title="전체 선택">전체 선택</button>
        <button id="fltNone" class="flt" title="전체 해제">전체 해제</button>
      </div>
    </div>

    <!-- 신고 관리 모드 -->
    <div id="sideReports" style="display:none">
      <h3>신고된 댓글</h3>
      <div class="rep-sort" id="repSortBar">
        <button class="flt on" data-sort="mix">종합</button>
        <button class="flt" data-sort="count">누적횟수</button>
        <button class="flt" data-sort="remain">남은숨김시간</button>
        <button class="flt" data-sort="oldest">오래된신고</button>
      </div>
      <div class="rep-filt" id="repFiltBar">
        <button class="flt on" data-filt="all">전체</button>
        <button class="flt" data-filt="eligible">가림조건충족</button>
        <button class="flt" data-filt="ineligible">미충족</button>
      </div>
      <div id="repCommentList" class="rlist"></div>
      
      <div class="warning-users">
        <h4>⚠️ 요주의 유저</h4>
        <div id="warningUserList" style="font-size:12px"></div>
      </div>
      
      <div class="hr"></div>
      <div style="font-size:12px;opacity:.8">관리자용 프록시와 댓글/숨김/보류 리포트를 병합해 표시합니다.</div>
    </div>

    <div class="hr"></div>
    <h3>통합 검색</h3>
    <div class="row" style="align-items:stretch">
      <input id="qInput" class="inp" placeholder="제목/내용에서 검색" aria-label="검색어 입력 (/)로 포커스" />
      <button id="qSearch" class="flt" title="검색">검색</button>
      <button id="qClear" class="flt" title="초기화">초기화</button>
    </div>
    <div style="margin-top:8px; font-size:12px; opacity:.85">최근 7일 인기 검색어</div>
    <div id="qTrending" class="flt-wrap" style="margin-top:6px"></div>
  </aside>

  <div id="map" role="application" aria-label="게임 월드 지도"></div>

  <!-- 반응 메뉴 -->
  <div id="reactionMenu" class="reaction-menu">
    <button data-emoji="👍">👍</button>
    <button data-emoji="😕">😕</button>
    <button data-emoji="❤️">❤️</button>
    <button data-emoji="❓">❓</button>
    <button data-emoji="❗">❗</button>
    <button data-emoji="✓">✓</button>
    <button data-emoji="✘">✘</button>
  </div>

  <!-- 우하단 상세 패널 -->
  <aside id="info" aria-live="polite">
    <header>
      <h3 id="infoTitle">(제목)</h3>
      <span id="infoId" class="idtag">#-</span>
      <button id="btnConfirm" title="확인 표시">✓</button>
      <span class="view-count" id="pinViewCount">조회 -</span>
      <button id="copyLinkBtn" title="이 핀 링크 복사">링크복사</button>
      <button id="infoClose" title="닫기(Esc)">닫기</button>
    </header>
    <div class="media" id="infoMediaTop"></div>
    <div class="pad">
      <div class="meta" id="infoMeta"></div>
      <div id="infoPk" class="pk-tags"></div>
      <div id="infoBody" style="white-space:pre-wrap; margin-top:8px"></div>
      <div id="pinReactions" class="reactions"></div>

      <div id="infoCarousel" class="carousel" style="display:none">
        <div class="inner" id="carInner"></div>
        <button class="nav prev" id="carPrev" aria-label="이전">‹</button>
        <button class="nav next" id="carNext" aria-label="다음">›</button>
        <div class="dots" id="carDots"></div>
      </div>

      <!-- 댓글 -->
      <div id="comments">
        <div class="cform" id="cForm" style="display:none">
          <textarea id="cBody" rows="3" placeholder="댓글을 입력하세요"></textarea>
          <div class="row"><button id="cSubmit">댓글 등록</button></div>
        </div>
        <div class="clist" id="cList"></div>
      </div>

      <div class="btns" id="infoBtns" style="margin-top:12px"></div>
    </div>
  </aside>

  <!-- 마커 입력 모달 -->
  <div id="modal">
    <div class="panel">
      <h3>마커 추가 (검수 대기)</h3>
      <input id="mTitle" class="inp" placeholder="제목" />
      <textarea id="mBody" class="inp" rows="4" placeholder="공략/설명(줄바꿈 가능)"></textarea>

      <label style="display:block;margin-top:8px">카테고리</label>
      <select id="mCat" class="inp"></select>
      <small class="muted">카테고리 아이콘은 Firestore <code>categories/{카테고리키}.iconUrl</code>로 전역 변경</small>

      <!-- 기술머신 -->
      <div id="tmEditor" style="display:none; margin-top:10px">
        <label>기술머신 번호</label>
        <input id="tmNumber" class="inp" placeholder="예: 001" />
        <label style="margin-top:8px">기술머신 이름</label>
        <input id="tmName" class="inp" placeholder="예: 몸통박치기" />
      </div>

      <!-- 메가스톤 -->
      <div id="megaEditor" style="display:none; margin-top:10px">
        <label>포켓몬 이름</label>
        <input id="megaPokemon" class="inp" placeholder="예: 리자몽" />
      </div>

      <!-- 미션 -->
      <div id="missionEditor" style="display:none; margin-top:10px">
        <label>미션 번호</label>
        <input id="missionNumber" class="inp" placeholder="예: M-01" />
      </div>

      <!-- 아이템 -->
      <div id="itemEditor" style="display:none; margin-top:10px">
        <label>아이템 이름</label>
        <input id="itemName" class="inp" placeholder="아이템 이름 입력" />
      </div>

      <!-- 포켓몬 지정 -->
      <div id="pkEditor" style="display:none; margin-top:10px">
        <label>포켓몬(여러 개 가능)</label>
        <div class="row" style="align-items:stretch">
          <input id="pkAddInput" class="inp" placeholder="포켓몬 이름 입력 후 추가" />
          <button id="pkAddBtn" class="flt">추가</button>
          <button id="pkAddClear" class="flt">초기화</button>
        </div>
        <div id="pkChips" class="pk-tags" style="margin-top:6px"></div>
      </div>

      <!-- 선택 업로드 -->
      <label style="display:block;margin-top:8px">사진(선택, 여러장 가능)</label>
      <input id="mImgs" class="inp" type="file" accept="image/*" multiple />
      <label style="display:block;margin-top:8px">동영상(선택, 1개 권장)</label>
      <input id="mVideo" class="inp" type="file" accept="video/*" />
      <div style="margin-top:12px; text-align:right">
        <button id="cancelBtn">취소</button>
        <button id="saveBtn">등록</button>
      </div>
    </div>
  </div>

  <!-- 프로필 모달 -->
  <div id="profileModal">
    <div class="panel">
      <h3>프로필 설정</h3>
      <div id="pfWho" style="font-size:12px; opacity:.8; margin-bottom:6px">(로그인 필요)</div>
      
      <!-- 업적 전시 -->
      <div id="pfAchievements" style="margin-bottom:12px">
        <strong>전시 업적</strong>
        <div id="pfAchievementList" style="margin-top:6px"></div>
        <button id="pfManageAchievements" class="tbtn" style="margin-top:6px">업적 관리</button>
      </div>
      
      <label>닉네임</label>
      <input id="pfNick" class="inp" maxlength="24" placeholder="지도에 표시될 이름" />
      <div class="hr"></div>
      
      <div><strong>내 랭크</strong> · <span id="pfRank">(Z)</span></div>
      <div style="font-size:12px; opacity:.85; margin:6px 0">
        <strong>신뢰도:</strong> <span id="pfTrust">10</span>
      </div>
      
      <!-- XP 바 -->
      <div class="xp-bar">
        <div class="xp-bar-fill" id="pfXpFill"></div>
        <div class="xp-bar-text" id="pfXpText">0 / 100 XP</div>
      </div>
      
      <div style="font-size:12px; opacity:.85">
        <strong>총 조회수:</strong> <span id="pfTotalViews">0</span>
      </div>
      <div style="font-size:12px; opacity:.85">
        <strong>총 반응 수:</strong> <span id="pfTotalReactions">0</span>
      </div>
      
      <div class="hr"></div>
      <div style="font-size:12px; opacity:.85; margin:6px 0">
        <strong>경험치 획득 방법:</strong><br>
        • 핀 등록: +100 XP<br>
        • 댓글 작성: +10 XP<br>
        • 신고 승인: 핀 작성의 110% (+110 XP)
      </div>
      
      <div class="hr"></div>
      <div style="font-size:12px; opacity:.85; margin:6px 0">
        <strong>신뢰도 시스템:</strong><br>
        • 기본 신뢰도: 10 (최대 100)<br>
        • 핀 등록: +10<br>
        • 댓글 등록: +5<br>
        • 신고 접수: -10<br>
        • 신고 승인: 추가 -10<br>
        • 신고 반려: +15
      </div>
      
      <div class="hr"></div>
      <button id="pfTrustHistory" class="tbtn" style="margin-bottom:8px">신뢰도 내역</button>
      
      <div style="text-align:right">
        <button id="pfClose">닫기</button>
        <button id="pfSave" class="tbtn on">저장</button>
      </div>
    </div>
  </div>

  <!-- 타 유저 프로필 모달 -->
  <div id="otherProfileModal">
    <div class="panel">
      <h3>유저 프로필</h3>
      <div id="opNick" style="font-size:18px; font-weight:600; margin-bottom:8px"></div>
      
      <div id="opAchievements" style="margin-bottom:12px">
        <strong>전시 업적</strong>
        <div id="opAchievementList" style="margin-top:6px"></div>
      </div>
      
      <div style="font-size:14px; margin:6px 0">
        <strong>랭크:</strong> <span id="opRank">Z</span>
      </div>
      <div style="font-size:14px; margin:6px 0">
        <strong>신뢰도:</strong> <span id="opTrust">10</span>
      </div>
      <div style="font-size:14px; margin:6px 0">
        <strong>총 경험치:</strong> <span id="opXp">0</span> XP
      </div>
      <div style="font-size:14px; margin:6px 0">
        <strong>총 조회수:</strong> <span id="opViews">0</span>
      </div>
      
      <div style="text-align:right; margin-top:16px">
        <button id="opClose" class="tbtn">닫기</button>
      </div>
    </div>
  </div>

  <!-- 신뢰도 내역 모달 -->
  <div id="trustHistoryModal">
    <div class="panel">
      <h3>신뢰도 내역</h3>
      <div id="trustHistoryList" style="max-height:400px; overflow:auto; margin:12px 0"></div>
      <div style="text-align:right">
        <button id="thClose" class="tbtn">닫기</button>
      </div>
    </div>
  </div>

  <!-- 업적 관리 모달 -->
  <div id="achievementModal">
    <div class="panel">
      <h3>업적 관리</h3>
      <p style="font-size:12px; opacity:.8">달성한 업적 중 최대 3개를 프로필에 전시할 수 있습니다.</p>
      <div id="achievementList" style="max-height:400px; overflow:auto; margin:12px 0"></div>
      <div style="text-align:right">
        <button id="achClose" class="tbtn">닫기</button>
      </div>
    </div>
  </div>

  <!-- 관리자 메신저 모달 -->
  <div id="messengerModal">
    <div class="panel wide">
      <h3 style="display:flex;justify-content:space-between;align-items:center">
        관리진 메신저
        <span>
          <button id="msgClose" class="tbtn">닫기</button>
        </span>
      </h3>
      <div id="chatBox" class="chat-wrap"></div>
      <div class="row" style="margin-top:8px">
        <input id="msgInput" class="inp" placeholder="메세지 입력…" />
        <button id="msgSend" class="tbtn on">보내기</button>
      </div>
      <div style="font-size:12px;opacity:.75;margin-top:6px">* 내가 보낸 메세지는 좌측, 다른 관리자가 보낸 메세지는 우측에 표시됩니다.</div>
    </div>
  </div>

  <!-- 공지 작성/보기 모달 -->
  <div id="noticeModal">
    <div class="panel wide">
      <h3 style="display:flex;justify-content:space-between;align-items:center">
        공지
        <span>
          <button id="noticeClose" class="tbtn">닫기</button>
        </span>
      </h3>
      <div id="noticeView" style="display:none">
        <div style="font-size:12px;opacity:.8;margin-bottom:6px; display:flex; justify-content:space-between" id="noticeViewMeta">
          <span id="noticeDate"></span>
          <span class="view-count" id="noticeViewCount">조회 -</span>
        </div>
        <h3 id="noticeTitle"></h3>
        <div id="noticeBody" style="white-space:pre-wrap;margin-top:8px"></div>
        <div id="noticeFiles" style="margin-top:10px"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px" id="noticeAdminBtns"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
          <button id="noticeHide24" class="tbtn">24시간 동안 안뜨게</button>
          <button id="noticeDismiss" class="tbtn">닫기</button>
        </div>
      </div>
      <div id="noticeEdit" style="display:none">
        <label>제목</label>
        <input id="ntTitle" class="inp" maxlength="80" />
        <label style="margin-top:8px;display:block">내용</label>
        <textarea id="ntBody" class="inp" rows="6"></textarea>
        <label style="margin-top:8px;display:block">파일 첨부(선택, 여러 개)</label>
        <input id="ntFiles" class="inp" type="file" multiple />
        <div style="text-align:right;margin-top:10px">
          <button id="ntCancel" class="tbtn">취소</button>
          <button id="ntSave" class="tbtn on">작성 완료</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 공지 목록 모달 -->
  <div id="noticeListModal">
    <div class="panel wide">
      <h3 style="display:flex;justify-content:space-between;align-items:center">
        공지 목록
        <span style="display:flex;gap:8px;align-items:center">
          <button id="ntNew" class="tbtn" style="display:none">공지 작성</button>
          <button id="ntListClose" class="tbtn">닫기</button>
        </span>
      </h3>
      <div id="ntListWrap" style="max-height:60vh;overflow:auto"></div>
    </div>
  </div>

  <!-- 건의 및 문의 목록 모달 -->
  <div id="suggestListModal">
    <div class="panel wide">
      <h3 style="display:flex;justify-content:space-between;align-items:center">
        건의 및 문의
        <span style="display:flex;gap:8px;align-items:center">
          <button id="sgNew" class="tbtn">작성하기</button>
          <button id="sgListClose" class="tbtn">닫기</button>
        </span>
      </h3>
      <div id="sgListWrap" style="max-height:60vh;overflow:auto"></div>
    </div>
  </div>

  <!-- 건의 및 문의 상세/작성 모달 -->
  <div id="suggestModal">
    <div class="panel wide">
      <h3 style="display:flex;justify-content:space-between;align-items:center">
        건의 및 문의
        <span>
          <button id="sgClose" class="tbtn">닫기</button>
        </span>
      </h3>
      
      <div id="sgView" style="display:none">
        <div style="font-size:12px;opacity:.8;margin-bottom:6px" id="sgDate"></div>
        <h3 id="sgTitle"></h3>
        <div id="sgBody" style="white-space:pre-wrap;margin-top:8px"></div>
        
        <div class="hr"></div>
        <h4>답변</h4>
        <div id="sgReplies" style="margin-top:8px"></div>
        
        <div id="sgReplyForm" style="display:none; margin-top:12px">
          <textarea id="sgReplyBody" class="inp" rows="3" placeholder="답변 입력 (관리자 전용)"></textarea>
          <div style="text-align:right; margin-top:8px">
            <button id="sgReplySubmit" class="tbtn on">답변 등록</button>
          </div>
        </div>
      </div>
      
      <div id="sgEdit" style="display:none">
        <label>제목</label>
        <input id="sgEditTitle" class="inp" maxlength="80" />
        <label style="margin-top:8px;display:block">내용</label>
        <textarea id="sgEditBody" class="inp" rows="6"></textarea>
        <div style="text-align:right;margin-top:10px">
          <button id="sgEditCancel" class="tbtn">취소</button>
          <button id="sgEditSave" class="tbtn on">등록</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 미션 모달 -->
  <div id="missionsModal">
    <div class="panel">
      <h3 style="display:flex;justify-content:space-between;align-items:center">
        미션
        <button id="missionsClose" class="tbtn">닫기</button>
      </h3>
      
      <h4>일일 미션</h4>
      <div id="dailyMissions"></div>
      
      <div class="hr"></div>
      
      <h4>주간 미션</h4>
      <div id="weeklyMissions"></div>
    </div>
  </div>

  <!-- 업적 리스트 (관리자) 모달 -->
  <div id="achievementListModal">
    <div class="panel wide">
      <h3 style="display:flex;justify-content:space-between;align-items:center">
        전체 업적 리스트
        <button id="achListClose" class="tbtn">닫기</button>
      </h3>
      <div id="achListContent" style="max-height:60vh;overflow:auto"></div>
    </div>
  </div>

  <script type="module" src="za-patch-20251028.js"></script>
  
  
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script type="module">
    /* ---------------- 유틸 ---------------- */
    if (!globalThis.CSS) globalThis.CSS = {};
    if (!CSS.escape) CSS.escape = s => String(s).replace(/["'\\\s]/g, m => '\\' + m);
    const esc = (s)=> (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
    const nowMs = ()=> Date.now();
    const HIDE_MS = 48 * 3600 * 1000;
    const HIDE_DELAY_MS = 2 * 3600 * 1000;
    const HIDE_COUNT = 5;
    const toMs = (t)=>{
      if (!t) return null;
      if (t.toMillis) return t.toMillis();
      if (t.seconds)  return t.seconds*1000;
      if (typeof t === 'number') return t;
      const d = new Date(t); return isNaN(d) ? null : d.getTime();
    };
    const norm = s => (s||'').toLowerCase();
    const normName = s => (s||'').trim().toLowerCase();
    const fieldKey = s => normName(s).replace(/[.#$/\[\]\/]/g,'_');

    /* === 로컬 상태 저장/복원 === */
    const LS = {
      save(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch{} },
      load(k,def){ try{ const v = JSON.parse(localStorage.getItem(k)||'null'); return v==null?def:v; }catch{ return def; } }
    };
  
    // === Notice Seen (global) ===
    const SEEN_KEY = 'notice_seen_latest_id';
    function getLastSeenNoticeId(){ return LS.load(SEEN_KEY, '') || ''; }
    function setLastSeenNoticeId(id){ LS.save(SEEN_KEY, id || ''); }
    // Auto-open guard (respect 24h snooze)
    function guardNoticeAutoOpen(){ return isSnoozedNow(); }
  
    // ---- Notice Snooze Patch (UTILS) ----
    const SNOOZE_KEY_NOTICE = 'notice_snooze_until_ms';

    function setSnoozeUntilMs(ms){
      const v = Number(ms)||0;
      LS.save(SNOOZE_KEY_NOTICE, v);
    }
    function getSnoozeUntilMs(){
      const v = Number(LS.load(SNOOZE_KEY_NOTICE, 0));
      return Number.isFinite(v) ? v : 0;
    }
    function isSnoozedNow(){
      return getSnoozeUntilMs() > Date.now();
    }
    function humanRemain(ms){
      const m = Math.max(0, Math.floor(ms/60000));
      const h = Math.floor(m/60);
      const mm = m%60;
      return h ? `${h}시간 ${mm}분` : `${mm}분`;
    }
    // -------------------------------------

    /* ---------------- Leaflet ---------------- */
    const IMG_URL = "za_world_map_clean_fixed.png";
    const IMG_W = 2048, IMG_H = 2048;
    const map = L.map('map', { 
      crs: L.CRS.Simple, 
      minZoom: -2, 
      maxZoom: 4,
      zoomControl: false  // ✅ 줌 컨트롤 제거
    });
    const bounds = [[0,0],[IMG_H,IMG_W]];
    L.imageOverlay(IMG_URL, bounds).addTo(map);
    map.fitBounds(bounds);
    const isInside = (latlng)=> map.getBounds().contains(latlng);

    map.createPane('wildPane');
    map.getPane('wildPane').style.zIndex = 450;
    map.getPane('wildPane').style.pointerEvents = 'none';
    const wildLayer = L.layerGroup().addTo(map);
    let wildVisible = LS.load('wildVisible', true);

    let showPendingOnly = LS.load('showPendingOnly', false);
    let adminReportMode = false;

    /* ---------------- Firebase ---------------- */
    let firebaseOk = true;
    let app, auth, db, st;
    let GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, signOut, onAuthStateChanged;
    let collection, collectionGroup, addDoc, serverTimestamp, onSnapshot,
        orderBy, query, doc, updateDoc, deleteDoc, where, getDocs, getDoc, setDoc, increment, limit, arrayUnion, arrayRemove;
    let ref, getDownloadURL, uploadBytesResumable, uploadBytes;

    try {
      const [appMod, authMod, fsMod, stMod] = await Promise.all([
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js"),
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js"),
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js"),
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-storage.js"),
      ]);
      const firebaseConfig = {
        apiKey: "AIzaSyCam7y7qNINoxBlTeGx7CDlP8Y77pXFMWA",
        authDomain: "za-maps-32982.firebaseapp.com",
        projectId: "za-maps-32982",
        storageBucket: "za-maps-32982.appspot.com",
        messagingSenderId: "804333155537",
        appId: "1:804333155537:web:504bc3ee175e3678bc81f0",
        measurementId: "G-GTRK8JEZFM"
      };
      app = appMod.initializeApp(firebaseConfig);
      auth = authMod.getAuth(app);
      db   = fsMod.getFirestore(app);
      st   = stMod.getStorage(app);
      ({ GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, signOut, onAuthStateChanged } = authMod);
      ({ collection, collectionGroup, addDoc, serverTimestamp, onSnapshot, orderBy, query, doc, updateDoc, deleteDoc, where, getDocs, getDoc, setDoc, increment, limit, arrayUnion, arrayRemove } = fsMod);
      ({ ref, getDownloadURL, uploadBytesResumable, uploadBytes } = stMod);
    } catch (e) {
      firebaseOk = false;
      console.warn("[Firebase] 동적 import 실패 — 오프라인 모드", e);
    }
  
    // === 공지 자동 오픈/강조 ===
    let currentNoticeId = null;

    async function openNoticeDoc(n){
      currentNoticeId = n.id;

      const modal = document.getElementById('noticeModal');
      const view  = document.getElementById('noticeView');
      const edit  = document.getElementById('noticeEdit');

      if (!modal || !view) return;
      // 내용 채우기
      document.getElementById('noticeTitle').textContent = n.title || '(제목 없음)';
      document.getElementById('noticeBody').textContent  = n.body  || '';
      document.getElementById('noticeDate').textContent  = n.createdAt
          ? new Date(toMs(n.createdAt)).toLocaleString()
          : '';

      const vc = (n.viewCount || 0) + 1;
      const vcEl = document.getElementById('noticeViewCount');
      if (vcEl) vcEl.textContent = `조회 ${vc}`;

      // 첨부(있으면)
      const filesWrap = document.getElementById('noticeFiles');
      if (filesWrap){
        const files = Array.isArray(n.files) ? n.files : [];
        filesWrap.innerHTML = files.map(u =>
          `<div style="margin-top:6px"><a href="${esc(u)}" target="_blank" rel="noopener">첨부 보기</a></div>`
        ).join('');
      }

      // 보기 모드 표시
      view.style.display = 'block';
      if (edit) edit.style.display = 'none';
      modal.style.display = 'flex';

      // 계정별 '읽음' 기록
      setLastSeenNoticeId(n.id);

      // 뱃지/하이라이트 해제
      try {
        const btn = document.getElementById('btnNoticeList');
        if (btn) btn.classList.remove('on');
      } catch {}

      // 조회수 증가
      try { await updateDoc(doc(db,'notices', n.id), { viewCount: increment(1) }); } catch(_e){}
    }

    async function tryOpenLatestNotice(){
      if (!firebaseOk) return;
      if (isSnoozedNow()) return;

      // 최신 공지 1개
      const qLatest = query(collection(db,'notices'), orderBy('createdAt','desc'), limit(1));
      const snap = await getDocs(qLatest);
      if (snap.empty) return;

      const d  = snap.docs[0];
      const n  = { id: d.id, ...d.data() };
      const seenId = getLastSeenNoticeId();

      // 이미 본 공지는 자동 오픈 안 함
      if (seenId === d.id) {
        // 대신 버튼을 하이라이트 해제만 보장
        const btn = document.getElementById('btnNoticeList');
        if (btn) btn.classList.remove('on');
        return;
      }

      await openNoticeDoc(n);
    }

    async function highlightNoticeIfUnseen(){
      if (!firebaseOk) return;
      const qLatest = query(collection(db,'notices'), orderBy('createdAt','desc'), limit(1));
      const snap = await getDocs(qLatest);
      if (snap.empty) return;

      const latestId = snap.docs[0].id;
      const btn = document.getElementById('btnNoticeList');
      if (!btn) return;

      if (getLastSeenNoticeId() !== latestId){
        // 새 공지 있음 → 버튼 하이라이트
        btn.classList.add('on');
        btn.title = '새 공지 있음';
      } else {
        btn.classList.remove('on');
        btn.title = '공지 목록';
      }
    }

    /* ---------------- 업로드 유틸 ---------------- */
    async function safeMergeDoc(pathArr, data){
      if (!firebaseOk) return;
      await setDoc(doc(db, ...pathArr), data, { merge: true });
    }
    const safeName = (name)=> name.normalize('NFKD').replace(/[^\w.\-]+/g,'_').replace(/_+/g,'_').slice(-80);
    globalThis.uploadSmart = async function uploadSmart(file, folder, onProgress, label='업로드'){
      if (!firebaseOk) throw new Error('Firebase unavailable');
      const uid = (me && me.uid) || 'anon';
      const fname = `${Date.now()}_${safeName(file.name)}`;
      const path  = `${folder}/${uid}/${fname}`;
      const r     = ref(st, path);
      try{
        onProgress?.(`${label}…`);
        await uploadBytes(r, file);
        return await getDownloadURL(r);
      }catch(e1){
        console.warn('[upload] simple 실패 → resumable', e1);
      }
      const task = uploadBytesResumable(r, file);
      await new Promise((resolve, reject)=>{
        task.on('state_changed',
          s=> onProgress?.(`${label}… ${Math.round(s.bytesTransferred/s.totalBytes*100)}%`),
          reject, resolve);
      });
      return await getDownloadURL(r);
    };
    // markers 쓰기 실패(권한) 시 submissions로 폴백 저장
    async function tryAddMarker(docData){
      if (!firebaseOk) throw new Error('Firebase unavailable');
      // 안전장치: 카테고리 정규화 보장
      docData.category = normalizeCategoryKey(docData.category);
      try{
        const r = await addDoc(collection(db, 'markers'), docData);
        return { ok:true, id:r.id, to:'markers' };
      }catch(e){
        const msg = String(e?.message||'');
        const code = String(e?.code||'');
        if (code === 'permission-denied' || /Missing or insufficient permissions/i.test(msg)){
          const r2 = await addDoc(collection(db, 'submissions'), {
            ...docData,
            status: 'pending',
            createdAt: serverTimestamp(),
            submittedBy: me?.uid || null
          });
          alert('권한 문제로 검수함에 임시 저장했어요. 관리자가 승인하면 지도에 반영돼요.');
          return { ok:false, id:r2.id, to:'submissions' };
        }
        throw e;
      }
    }

    /* ---------------- 카테고리 ---------------- */
    const CATEGORIES = [
      {key:'장소-와일드 존',       label:'와일드 존',       defaultIcon:'wild_zone.png', group:'장소'},
      {key:'장소-중요한 장소',     label:'중요한 장소',     defaultIcon:'poi.png', group:'장소'},
      {key:'장소-포켓몬 센터',     label:'포켓몬 센터',     defaultIcon:'pokemon_center.png', group:'장소'},
      {key:'장소-카페',           label:'카페',           defaultIcon:'cafe.png', group:'장소'},
      {key:'장소-레스토랑',       label:'레스토랑',       defaultIcon:'restaurant.png', group:'장소'},
      {key:'장소-헤어살롱',       label:'헤어 살롱',       defaultIcon:'hair_salon.png', group:'장소'},
      {key:'장소-부티크',         label:'부티크',         defaultIcon:'boutique.png', group:'장소'},
      {key:'아이템-컬러풀한 나사',   label:'컬러풀한 나사',   defaultIcon:'colorful_screw.png', group:'아이템'},
      {key:'아이템-중요 아이템',     label:'중요 아이템',     defaultIcon:'key_item.png', group:'아이템'},
      {key:'아이템-보물',           label:'보물',           defaultIcon:'treasure.png', group:'아이템'},
      {key:'아이템-메가스톤',       label:'메가스톤',       defaultIcon:'mega_stone.png', group:'아이템'},
      {key:'아이템-포켓몬 볼',       label:'포켓몬 볼',       defaultIcon:'poke_ball.png', group:'아이템'},
      {key:'아이템-회복 아이템',     label:'회복 아이템',     defaultIcon:'medicine.png', group:'아이템'},
      {key:'아이템-기타 아이템',     label:'기타 아이템',     defaultIcon:'other_item.png', group:'아이템'},
      {key:'임무-메인 임무',       label:'메인 임무',       defaultIcon:'main_mission.png', group:'임무'},
      {key:'임무-사이드 임무',     label:'사이드 임무',     defaultIcon:'side_mission.png', group:'임무'},
      {key:'임무-승급전',         label:'승급전',         defaultIcon:'promotion_match.png', group:'임무'},
      {key:'임무-NPC',            label:'NPC',            defaultIcon:'npc.png', group:'임무'},
      {key:'포켓몬-메가 포켓몬',     label:'메가 포켓몬',     defaultIcon:'mega_pokemon.png', group:'포켓몬'},
      {key:'포켓몬-우두머리 포켓몬', label:'우두머리 포켓몬', defaultIcon:'alpha_pokemon.png', group:'포켓몬'},
      {key:'기타-홀로베이터',     label:'홀로베이터',     defaultIcon:'holovator.png', group:'기타'},
      {key:'기타-사다리',         label:'사다리',         defaultIcon:'ladder.png', group:'기타'},
      {key:'기타-기술머신',       label:'기술머신',       defaultIcon:'tm.png', group:'기타'},
      {key:'기타-기타',           label:'기타',           defaultIcon:'misc.png', group:'기타'},
    ];
    
    const POKEMON_CATS = ['장소-와일드 존','포켓몬-우두머리 포켓몬','포켓몬-메가 포켓몬'];
    const TM_CAT = '기타-기술머신';
    const MEGA_STONE_CAT = '아이템-메가스톤';
    const MISSION_CATS = ['임무-메인 임무', '임무-사이드 임무'];
    const ITEM_CATS = ['아이템-중요 아이템', '아이템-포켓몬 볼', '아이템-회복 아이템', '아이템-보물', '아이템-기타 아이템'];
    
    const catSel = document.getElementById('mCat');
    catSel.innerHTML = CATEGORIES.map(c=>`<option value="${c.key}">${c.label}</option>`).join('');

    const categoryIconOverride = new Map();
    if (firebaseOk){
      onSnapshot(collection(db,'categories'), snap=>{
        categoryIconOverride.clear();
        snap.forEach(d=>{ const v=d.data()?.iconUrl; if (v) categoryIconOverride.set(d.id, v); });
      });
    }
  
    /* PATCH START: robust category resolution (2025-10-28) */
    const CAT_BY_KEY   = new Map(CATEGORIES.map(c => [c.key, c]));
    const CAT_BY_LABEL = new Map(CATEGORIES.map(c => [c.label, c]));    
    function resolveCategoryKey(k){
      if (!k) return k;
      if (CAT_BY_KEY.has(k)) return k;
      if (CAT_BY_LABEL.has(k)) return CAT_BY_LABEL.get(k).key;
      const s = (k+'').toLowerCase();
      if (s.includes('기술머신')) return TM_CAT;
      if (s.includes('메가스톤') || s.includes('메가 스톤')) return MEGA_STONE_CAT;
      return k; // 알 수 없으면 원본 유지
    }

    // 기존 iconUrlForCat을 교체해 라벨/키 모두 지원
    function iconUrlForCat(cat){
      const key = resolveCategoryKey(cat);
      const override = categoryIconOverride.get(key);
      if (override) return override;
      const def = CAT_BY_KEY.get(key)?.defaultIcon;
      return def ? `icons/${def}` : `icons/default.png`;
    }
    /* PATCH END */
  
    const labelFor=(key)=> CATEGORIES.find(c=>c.key===key)?.label || key;
    const defaultIconFor=(key)=>{
    const def = CATEGORIES.find(c=>c.key===key)?.defaultIcon;
    return def ? `icons/${def}` : `icons/misc.png`;
  };
    // 라벨→키 매핑 (레거시 호환)
    const KEY_BY_LABEL = Object.fromEntries(CATEGORIES.map(c => [c.label, c.key]));

    // 카테고리 값 정규화: 키면 그대로, 라벨/옛값이면 키로 환산, 최종 실패 시 '기타-기타'
    function normalizeCategoryKey(k){
      if (!k) return '기타-기타';
      if (CATEGORIES.some(c => c.key === k)) return k;
      const byLabel = KEY_BY_LABEL[k] || KEY_BY_LABEL[String(k).trim()];
      return byLabel || '기타-기타';
    }

    /* ---------------- 로그인/관리자 상태 + 프로필/랭크 ---------------- */
    const $who = document.getElementById('who');
    const $login = document.getElementById('login');
    const $logout = document.getElementById('logout');
    const $btnProfile = document.getElementById('btnProfile');
    const $adminBadge = document.getElementById('adminBadge');
    const $btnPendingOnly = document.getElementById('btnPendingOnly');
    const $btnAdminReport = document.getElementById('btnAdminReport');
    const $btnMsg = document.getElementById('btnMsg');
    const $msgBang = document.getElementById('msgBang');
    let me=null, isAdmin=false, unsubAdminDoc=null;

    // 랭크 정의
    const RANKS = 'ZYXWVUTSRQPONMLKJIHGFEDCBA'.split('');
    const PIN_XP = 100, CMT_XP = 10, REPORT_APPROVED_XP = 110;
    const FIRST_PIN_AUTO_UP = true;
    
    function xpForRankIndex(i){
      let req=0, step=100;
      for(let k=0;k<i;k++){ req += step; step*=2; }
      return req;
    }
    
    function totalToRank(totalXP){
      const aIdx = RANKS.length-1;
      const aNeed = xpForRankIndex(aIdx);
      if (totalXP < aNeed){
        let idx=0;
        while(idx<RANKS.length && xpForRankIndex(idx)<=totalXP) idx++;
        idx = Math.max(0, idx-1);
        const curNeed = xpForRankIndex(idx);
        const nextNeed = xpForRankIndex(Math.min(idx+1, aIdx));
        return { idx, rank:RANKS[idx], plus:0, cur: totalXP-curNeed, next: Math.max(0, nextNeed-totalXP), cap:false, q:false };
      }
      const over = totalXP - aNeed;
      const plusUnit = 50000;
      let plus = Math.floor(over / plusUnit);
      if (plus<=5){
        const next = (plus<5) ? (plusUnit - (over % plusUnit)) : 0;
        const cap = plus>=5;
        return { idx:aIdx, rank:'A' + '+'.repeat(plus), plus, cur: over%plusUnit, next, cap, q:false };
      }
      return { idx:aIdx, rank:'?', plus:999, cur:0, next:0, cap:true, q:true };
    }

    // ✅ 업적 정의
    const ACHIEVEMENTS = [
      {id:'pioneer', name:'개척자', desc:'핀을 처음으로 등록하세요', tier:'normal', xp:50, check:(p)=>p.pinsCreated>=1},
      {id:'listener', name:'경청자', desc:'처음으로 반응을 추가해보세요', tier:'normal', xp:50, check:(p)=>p.reactionsGiven>=1},
      {id:'questioner', name:'질문자', desc:'댓글을 처음으로 등록하세요', tier:'normal', xp:50, check:(p)=>p.commentsCreated>=1},
      {id:'guardian', name:'정의의 수호자', desc:'신고가 처음으로 승인되어보세요', tier:'normal', xp:50, check:(p)=>p.reportsApproved>=1},
      {id:'suggester', name:'제안자', desc:'처음으로 의견을 제출해보세요', tier:'rare', xp:150, check:(p)=>p.suggestionsMade>=1},
      {id:'novice_explorer', name:'초보 탐험가', desc:'핀을 처음으로 비활성화 해보세요', tier:'normal', xp:50, check:(p)=>p.pinsConfirmed>=1},
      {id:'veteran_explorer', name:'중견 탐험가', desc:'핀을 50개 이상 비활성화 하세요', tier:'epic', xp:500, check:(p)=>p.pinsConfirmed>=50},
      {id:'legend_explorer', name:'전설의 탐험가', desc:'핀을 100개 이상 비활성화 하세요', tier:'legend', xp:2500, check:(p)=>p.pinsConfirmed>=100},
      {id:'celebrity', name:'셀러브리티', desc:'반응을 받은 횟수가 1000회를 넘기세요', tier:'epic', xp:500, check:(p)=>p.reactionsReceived>=1000},
      {id:'star', name:'연예인', desc:'총 조회수가 10000을 넘으세요', tier:'legend', xp:2500, check:(p)=>p.totalViews>=10000},
    ];

    // ✅ 미션 정의
    const DAILY_MISSIONS = [
      {id:'daily_login', name:'로그인하기', xp:20, check:(m)=>m.loginToday},
      {id:'daily_comment', name:'댓글 1개 이상 달기', xp:20, check:(m)=>m.commentsToday>=1},
      {id:'daily_notice', name:'공지 확인하기', xp:20, check:(m)=>m.noticeCheckedToday},
      {id:'daily_complete', name:'일일미션 3개 하기', xp:40, check:(m)=>{
        const completed = [m.loginToday, m.commentsToday>=1, m.noticeCheckedToday].filter(x=>x).length;
        return completed>=3;
      }},
    ];

    const WEEKLY_MISSIONS = [
      {id:'weekly_login', name:'로그인 5회 이상 하기', xp:60, check:(m)=>m.loginDaysThisWeek>=5},
      {id:'weekly_pin', name:'핀 1개 이상 등록하기', xp:60, check:(m)=>m.pinsThisWeek>=1},
      {id:'weekly_suggest', name:'건의 및 문의 1회 이상 하기', xp:60, check:(m)=>m.suggestionsThisWeek>=1},
      {id:'weekly_reactions', name:'핀 혹은 댓글에 반응 3회 이상 남기기', xp:60, check:(m)=>m.reactionsThisWeek>=3},
      {id:'weekly_complete', name:'주간미션 3개 이상 하기', xp:120, check:(m)=>{
        const completed = [
          m.loginDaysThisWeek>=5,
          m.pinsThisWeek>=1,
          m.suggestionsThisWeek>=1,
          m.reactionsThisWeek>=3
        ].filter(x=>x).length;
        return completed>=3;
      }},
    ];

    async function checkAchievements(uid){
      if (!firebaseOk || !uid) return;
      const pfRef = doc(db,'profiles', uid);
      const snap = await getDoc(pfRef);
      if (!snap.exists()) return;
      const profile = snap.data();
      const unlocked = profile.achievementsUnlocked || [];
      
      for (const ach of ACHIEVEMENTS){
        if (unlocked.includes(ach.id)) continue;
        if (ach.check(profile)){
          await updateDoc(pfRef, {
            achievementsUnlocked: arrayUnion(ach.id),
            xp: increment(ach.xp)
          });
          showAchievementPopup(ach);
        }
      }
    }

    function showAchievementPopup(ach){
      const tierLabels = {normal:'노말', rare:'레어', epic:'에픽', legend:'레전드'};
      const popup = document.createElement('div');
      popup.className = 'achievement-popup';
      popup.innerHTML = `
        <h3>🎉 업적 달성!</h3>
        <div class="achievement-badge ${ach.tier}">${ach.name}</div>
        <p style="margin:8px 0">${ach.desc}</p>
        <p style="font-size:12px; opacity:.8">${tierLabels[ach.tier]} 업적 · +${ach.xp} XP</p>
      `;
      document.body.appendChild(popup);
      setTimeout(()=>popup.remove(), 4000);
    }

    async function awardXP(kind, customAmount){
      if (!firebaseOk || !me) return;
      const pfRef = doc(db,'profiles', me.uid);
      const snap = await getDoc(pfRef);
      const data = snap.exists()? (snap.data()||{}) : {};
      let xp = data.xp||0;
      const amount = customAmount !== undefined ? customAmount : (kind==='pin'? PIN_XP : CMT_XP);
      xp += amount;
      
      let firstPinBoon=false;
      if (kind==='pin' && FIRST_PIN_AUTO_UP && (data.rankCode||'Z')==='Z' && !(data.pinnedOnce)){
        firstPinBoon = true;
      }
      const calc = totalToRank(xp);
      let rankCode = calc.rank;
      if (firstPinBoon) { rankCode = 'Y'; }
      
      await setDoc(pfRef, {
        uid: me.uid,
        nick: data.nick || (me.displayName||'익명'),
        xp,
        rankCode,
        pinnedOnce: data.pinnedOnce || (kind==='pin')
      }, { merge:true });

      if (calc.q && typeof toast === 'function'){
        toast('경고: A+++++ 초과 시 랭크 표기가 ? 로 표시됩니다');
      }

      
      await checkAchievements(me.uid);
    }

    // ✅ 신뢰도 관리
    async function addTrust(uid, amount, reason){
      if (!firebaseOk || !uid) return;
      const pfRef = doc(db,'profiles', uid);
      const snap = await getDoc(pfRef);
      const data = snap.exists() ? (snap.data()||{}) : {};
      const currentTrust = data.trust || 10;
      const newTrust = Math.max(-999, Math.min(100, currentTrust + amount));
      
      await setDoc(pfRef, { trust: newTrust }, { merge:true });
      await addDoc(collection(db,'profiles', uid, 'trustHistory'), {
        amount, reason, timestamp: serverTimestamp(), newTotal: newTrust
      });
    }

    function nameWithRank(nick, rankCode, trust, isAdminFlag){
      const trustStr = trust !== undefined ? ` • 신뢰도: ${trust >= 0 ? trust : `<span class="trust-negative">${trust}</span>`}` : '';
      return `${nick||'익명'} • ${isAdminFlag ? '관리자' : (rankCode||'Z')}${trustStr}`;
    }

    async function ensureProfileOnLogin(){
      if (!firebaseOk || !me) return;
      const pfRef = doc(db,'profiles', me.uid);
      const snap = await getDoc(pfRef);
      if (!snap.exists()){
        openProfile(true);
        alert('최초 로그인: 어떤 닉네임으로 활동할지 설정해주세요.\n설정하지 않으면 Google 닉네임으로 활동합니다.');
        await setDoc(pfRef, {
          uid: me.uid,
          nick: me.displayName || '익명',
          xp: 0,
          rankCode: 'Z',
          trust: 10,
          createdAt: serverTimestamp(),
          pinsCreated:0, commentsCreated:0, reactionsGiven:0, reactionsReceived:0,
          reportsApproved:0, suggestionsMade:0, pinsConfirmed:0, totalViews:0,
          achievementsUnlocked:[], achievementsDisplayed:[]
        }, { merge:true });
      } else {
        const data = snap.data()||{};
        $who.textContent = nameWithRank(data.nick, data.rankCode, data.trust, isAdmin);
      }
    }

    const $btnNoticeList = document.getElementById('btnNoticeList');
    
    // ---- Notice Snooze Patch (BUTTON WIRING) ----
    const $noticeModalEl = document.getElementById('noticeModal');
    const $noticeHide24  = document.getElementById('noticeHide24');
    const $noticeDismiss = document.getElementById('noticeDismiss'); // 이미 있음

    function closeNoticeModal(){
      if ($noticeModalEl) $noticeModalEl.style.display = 'none';
    }

    if ($noticeHide24){
      $noticeHide24.onclick = ()=>{
        // 24시간 스누즈 설정
        setSnoozeUntilMs(Date.now() + 24*3600*1000);
        closeNoticeModal();
        // 버튼 상태(툴팁/불투명도) 즉시 반영
        const btn = document.getElementById('btnNoticeList');
        if (btn){
          btn.title = '공지 스누즈 중';
          btn.style.opacity = '0.6';
        }
        alert('24시간 동안 공지가 자동으로 뜨지 않아요.');
      };
    }

    if ($noticeDismiss){
     $noticeDismiss.onclick = ()=>{
        // 그냥 닫아도 '읽음' 처리해서 자동 재오픈 방지
        try { setLastSeenNoticeId(currentNoticeId || getLastSeenNoticeId()); } catch(_e){}
        closeNoticeModal();
      };
  }
    // ----------------------------------------------
  
    $login.onclick = async () => {
      if (!firebaseOk) { alert('네트워크 차단으로 로그인 불가'); return; }
      try{ await signInWithPopup(auth, new GoogleAuthProvider()); }
      catch{ await signInWithRedirect(auth, new GoogleAuthProvider()); }
    };
    $logout.onclick = ()=>{ if(firebaseOk) signOut(auth); };

    if (firebaseOk) getRedirectResult(auth).catch(()=>{});

    function applyAdminUI() {
      // ✅ 관리자 랭크는 "관리자"로 표시
      $adminBadge.style.display = isAdmin ? 'inline-block' : 'none';
      $btnPendingOnly.style.display = isAdmin ? 'inline-block' : 'none';
      $btnAdminReport.style.display = isAdmin ? 'inline-block' : 'none';
      $btnMsg.style.display = isAdmin ? 'inline-block' : 'none';
      if (!isAdmin) {
        showPendingOnly = false;
        $btnPendingOnly.classList.remove('on');
        if (adminReportMode) setAdminReportMode(false);
      }
      applyAllVisibility();
      subscribeMarkers();
      subscribeReportedCommentsAdmin();
      wireAdminMessenger();
    }

    if (firebaseOk){
      onAuthStateChanged(auth, async (user)=>{
        me = user || null;
        $btnProfile.style.display = me ? 'inline-block' : 'none';
        document.getElementById('btnAchievementList')?.remove();
        document.getElementById('login').style.display  = me ? 'none' : 'inline-block';
        document.getElementById('logout').style.display = me ? 'inline-block' : 'none';
        $who.textContent = me ? (me.displayName || '로그인됨') : '로그인 안 됨';

        // ── 기존 구독 정리 및 기본값 초기화
        try { if (unsubAdminDoc) { unsubAdminDoc(); unsubAdminDoc = null; } } catch {}
        isAdmin = false;
        applyAdminUI();

        // me가 있으면 관리자 문서 구독 시작
        if (me) {
          try {
           const r = doc(db, 'admins', me.uid);
            unsubAdminDoc = onSnapshot(
              r,
              (s) => {
                const prev = isAdmin;
                const d = s.exists() ? (s.data() || {}) : null;
                // enabled 가 false가 아니면 관리자
                isAdmin = !!(d && (d.enabled !== false));
                if (isAdmin !== prev) applyAdminUI();
                ensureProfileOnLogin();
                  refreshTopName();
              },
             (err) => {
                console.warn('[admins] subscribe failed', err);
               isAdmin = false;
               applyAdminUI();
                refreshTopName();
             }
           );
          } catch (e) {
            console.warn('[admins] subscribe init error', e);
            isAdmin = false;
            applyAdminUI();
            refreshTopName();
          }
        } else {
          // 로그아웃 시 초기화
          isAdmin = false;
         applyAdminUI();
          refreshTopName();
        }
        
        if (!guardNoticeAutoOpen()){
          await highlightNoticeIfUnseen();   // 버튼에 '새 공지' 하이라이트
          await tryOpenLatestNotice();       // 실제 자동 오픈
        }
        
 
      }); // ← 여기서 끝나야 함 (추가 } 제거)

    }
    async function recordDailyLogin(){
      if (!firebaseOk || !me) return;
      const today = new Date().toISOString().split('T')[0];
      const mRef = doc(db,'profiles', me.uid, 'missions', 'daily');
      const snap = await getDoc(mRef);
      const data = snap.exists() ? snap.data() : {};
      
      if (data.lastLoginDate !== today){
        await setDoc(mRef, {
          loginToday: true,
          lastLoginDate: today
        }, {merge:true});
      }
      
      // 주간 로그인 기록
      const weekNum = getWeekNumber(new Date());
      const wRef = doc(db,'profiles', me.uid, 'missions', 'weekly');
      const wSnap = await getDoc(wRef);
      const wData = wSnap.exists() ? wSnap.data() : {};
      
      if (wData.currentWeek !== weekNum){
        await setDoc(wRef, {
          currentWeek: weekNum,
          loginDaysThisWeek: 1,
          loginDates: [today]
        }, {merge:true});
      } else {
        const dates = wData.loginDates || [];
        if (!dates.includes(today)){
          await updateDoc(wRef, {
            loginDaysThisWeek: increment(1),
            loginDates: arrayUnion(today)
          });
        }
      }
    }

    function getWeekNumber(d){
      const onejan = new Date(d.getFullYear(),0,1);
      return Math.ceil((((d - onejan) / 86400000) + onejan.getDay()+1)/7);
    }

    async function refreshTopName(){
      if (!firebaseOk || !me){
       $who.textContent = '로그인 안 됨';
        return;
      }
      try{
        const pf = await getDoc(doc(db,'profiles', me.uid));
        const d = pf.exists()? (pf.data()||{}) : null;
        const nick = d?.nick || (me.displayName||'익명');
        const rankCode = isAdmin ? '관리자' : (d?.rankCode || 'Z');
        const trust = (d?.trust !== undefined) ? d.trust : 10;
        $who.textContent = nameWithRank(nick, rankCode, trust, isAdmin);
      }catch{
        $who.textContent = me.displayName || '로그인됨';
      }
    }


    /* ---------------- 아이콘 캐시 ---------------- */
    const iconCache = new Map();
    function iconFor(catKey){
     const url = iconUrlForCat(catKey);
      if (iconCache.has(url)) return iconCache.get(url);
      const ic = L.icon({
        iconUrl: url,
        iconSize: [28, 28],
        iconAnchor: [14, 14],
        className: 'pin-icon'
      });
      iconCache.set(url, ic);
      return ic;
    }

     function iconUrlForCat(catKey){
      const o = categoryIconOverride.get(catKey);
      if (o) {
        const u = String(o).trim();
        // 완전한 URL이나 data URL은 그대로 사용
        if (/^(https?:)?\/\//.test(u) || u.startsWith('data:')) return u;
        // 도메인 루트 기준 절대경로도 허용
        if (u.startsWith('/')) return u;
        // 파일명만 온 경우엔 /icons 프리픽스 붙여서 로컬 자원으로 처리
        if (!u.startsWith('icons/')) return 'icons/' + u;
        return u;
      }
      return defaultIconFor(catKey);
    }

    /* ---------------- 카테고리 그룹 & 토글 + 진행도 ---------------- */
    const catGroups = new Map();
    const catVisible = new Map(CATEGORIES.map(c => [c.key, true]));
    const catConfirmed = new Map(); // ✅ 카테고리별 확인된 핀 추적
    
    const savedCatVis = LS.load('catVisible', null);
    if (savedCatVis && typeof savedCatVis==='object'){
      for (const [k,v] of Object.entries(savedCatVis)){ catVisible.set(k, !!v); }
    }
    
    function ensureCatGroup(key){
      if (!catGroups.has(key)) {
        catGroups.set(key, L.layerGroup().addTo(map));
      }
      return catGroups.get(key);
    }
    
    function setCategoryVisible(key, visible){
      catVisible.set(key, visible);
      LS.save('catVisible', Object.fromEntries(catVisible));
      const g = ensureCatGroup(key);
      if (visible) { if (!map.hasLayer(g)) g.addTo(map); }
      else { if (map.hasLayer(g)) map.removeLayer(g); }
      const btn = document.querySelector(`.flt[data-cat="${CSS.escape(key)}"]`);
      if (btn){ 
        btn.classList.toggle('on', visible);
        updateCategoryProgress(key);
      }
      applyAllVisibility();
      recomputeSeqs();
    }
    
    function updateCategoryProgress(catKey){
      const btn = document.querySelector(`.flt[data-cat="${CSS.escape(catKey)}"]`);
      if (!btn) return;

      // 승인된 핀만 총계
      const total = [...markerMap.values()]
        .filter(r=>r.data.category===catKey && r.data.status==='approved').length;

      const confirmed = confirmedCountForCat(catKey);
      const percent = total > 0 ? Math.round((confirmed/total)*100) : 0;

      let progressEl = btn.querySelector('.progress');
      if (!progressEl){
        progressEl = document.createElement('div');
        progressEl.className = 'progress';
        btn.appendChild(progressEl);
      }
      progressEl.textContent = `${percent}%`;

      // 카테고리가 "켜져 있을 때만" 보이게 (CSS와 함께 동작)
      progressEl.style.display = btn.classList.contains('on') ? 'block' : 'none';
    }
    
    function setAllCats(v){ CATEGORIES.forEach(c=> setCategoryVisible(c.key, v)); }
    function setOnlyPokemonCats(){
      setAllCats(false);
      POKEMON_CATS.forEach(k=> setCategoryVisible(k, true));
    }
    function setWildVisible(v){
      wildVisible = v;
      LS.save('wildVisible', v);
      if (v){ if (!map.hasLayer(wildLayer)) wildLayer.addTo(map); }
      else { if (map.hasLayer(wildLayer)) map.removeLayer(wildLayer); }
      document.getElementById('fltWild').classList.toggle('on', v);
    }

    // 좌측 필터 UI
    const side = document.getElementById('side');
    const sideCats = document.getElementById('sideCats');
    const sideReports = document.getElementById('sideReports');
    const repCommentList = document.getElementById('repCommentList');
    const fltList = document.getElementById('fltList');
    const repSortBar = document.getElementById('repSortBar');
    const repFiltBar = document.getElementById('repFiltBar');
    const warningUserList = document.getElementById('warningUserList');
    let repSortMode = 'mix';
    let repFilterMode = 'all';

    repSortBar.onclick = (e)=>{
      const b=e.target.closest('[data-sort]'); if(!b) return;
      repSortMode = b.getAttribute('data-sort');
      [...repSortBar.children].forEach(x=> x.classList.toggle('on', x===b));
      renderReportedComments();
    };
    repFiltBar.onclick = (e)=>{
      const b=e.target.closest('[data-filt]'); if(!b) return;
      repFilterMode = b.getAttribute('data-filt');
      [...repFiltBar.children].forEach(x=> x.classList.toggle('on', x===b));
      renderReportedComments();
    };

    function buildFilters(){
      fltList.innerHTML = CATEGORIES.map(c=>`<button class="flt ${catVisible.get(c.key)!==false?'on':''}" data-cat="${c.key}">${c.label}<div class="progress">0%</div></button>`).join('');
      fltList.onclick = (e)=>{
        const b = e.target.closest('.flt[data-cat]');
        if (!b) return;
        const key = b.getAttribute('data-cat');
        const next = !catVisible.get(key);
        setCategoryVisible(key, next);
        // 모든 카테고리 레이어를 미리 만들어 전체 토글이 즉시 전 범위에 적용되도록 함
          CATEGORIES.forEach(c => ensureCatGroup(c.key));
      };
      document.getElementById('fltWild').onclick = ()=> setWildVisible(!wildVisible);
      document.getElementById('fltAll').onclick  = ()=> setAllCats(true);
      document.getElementById('fltNone').onclick = ()=> setAllCats(false);

      $btnPendingOnly.onclick = ()=>{
        if (!isAdmin) return;
        showPendingOnly = !showPendingOnly;
        LS.save('showPendingOnly', showPendingOnly);
        $btnPendingOnly.classList.toggle('on', showPendingOnly);
        applyAllVisibility(); recomputeSeqs();
      };

      $btnAdminReport.onclick = ()=>{
        if (!isAdmin) return;
        setAdminReportMode(!adminReportMode);
      };
    }
    buildFilters();

    function setAdminReportMode(v){
      adminReportMode = !!v;
      side.style.display = 'block';
      sideCats.style.display = adminReportMode ? 'none' : 'block';
      sideReports.style.display = adminReportMode ? 'block' : 'none';
      document.getElementById('btnAdminReport').classList.toggle('on', adminReportMode);
      applyAllVisibility();
      recomputeSeqs();
      if (adminReportMode) updateWarningUsers();
    }

    // ✅ 요주의 유저 표시
    async function updateWarningUsers(){
      if (!firebaseOk || !isAdmin) return;
      const profiles = await getDocs(collection(db,'profiles'));
      const warning = [];
      
      for (const p of profiles.docs){
        const data = p.data();
        const uid = p.id;
        
        // 신고 반려 10회 이상
        const rejectCount = data.reportsRejected || 0;
        if (rejectCount >= 10){
          warning.push({uid, nick:data.nick||'익명', reason:`신고 반려 ${rejectCount}회`});
        }
        
        // 신고 승인/삭제된 핀/댓글 10개 이상
        const badContent = (data.pinsDeleted||0) + (data.commentsDeleted||0);
        if (badContent >= 10){
          warning.push({uid, nick:data.nick||'익명', reason:`삭제된 콘텐츠 ${badContent}개`});
        }
      }
      
      if (warning.length === 0){
        warningUserList.innerHTML = '<div style="opacity:.7">없음</div>';
      } else {
        warningUserList.innerHTML = warning.map(w=>`
          <div style="background:#2a2a2a; padding:6px; margin:4px 0; border-radius:6px">
            ${esc(w.nick)} (${w.uid.slice(0,8)}…)<br>
            <span style="opacity:.8">${esc(w.reason)}</span>
          </div>
        `).join('');
      }
    }

    /* ---------------- 통합 검색 ---------------- */
    const qInput   = document.getElementById('qInput');
    const qSearch  = document.getElementById('qSearch');
    const qClear   = document.getElementById('qClear');
    const qTrendEl = document.getElementById('qTrending');

    let textFilter = LS.load('textFilter','');
    if (textFilter){ qInput.value = textFilter; }
    function applyTextFilter(q){
      textFilter = norm(q||'');
      LS.save('textFilter', textFilter);
      applyAllVisibility();
      recomputeSeqs();
    }
    qSearch.onclick = ()=> { const q = qInput.value.trim(); applyTextFilter(q); if (q) logQuery(q).catch(()=>{}); };
    qInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ qSearch.click(); }});
    qClear.onclick = ()=>{ qInput.value=''; applyTextFilter(''); };

    function dateKey(d=new Date()){
      const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), da=String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${da}`;
    }
    async function logQuery(q){
      if (!firebaseOk) return;
      const normed = fieldKey(q);
      const refD = doc(db,'searchDaily', dateKey());
      await setDoc(refD, {
        updatedAt: serverTimestamp(),
        [`counts.${normed}`]: increment(1),
        [`labels.${normed}`]: q
      }, { merge:true });
    }
    function lastNDaysKeys(n){
      const arr=[]; const now=new Date();
      for(let i=0;i<n;i++){ const d=new Date(now.getTime()-i*24*3600*1000); arr.push(dateKey(d)); }
      return arr;
    }
    async function refreshTrending(){
      if (!firebaseOk) { qTrendEl.innerHTML=''; return; }
      const keys = lastNDaysKeys(7);
      const counts = new Map(); const labels = new Map();
      for (const k of keys){
        const s = await getDoc(doc(db,'searchDaily', k));
        if (!s.exists()) continue;
        const data = s.data();
        const cs = data?.counts || {}; const ls = data?.labels || {};
        for (const [normKey, c] of Object.entries(cs)){
          counts.set(normKey, (counts.get(normKey)||0) + (c||0));
          if (ls[normKey]) labels.set(normKey, ls[normKey]);
        }
      }
      const tops = [...counts.entries()].sort((a,b)=>b[1]-a[1]).slice(0,5).map(([n])=> labels.get(n) || n);
      qTrendEl.innerHTML = tops.map(t=>`<button class="flt" data-sug="${esc(t)}">${esc(t)}</button>`).join('');
    }
    qTrendEl.onclick = (e)=>{
      const b=e.target.closest('[data-sug]'); if(!b) return;
      const q=b.getAttribute('data-sug'); qInput.value = q; qSearch.click();
    };
    refreshTrending(); setInterval(refreshTrending, 3600*1000);

    /* ---------------- 신고: 정책/프록시 ---------------- */
    let reportedComments = [];
    let unsubRepComments = null;

    const msToHuman = (ms)=>{
      if (!ms || ms<=0) return '해제됨';
      const h = Math.floor(ms/3600000);
      const m = Math.floor((ms%3600000)/60000);
      return h>0 ? `${h}시간 ${m}분 남음` : `${m}분 남음`;
    };

    const statusTextOf=(rc)=>{
      if (rc.hidden) return `가림 적용중 · ${msToHuman(rc.remainMs||0)}`;
      const age = nowMs() - (rc.firstReportAt||nowMs());
      const h = Math.floor(age/3600000), m = Math.floor((age%3600000)/60000);
      if (rc.eligible) return `가림 조건 충족(적용 대기) · 경과 ${h}시간 ${m}분 · 누적 ${rc.count}`;
      return `가림 조건 미충족 · 누적 ${rc.count||0}/${HIDE_COUNT} · 경과 ${h}시간 ${m}분`;
    };

    function sortReported(a,b){
      if (b.count!==a.count) return b.count - a.count;
      if (b.remainMs!==a.remainMs) return b.remainMs - a.remainMs;
      if ((a.hidden?1:0)!==(b.hidden?1:0)) return (b.hidden?1:0)-(a.hidden?1:0);
      return (a.firstReportAt||0) - (b.firstReportAt||0);
    }



    async function ensureCommentHidePolicy(markerId, commentId){
      try{
        const cs = await getDoc(doc(db,'markers', markerId, 'comments', commentId));
        if (!cs.exists()) return { hidden:false, count:0, first:null, eligible:false };
        const c = cs.data()||{};
        const count = c.reportPendingCount||0;
        const first = toMs(c.firstReportAt)||null;
        const eligible = (count>=HIDE_COUNT) || (!!first && (nowMs()-first)>=HIDE_DELAY_MS);
        if (eligible){
          const until = new Date(Date.now()+HIDE_MS);
          await updateDoc(cs.ref, { hiddenUntil: until });
          return { hidden:true, count, first, eligible };
        }else{
          await updateDoc(cs.ref, { hiddenUntil: null });
          return { hidden:false, count, first, eligible };
        }
      }catch(e){
        console.warn('[ensureCommentHidePolicy] error', e);
        return { hidden:false, error:e };
      }
    }

    async function ensureMarkerHidePolicy(markerId){
      try{
        const ms = await getDoc(doc(db,'markers', markerId));
        if (!ms.exists()) return { hidden:false, count:0, first:null, eligible:false };
        const m = ms.data()||{};
        const count = m.reportPendingCount||0;
        const first = toMs(m.firstReportAt)||null;
        const eligible = (count>=HIDE_COUNT) || (!!first && (nowMs()-first)>=HIDE_DELAY_MS);
        if (eligible){
          const until = new Date(Date.now()+HIDE_MS);
          await updateDoc(ms.ref, { hiddenUntil: until });
          const rec = markerMap.get(markerId);
          if (rec){ rec.data.hiddenUntil = until; applyVisibility(markerId); }
          return { hidden:true, count, first, eligible };
        }else{
          await updateDoc(ms.ref, { hiddenUntil: null });
          const rec = markerMap.get(markerId);
          if (rec){ rec.data.hiddenUntil = null; applyVisibility(markerId); }
          return { hidden:false, count, first, eligible };
        }
      }catch(e){
        console.warn('[ensureMarkerHidePolicy] error', e);
        return { hidden:false, error:e };
      }
    }

    async function subscribeReportedCommentsAdmin(){
      if (unsubRepComments){unsubRepComments();unsubRepComments=null;}
      if (!firebaseOk || !isAdmin){
        reportedComments = [];
        renderReportedComments();
        return;
      }
      const stops = [];

      stops.push(onSnapshot(query(collectionGroup(db,'comments'), where('reportPendingCount','>',0)),
        (snap)=> ingestCommentGroupSnap(snap),
        (err)=> console.warn('[rep-list count]', err)
      ));
      stops.push(onSnapshot(query(collectionGroup(db,'comments'), where('hiddenUntil','>', new Date())),
        (snap)=> ingestCommentGroupSnap(snap),
        (err)=> console.warn('[rep-list hidden]', err)
      ));
      stops.push(onSnapshot(query(collectionGroup(db,'reports'), where('status','==','pending')),
        async (snap)=>{
          const tasks = [];
          snap.forEach(d=>{
            const parentCommentRef = d.ref.parent.parent;
            if (!parentCommentRef) return;
            tasks.push(getDoc(parentCommentRef));
          });
          const parents = await Promise.all(tasks);
          const fakeSnap = { forEach: (fn)=> parents.forEach(ps=> { if(ps && ps.exists()) fn(ps); }) };
          ingestCommentGroupSnap(fakeSnap);
        },
        (err)=> console.warn('[rep-list reports]', err)
      ));
      stops.push(onSnapshot(collection(db,'adminReports'), snap=>{
        const now = nowMs();
        const idx = new Map(reportedComments.map(x=> [`${x.markerId}|${x.commentId}`, x]));
        snap.forEach(d=>{
          const docData = d.data()||{};
          const markerId = docData.markerId;
          const commentId = docData.commentId || null;
          const body = docData.body || '';
          const first = toMs(docData.createdAt) || now;
          const key = `${markerId}|${commentId}`;
          const merged = {
            markerId, commentId,
            body,
            firstReportAt:first,
            remainMs: 0,
            hidden: false,
            count: docData.reportPendingCount || 1,
            eligible: false,
            adminProxyId: d.id
          };
          idx.set(key, merged);
        });
        reportedComments = [...idx.values()].sort(sortReported);
        renderReportedComments();
      }, err=> console.warn('[adminReports]', err)));

      unsubRepComments = ()=> stops.forEach(s=> s());
    }

    function ingestCommentGroupSnap(snap){
      const now = nowMs();
      const idx = new Map(reportedComments.map(x=> [`${x.markerId}|${x.commentId}`, x]));
      snap.forEach(d=>{
        const p = d.ref.path.split('/');
        if (!(p[0]==='markers' && p[2]==='comments')) return;
        const markerId = p[1], commentId = p[3];
        const c = d.data()||{};
        const first = toMs(c.firstReportAt)||now;
        const hidden = toMs(c.hiddenUntil) > now;
        const remainMs = hidden ? (toMs(c.hiddenUntil)-now) : 0;
        const count = c.reportPendingCount||0;
        const eligible = (count>=HIDE_COUNT) || (!!first && (now-first)>=HIDE_DELAY_MS);

        const key = `${markerId}|${commentId}`;
        const prev = idx.get(key)||{};
        const merged = {
          markerId, commentId,
          body: c.body || prev.body || '(본문 없음)',
          firstReportAt:first, remainMs, hidden, count, eligible
        };
        idx.set(key, merged);
      });
      reportedComments = [...idx.values()].sort(sortReported);
      renderReportedComments();
    }

    function renderReportedComments(){
      const repCommentList = document.getElementById('repCommentList');
      if (!adminReportMode){ repCommentList.innerHTML=''; return; }
      if (!reportedComments.length){
        repCommentList.innerHTML = `<div style="opacity:.7">신고 접수된 댓글이 없습니다.</div>`;
        return;
      }
      let list = Array.isArray(reportedComments) ? [...reportedComments] : [];
      if (repFilterMode==='eligible')   list = list.filter(x=> x.eligible);
      if (repFilterMode==='ineligible') list = list.filter(x=> !x.eligible);
      list.sort(sortReported);

      repCommentList.innerHTML = list.map(rc=>{
        const midSafe = rc && rc.markerId ? String(rc.markerId).slice(0,6) : '??????';
        const cidSafe = rc && rc.commentId ? rc.commentId : '';
        const bodySafe = rc && rc.body ? rc.body : '(본문 없음)';
        return `
          <div class="ritem" data-mid="${esc(rc?.markerId||'')}" data-cid="${esc(cidSafe)}" data-adminproxy="${esc(rc?.adminProxyId||'')}">
            <div style="font-weight:600">#${midSafe}… · 댓글</div>
            <div style="white-space:pre-wrap;margin-top:6px">${esc(bodySafe)}</div>
            <div class="meta">${esc(statusTextOf(rc||{}))}</div>
            <div class="act">
              <button class="rbtn" data-jump>해당 핀 보기</button>
              <button class="rbtn" data-dismiss>신고 반려</button>
              <button class="rbtn warn" data-delete>원문 삭제</button>
            </div>
          </div>
        `;
      }).join('');

      repCommentList.onclick = async (e)=>{
        const card = e.target.closest('.ritem'); if (!card) return;
        const markerId = card.getAttribute('data-mid');
        const commentId= card.getAttribute('data-cid') || null;
        const proxyId  = card.getAttribute('data-adminproxy') || null;

        if (e.target.matches('[data-jump]')){
          const rec = markerMap.get(markerId);
          if (rec){
            openInfoWithSeq(rec.data);
            setTimeout(()=>{
              if (commentId){
                const el = document.getElementById('c-'+commentId);
                if (el) el.scrollIntoView({behavior:'smooth', block:'center'});
              }
            }, 400);
          } else alert('해당 핀을 지도에서 찾을 수 없습니다.');
          return;
        }

        if (e.target.matches('[data-dismiss]')){
          try{
            // ✅ 신고자에게 신뢰도 +15
            const reports = await getDocs(query(collection(db,'markers', markerId, 'comments', commentId, 'reports'), where('status','==','pending')));
            for (const r of reports.docs){
              const reporterUid = r.data().uid;
              if (reporterUid) await addTrust(reporterUid, 15, '신고 반려');
            }
            
            if (proxyId){
              await deleteDoc(doc(db,'adminReports', proxyId));
            } else {
              try{
                const q = query(collection(db,'adminReports'), where('markerId','==', markerId), where('commentId','==', commentId));
                const s = await getDocs(q);
                await Promise.all(s.docs.map(d=> deleteDoc(d.ref)));
              }catch(e){ console.warn('reject pending reports failed', e); }
            }
            try{
              const q = query(collection(db,'markers', markerId, 'comments', commentId, 'reports'), where('status','==','pending'));
              const s = await getDocs(q);
              await Promise.all(s.docs.map(d=> updateDoc(d.ref, { status:'rejected', reviewedAt: serverTimestamp() })));
            }catch(e){ console.warn('reject pending reports failed', e); }
            await updateDoc(doc(db,'markers', markerId, 'comments', commentId), {
              hiddenUntil: null,
              reportPendingCount: 0,
              reportsBlocked: true
            });
            try{ await updateDoc(doc(db,'markers', markerId), { reportPendingCount: 0 }); }catch(_e){}
            
            // ✅ 작성자 신뢰도 증가 없음 (반려 시 신뢰도 변화 없음)
            alert('신고 반려 완료 — 원본 댓글의 신고 카운트/뱃지를 제거하고 추가 신고를 차단했습니다.');
          }catch(err){
            alert('반려 처리 실패: ' + (err?.message||err));
          }
        }

        if (e.target.matches('[data-delete]')){
          if (!confirm('관리자 권한으로 원본 댓글을 삭제하시겠습니까?')) return;
          try{
            const cSnap = await getDoc(doc(db,'markers', markerId, 'comments', commentId));
            const authorUid = cSnap.data()?.uid;
            
            // ✅ 신고 승인: 신고자에게 110 XP, 작성자 신뢰도 -10
            const reports = await getDocs(query(collection(db,'markers', markerId, 'comments', commentId, 'reports'), where('status','==','pending')));
            for (const r of reports.docs){
              const reporterUid = r.data().uid;
              if (reporterUid){
                const pfRef = doc(db,'profiles', reporterUid);
                await setDoc(pfRef, { 
                  xp: increment(REPORT_APPROVED_XP),
                reportsApproved: increment(1)
                }, { merge:true });
                await checkAchievements(reporterUid);
              }
            }
            
            if (authorUid){
              await addTrust(authorUid, -10, '댓글 삭제됨 (신고 승인)');
              await safeMergeDoc(['profiles', authorUid], { commentsDeleted: increment(1) });
            }
            
            await updateDoc(doc(db,'markers', markerId, 'comments', commentId), { deleted:true });
            if (proxyId) await deleteDoc(doc(db,'adminReports', proxyId));
            else {
              try{
                const q = query(collection(db,'adminReports'), where('markerId','==', markerId), where('commentId','==', commentId));
                const s = await getDocs(q);
                await Promise.all(s.docs.map(d=> deleteDoc(d.ref)));
              }catch(_e){}
            }
            alert('원본 댓글을 삭제했습니다.');
          }catch(err){ alert('삭제 실패: ' + (err?.message||err)); }
        }
      };
    }

    /* ---------------- 마커 구독/렌더 + 조회수 ---------------- */
    const markerMap=new Map();
    let unsubMain=null, unsubPending=null;

    async function incrementViewCount(markerId){
      if (!firebaseOk) return;
      try{
        await updateDoc(doc(db,'markers', markerId), {
          viewCount: increment(1)
        });
      }catch(e){
        console.warn('[viewCount] increment failed', e);
      }
    }

    function subscribeMarkers(){
      if (!firebaseOk) return;
      if (unsubMain){unsubMain();} if (unsubPending){unsubPending();}
      markerMap.forEach(({group, marker})=> group.removeLayer(marker));
      markerMap.clear();

      const qApproved=query(collection(db,'markers'), where('status','==','approved'));
      unsubMain=onSnapshot(qApproved, s=>{
        s.docChanges().forEach(renderChange);
        recomputeSeqs();
        updateAllCategoryProgress();
        tryOpenDeepLink();
      });

      if (isAdmin){
        const qPending=query(collection(db,'markers'), where('status','==','pending'));
        unsubPending=onSnapshot(qPending, s=>{
          s.docChanges().forEach(renderChange);
          recomputeSeqs();
          updateAllCategoryProgress();
          tryOpenDeepLink();
        });
      }
    }

    function updateAllCategoryProgress(){
      CATEGORIES.forEach(c=> updateCategoryProgress(c.key));
    }

    function renderChange(ch){
      const id = ch.doc.id;
      if (ch.type === 'removed'){
        const prev = markerMap.get(id);
        if (prev){ prev.group.removeLayer(prev.marker); markerMap.delete(id); }
        return;
      }
      const m = { id, ...ch.doc.data() };

      // ✅ 카테고리 정규화(라벨/키 혼용 방지)
      m.category = resolveCategoryKey(m.category);

      if (Array.isArray(m.pokemon) && !Array.isArray(m.pokemonNorm)) {
        m.pokemonNorm = m.pokemon.map(normName);
      }

      if (markerMap.has(id)){
        const prev = markerMap.get(id);
        prev.group.removeLayer(prev.marker);
        markerMap.delete(id);
      }
      const group = ensureCatGroup(m.category);
      const mk = L.marker([m.y, m.x], { icon: iconFor(m.category) }).addTo(group);
      mk.on('click', ()=>openInfoWithSeq(m));
      markerMap.set(id, { group, marker: mk, data: m, seq: null, confirmed: LS.load(`pin_confirmed_${id}`, false) });
      applyVisibility(id);
    }

    function isHiddenByReport(m){ return toMs(m.hiddenUntil) > nowMs(); }
    
    function applyVisibility(id){
      const rec = markerMap.get(id); if (!rec) return;
      const {group, marker, data:m, confirmed} = rec;

      // ✅ 확인된 핀은 반투명 표시
      if (confirmed){
        marker.setOpacity(0.4);
      } else {
        marker.setOpacity(1);
      }

      if (adminReportMode){
        const ok = isHiddenByReport(m);
        if (ok){ if (!group.hasLayer(marker)) marker.addTo(group); }
        else   { if (group.hasLayer(marker)) group.removeLayer(marker); }
        return;
      }

      const catOn = catVisible.get(m.category) !== false;
      const hiddenForUser = isHiddenByReport(m) && !isAdmin;
      const txtOk = matchText(m);
      const statusOk = isAdmin ? (showPendingOnly ? m.status==='pending' : true) : (m.status==='approved');

      const ok = catOn && !hiddenForUser && txtOk && statusOk;
      if (ok){ if (!group.hasLayer(marker)) marker.addTo(group); }
      else   { if (group.hasLayer(marker)) group.removeLayer(marker); }
    }
    
    function applyAllVisibility(){ markerMap.forEach((_, id)=> applyVisibility(id)); }

    setInterval(()=> { applyAllVisibility(); recomputeSeqs(); }, 60*1000);

    async function _touchFirstAtIfEmpty(refPath){
      const r = doc(db, ...refPath);
      const s = await getDoc(r);
      if (!s.exists()) return null;
      const d = s.data()||{};
      if (!d.firstReportAt) await updateDoc(r, { firstReportAt: serverTimestamp() });
      return r;
    }

    async function submitCommentReport(markerId, commentId, reason){
      const cref = doc(db,'markers', markerId, 'comments', commentId);
      const cs = await getDoc(cref);
      if (!cs.exists()){ alert('댓글이 삭제되었습니다.'); return; }
      const cd = cs.data()||{};
      if (cd.reportsBlocked){ alert('관리자에 의해 이 댓글은 신고가 차단되었습니다.'); return; }

      // ✅ 신고 접수 시 신뢰도 -10
      if (me?.uid) await addTrust(me.uid, -10, '댓글 신고 접수');

      await addDoc(collection(db,'markers', markerId, 'comments', commentId, 'reports'), {
        type:'comment', markerId, commentId, uid: me?.uid||null, reason,
        status:'pending', createdAt: serverTimestamp()
      });

      await _touchFirstAtIfEmpty(['markers', markerId, 'comments', commentId]);
      await updateDoc(cref, { reportPendingCount: increment(1) });

      try{
        const body = cd.body || '(본문 없음)';
        await addDoc(collection(db,'adminReports'), {
          proxyType: 'comment',
          markerId, commentId,
          body,
          reporterUid: me?.uid || null,
          createdAt: serverTimestamp(),
          reportPendingCount: 1
        });
      }catch(_e){
        console.warn('[admin proxy create] failed', _e);
      }

      const res = await ensureCommentHidePolicy(markerId, commentId);
      if (res.hidden) alert('신고 누적/경과시간으로 댓글이 임시 숨김 처리되었습니다.');
      else alert('신고가 접수되었습니다. 조건 충족 시 자동으로 가려집니다.');
    }

    async function reportMarker(m, reason){
      if (!firebaseOk) return { ok:false, hid:false };
      const mref = doc(db,'markers', m.id);
      const ms = await getDoc(mref);
      const md = ms.data()||{};
      if (md.reportsBlocked){ alert('관리자에 의해 이 핀은 신고가 차단되었습니다.'); return {ok:false, hid:false}; }

      // ✅ 신고 접수 시 신뢰도 -10
      if (me?.uid) await addTrust(me.uid, -10, '핀 신고 접수');

      try{
        await addDoc(collection(db,'markers', m.id, 'reports'), {
          type:'marker', markerId: m.id, uid: me?.uid||null, reason,
          status:'pending', createdAt: serverTimestamp()
        });
      }catch(_e){}

      await _touchFirstAtIfEmpty(['markers', m.id]);
      await updateDoc(mref, { reportPendingCount: increment(1) });

      try{
        await addDoc(collection(db,'adminReports'), {
          proxyType: 'marker',
          markerId: m.id,
          commentId: null,
          body: m.title || '(핀 신고)',
          reporterUid: me?.uid || null,
          createdAt: serverTimestamp(),
          reportPendingCount: 1
        });
      }catch(_e){ console.warn('[admin proxy create] failed', _e); }

      const res = await ensureMarkerHidePolicy(m.id);
      if (res.hidden) alert('신고 누적/경과시간으로 핀이 임시 숨김 처리되었습니다.');
      else alert('신고가 접수되었습니다. 조건 충족 시 자동으로 가려집니다.');
      return { ok:true, hid:!!res.hidden };
    }

    /* ---------- 동적 시퀀스 ---------- */
    function visibleForSeq(m){
      if (!m) return false;
      if (adminReportMode) return isHiddenByReport(m);
      if (isHiddenByReport(m) && !isAdmin) return false;
      if (catVisible.get(m.category) === false) return false;
      if (!matchText(m)) return false;
      const statusOk = isAdmin ? (showPendingOnly ? m.status==='pending' : true) : (m.status==='approved');
      return !!statusOk;
    }

    function recomputeSeqs(){
      const items = [];
      markerMap.forEach(({data}, id)=>{
        if (visibleForSeq(data)){
          const created = toMs(data.createdAt) ?? 0;
          items.push({ id, created });
        }
      });
      items.sort((a,b)=> ((a.created || a._localCreatedAt || 0) - (b.created || b._localCreatedAt || 0)));
      const seqById = new Map();
      for (let i=0;i<items.length;i++) seqById.set(items[i].id, i+1);

      markerMap.forEach((rec, id)=>{ rec.seq = seqById.get(id) ?? null; });
      if (currentOpenId && markerMap.has(currentOpenId)){
        const rec = markerMap.get(currentOpenId);
        document.getElementById('infoId').textContent = rec.seq ? '#'+rec.seq : '#-';
      }
    }

    /* ---------------- 반응 시스템 ---------------- */
    const reactionMenu = document.getElementById('reactionMenu');
    let currentReactionTarget = null;

    function showReactionMenu(x, y, type, targetId, parentId){
      currentReactionTarget = {type, targetId, parentId};
      reactionMenu.style.left = x + 'px';
      reactionMenu.style.top = y + 'px';
      reactionMenu.style.display = 'block';
    }
    globalThis.showReactionMenu = showReactionMenu;


    function hideReactionMenu(){
      reactionMenu.style.display = 'none';
      currentReactionTarget = null;
    }

    document.addEventListener('click', (e)=>{
      if (!reactionMenu.contains(e.target)) hideReactionMenu();
    });

    reactionMenu.onclick = async (e)=>{
      const btn = e.target.closest('[data-emoji]');
      if (!btn || !currentReactionTarget) return;
      const emoji = btn.getAttribute('data-emoji');
      const {type, targetId, parentId} = currentReactionTarget;
      
      if (!me){
        alert('로그인이 필요합니다');
        hideReactionMenu();
        return;
      }

      try{
        if (type === 'pin'){
          const rRef = doc(db,'markers', targetId, 'reactions', me.uid);
          await setDoc(rRef, { emoji, uid: me.uid, createdAt: serverTimestamp() });
          
          // 반응 받은 사람 통계 업데이트
          const pinSnap = await getDoc(doc(db,'markers', targetId));
          const authorUid = pinSnap.data()?.authorUid;
          if (authorUid){
            await safeMergeDoc(['profiles', authorUid], { reactionsReceived: increment(1) });
          }
        } else if (type === 'comment'){
          const rRef = doc(db,'markers', parentId, 'comments', targetId, 'reactions', me.uid);
          await setDoc(rRef, { emoji, uid: me.uid, createdAt: serverTimestamp() });
          
          // 반응 받은 사람 통계 업데이트
          const cmtSnap = await getDoc(doc(db,'markers', parentId, 'comments', targetId));
          const authorUid = cmtSnap.data()?.uid;
          if (authorUid){
            await safeMergeDoc(['profiles', authorUid], { reactionsReceived: increment(1) });
          }
        }
        
        // 반응 준 사람 통계 업데이트
        await updateDoc(doc(db,'profiles', me.uid), {
          reactionsGiven: increment(1)
        });
        
        // 일일 미션 체크
        const mRef = doc(db,'profiles', me.uid, 'missions', 'daily');
        await setDoc(mRef, {
          reactionsToday: increment(1)
        }, {merge:true});
        
        // 주간 미션 체크
        const weekNum = getWeekNumber(new Date());
        const wRef = doc(db,'profiles', me.uid, 'missions', 'weekly');
        await setDoc(wRef, {
          currentWeek: weekNum,
          reactionsThisWeek: increment(1)
        }, {merge:true});
        
        await checkAchievements(me.uid);
        hideReactionMenu();
        
        // 화면 새로고침
        if (currentOpenId) openInfoWithSeq(markerMap.get(currentOpenId).data);
      }catch(err){
        alert('반응 추가 실패: ' + (err?.message||err));
        hideReactionMenu();
      }
    };

    async function loadReactions(type, targetId, parentId){
      if (!firebaseOk) return {};
      try{
        let rCol;
        if (type === 'pin'){
          rCol = collection(db,'markers', targetId, 'reactions');
        } else {
          rCol = collection(db,'markers', parentId, 'comments', targetId, 'reactions');
        }
        const snap = await getDocs(rCol);
        const counts = {};
        snap.forEach(d=>{
          const emoji = d.data().emoji;
          counts[emoji] = (counts[emoji]||0) + 1;
        });
        return counts;
      }catch{
        return {};
      }
    }

    function renderReactions(counts){
      if (!counts || Object.keys(counts).length === 0) return '';
      return Object.entries(counts).map(([emoji, count])=>`<span>${emoji} ${count}</span>`).join('');
    }
    
    // === 카테고리별 에디터 표시/초기화 ===
    const $tmEditor = document.getElementById('tmEditor');
    const $megaEditor = document.getElementById('megaEditor');
    const $missionEditor = document.getElementById('missionEditor');
    const $itemEditor = document.getElementById('itemEditor');
    const $pkEditor = document.getElementById('pkEditor');

    const $pkAddInput = document.getElementById('pkAddInput');
    const $pkAddBtn = document.getElementById('pkAddBtn');
    const $pkAddClear = document.getElementById('pkAddClear');
    const $pkChips = document.getElementById('pkChips');

    let pkSet = [];

    function renderPkChips(){
      $pkChips.innerHTML = pkSet.map((name, i) =>
        `<span class="tag" data-i="${i}" title="제거">${esc(name)}</span>`).join('');
      // 칩 클릭으로 제거
      $pkChips.querySelectorAll('.tag').forEach(tag=>{
        tag.onclick = () => {
          const i = +tag.getAttribute('data-i');
          pkSet.splice(i,1);
          renderPkChips();
        };
      });
    }

    function clearPkTags(){
      pkSet = [];
      renderPkChips();
      $pkAddInput.value = '';
    }

    $pkAddBtn.onclick = () => {
      const v = ($pkAddInput.value||'').trim();
      if(!v) return;
      if(!pkSet.includes(v)) pkSet.push(v);
      $pkAddInput.value = '';
      renderPkChips();
    };
    $pkAddClear.onclick = () => { clearPkTags(); };

    // 현재 선택된 카테고리에 맞춰 에디터 show/hide 및 불필요 입력 초기화
    function updateEditorsForCategory(catKey){
      const showTM = (catKey === TM_CAT);
      const showMega = (catKey === MEGA_STONE_CAT);
      const showMission = MISSION_CATS.includes(catKey);
      const showItem = ITEM_CATS.includes(catKey);
      const showPk = POKEMON_CATS.includes(catKey);

      $tmEditor.style.display = showTM ? 'block' : 'none';
      if(!showTM){ document.getElementById('tmNumber').value=''; document.getElementById('tmName').value=''; }

      $megaEditor.style.display = showMega ? 'block' : 'none';
      if(!showMega){ document.getElementById('megaPokemon').value=''; }

      $missionEditor.style.display = showMission ? 'block' : 'none';
      if(!showMission){ document.getElementById('missionNumber').value=''; }

      $itemEditor.style.display = showItem ? 'block' : 'none';
      if(!showItem){ document.getElementById('itemName').value=''; }

      $pkEditor.style.display = showPk ? 'block' : 'none';
      if(!showPk){ clearPkTags(); }
    }

    // 카테고리 변경 시 에디터 상태 갱신
    catSel.addEventListener('change', () => updateEditorsForCategory(catSel.value));
    // 초기 1회 적용
    updateEditorsForCategory(catSel.value);
  
    /* PATCH START: Suggest/Inquiry debounce & auto-close (2025-10-28) */
    const suggestModal = document.getElementById('suggestModal');
    const sgEditSave   = document.getElementById('sgEditSave');
    let __sgLock = false;

    if (sgEditSave){
      sgEditSave.addEventListener('click', async ()=>{
        if (__sgLock) return;
        const last = +LS.load('sg_last_ts', 0);
        if (Date.now() - last < 4000){ alert('연속 등록은 4초 후에 가능해요.'); return; }

        const titleEl = document.getElementById('sgEditTitle');
        const bodyEl  = document.getElementById('sgEditBody');
        const title = (titleEl?.value||'').trim();
        const body  = (bodyEl?.value||'').trim();
        if (!title || !body){ alert('제목/내용을 입력해주세요.'); return; }
        if (!firebaseOk){ alert('오프라인 상태입니다.'); return; }

        __sgLock = true; sgEditSave.disabled = true; sgEditSave.textContent = '등록중…';
        try{
          await addDoc(collection(db,'suggestions'), {
            title, body, uid: me?.uid||null, createdAt: serverTimestamp()
          });
          LS.save('sg_last_ts', Date.now());
          if (titleEl) titleEl.value = '';
          if (bodyEl)  bodyEl.value  = '';
          if (suggestModal) suggestModal.style.display = 'none';  // ✅ 자동 닫기
          alert('건의/문의가 등록되었습니다.');
        }catch(e){
          alert('등록 실패: ' + (e?.message||e));
        }finally{
          __sgLock = false; sgEditSave.disabled = false; sgEditSave.textContent = '등록';
        }
      });
    }
    /* PATCH END */
  
    /* ---------------- 상세 패널 + 캐러셀 + 댓글 ---------------- */
    const $info=document.getElementById('info');
    const $infoTitle=document.getElementById('infoTitle');
    const $infoId=document.getElementById('infoId');
    const $infoMeta=document.getElementById('infoMeta');
    const $infoBody=document.getElementById('infoBody');
    const $infoMediaTop=document.getElementById('infoMediaTop');
    const $infoBtns=document.getElementById('infoBtns');
    const $infoPk=document.getElementById('infoPk');
    const $copyLinkBtn=document.getElementById('copyLinkBtn');
    const $btnConfirm=document.getElementById('btnConfirm');
    const $pinViewCount=document.getElementById('pinViewCount');
    const $pinReactions=document.getElementById('pinReactions');

    const $carousel=document.getElementById('infoCarousel');
    const $carInner=document.getElementById('carInner');
    const $carPrev=document.getElementById('carPrev');
    const $carNext=document.getElementById('carNext');
    const $carDots=document.getElementById('carDots');
    let carIdx = 0, carItems = [];
    
    function buildCarousel(media){
      const rest = (media||[]).slice(1);
      if (!rest.length){ $carousel.style.display='none'; return; }
      $carousel.style.display='block';
      carItems = rest; carIdx = 0;
      $carInner.innerHTML = rest.map(m=>`
        <div class="item">
      ${ m.type==='video'
        ? `<video controls src="${m.url}" preload="metadata"></video>`
        : `<img src="${m.url}" loading="lazy" referrerpolicy="no-referrer" alt="">`
      }
         </div>`).join('');
      $carDots.innerHTML = rest.map((_,i)=>`<div class="dot ${i===0?'on':''}" data-i="${i}"></div>`).join('');
      updateCarousel();
      $carPrev.setAttribute('aria-controls','carInner');
      $carNext.setAttribute('aria-controls','carInner');
      $carInner.setAttribute('aria-live','polite');

    }
    
    function updateCarousel(){
      const w = $carousel.clientWidth || 1;
      $carInner.style.transform = `translateX(${-carIdx * w}px)`;
      [...$carDots.children].forEach((d,i)=> d.classList.toggle('on', i===carIdx));
    }
    
    window.addEventListener('resize', updateCarousel);
    $carPrev.onclick = ()=>{ if (carItems.length){ carIdx = (carIdx - 1 + carItems.length) % carItems.length; updateCarousel(); } };
    $carNext.onclick = ()=>{ if (carItems.length){ carIdx = (carIdx + 1) % carItems.length; updateCarousel(); } };
    $carDots.onclick = (e)=>{ const d = e.target.closest('.dot'); if (!d) return; carIdx = +d.getAttribute('data-i') || 0; updateCarousel(); };

    // ✅ 확인 버튼
    $btnConfirm.onclick = ()=>{
      if (!currentOpenId) return;
      const rec = markerMap.get(currentOpenId); if (!rec) return;

      rec.confirmed = !rec.confirmed;
      LS.save(`pin_confirmed_${currentOpenId}`, rec.confirmed);

      // 진행도 갱신
      updateCategoryProgress(rec.data.category);

      // 업적/통계 유지
      if (rec.confirmed && me){
        updateDoc(doc(db,'profiles', me.uid), {
          pinsConfirmed: increment(1)
        }).then(()=> checkAchievements(me.uid));
      }

      applyVisibility(currentOpenId);
      $btnConfirm.textContent = rec.confirmed ? '✓ 확인됨' : '✓ 확인';
      
      // 카테고리 진행도 업데이트
      const cat = rec.data.category;
      if (!catConfirmed.has(cat)) catConfirmed.set(cat, 0);
      catConfirmed.set(cat, catConfirmed.get(cat) + (rec.confirmed ? 1 : -1));
      updateCategoryProgress(cat);
      
      // 업적 체크
      if (rec.confirmed && me){
        updateDoc(doc(db,'profiles', me.uid), {
          pinsConfirmed: increment(1)
        }).then(()=> checkAchievements(me.uid));
      }
      
      applyVisibility(currentOpenId);
      $btnConfirm.textContent = rec.confirmed ? '✓ 확인됨' : '✓ 확인';
    };

    // 댓글
    const $cForm = document.getElementById('cForm');
    const $cBody = document.getElementById('cBody');
    const $cSubmit = document.getElementById('cSubmit');
    const $cList = document.getElementById('cList');
    let unsubComments = null;

    async function getDisplayForUid(uid){
      if (!firebaseOk || !uid) return {nick:'익명', rankCode:'Z', trust:10, isAdmin:false};
      const [pf, ad] = await Promise.all([
        getDoc(doc(db,'profiles', uid)).catch(()=>null),
        getDoc(doc(db,'admins', uid)).catch(()=>null)
      ]);
      const isAdm = ad && ad.exists();
      const nick = (pf && pf.exists() && (pf.data()?.nick)) || '익명';
      const rank = isAdm ? '관리자' : ((pf && pf.exists() && (pf.data()?.rankCode)) || 'Z');
      const trust = (pf && pf.exists() && (pf.data()?.trust !== undefined)) ? pf.data().trust : 10;
      return { nick, rankCode:rank, trust, isAdmin:isAdm };
    }

    /* PATCH START: other profile modal (2025-10-28) */
    async function openOtherProfile(uid){
      if (!firebaseOk || !uid){ alert('프로필을 불러올 수 없습니다.'); return; }
      try{
        const pfSnap = await getDoc(doc(db,'profiles', uid));
        const d = pfSnap.exists() ? (pfSnap.data()||{}) : {};
        document.getElementById('opNick').textContent  = d.nick || '(익명)';
        document.getElementById('opRank').textContent  = d.rankCode || 'Z';
        document.getElementById('opTrust').textContent = (d.trust ?? 10);
        document.getElementById('opXp').textContent    = (d.xp ?? 0);
        document.getElementById('opViews').textContent = (d.totalViews ?? 0);

        const list = document.getElementById('opAchievementList');
        const ids = d.achievementsUnlocked || [];
        if (!ids.length){
          list.innerHTML = '<div style="opacity:.7">표시할 업적 없음</div>';
        } else {
          list.innerHTML = ids.map(id=>{
            const meta = ACHIEVEMENTS.find(a=>a.id===id);
            if (!meta) return `<span class="achievement-badge">${esc(id)}</span>`;
            return `<span class="achievement-badge ${meta.tier}">${esc(meta.name)}</span>`;
          }).join('');
      }

        const modal = document.getElementById('otherProfileModal');
        modal.style.display = 'flex';
        document.getElementById('opClose').onclick = ()=> (modal.style.display = 'none');
      }catch(e){
        alert('프로필 로드 실패: ' + (e?.message||e));
      }
    }
    /* PATCH END */
  
    function fmtDisplay(nick, rankCode, trust, adm){
      const trustClass = trust < 0 ? 'trust-negative' : 'trust-positive';
      return `${nick} • ${adm ? '관리자' : rankCode} • 신뢰도: <span class="${trustClass}">${trust}</span>`;
    }

    
  
    function openComments(marker){
      if (!firebaseOk) { $cForm.style.display='none'; $cList.innerHTML=''; return; }
      if (unsubComments){unsubComments();unsubComments=null; }
      $cForm.style.display = me ? 'block':'none';
      $cBody.value='';
      const qC = query(collection(db,'markers', marker.id, 'comments'), orderBy('createdAt','asc'));
      unsubComments = onSnapshot(qC, async snap=>{
        const now = nowMs();
        const raw = [];
        snap.forEach(d=>{
          const c = { id:d.id, ...d.data() };
          const hidden = c.hiddenUntil ? (toMs(c.hiddenUntil) > now) : false;
          if (c.deleted) return;
          if (!isAdmin && hidden) return;
          raw.push({ ...c, _hidden:hidden });
        });

        const items = await Promise.all(raw.map(async c=>{
          let cnt = c.reportPendingCount || 0;
          try{
            if (!cnt){
              const q = query(collection(db,'markers', marker.id, 'comments', c.id, 'reports'), where('status','==','pending'));
              const s = await getDocs(q); cnt = s.size || 0;
            }
          }catch(_e){}
          const disp = await getDisplayForUid(c.uid);
          const reactions = await loadReactions('comment', c.id, marker.id);
          return { ...c, _repCnt: cnt, _disp: disp, _reactions: reactions };
        }));

        $cList.innerHTML = items.map(c => `
          <div class="citem ${c._hidden?'inactive':''}" id="c-${c.id}" oncontextmenu="event.preventDefault(); showReactionMenu(event.pageX, event.pageY, 'comment', '${c.id}', '${marker.id}'); return false;">
            <div class="meta">
              <span class="clickable" data-uid="${c.uid}">${fmtDisplay(c._disp.nick, c._disp.rankCode, c._disp.trust, c._disp.isAdmin)}</span> · ${new Date(toMs(c.createdAt||Date.now())).toLocaleString()}
              ${c._repCnt>0 ? `<span class="badge-report">신고 ${c._repCnt}</span>`:''}
              ${c._hidden ? `<span class="badge-hidden">가림중</span>`:''}
            </div>
            <div class="body" style="white-space:pre-wrap; margin-top:6px">${esc(c.body||'')}</div>
            <div class="reactions">${renderReactions(c._reactions)}</div>
            <div class="act">
              <button class="btn" data-crep="${c.id}">신고</button>
              ${(isAdmin || me?.uid===c.uid) ? `<button class="btn warn" data-cdel="${c.id}">삭제</button>`:''}
            </div>
          </div>`).join('');

        // 유저 프로필 클릭 이벤트
        $cList.querySelectorAll('[data-uid]').forEach(el=>{
          el.onclick = ()=> openOtherProfile(el.getAttribute('data-uid'));
        });

        $cList.querySelectorAll('[data-crep]').forEach(btn=>{
          btn.onclick = async ()=>{
            if (!me){ alert('로그인이 필요합니다'); return; }
            const cid = btn.getAttribute('data-crep');
            const reason = prompt('댓글 신고 사유를 입력해주세요'); if (!reason) return;
            await submitCommentReport(marker.id, cid, reason);
          };
        });
        $cList.querySelectorAll('[data-cdel]').forEach(btn=>{
          btn.onclick = async ()=>{
            const cid = btn.getAttribute('data-cdel');
            if (!confirm('댓글을 삭제할까요?')) return;
            await updateDoc(doc(db,'markers', marker.id, 'comments', cid), { deleted:true });
          };
        });
      });

      $cSubmit.onclick = async ()=>{
        if (!me) { alert('로그인 후 작성할 수 있어요.'); return; }
        const body = ($cBody.value||'').trim();
        if (!body) return;
        const myProfSnap = await getDoc(doc(db,'profiles', me.uid)).catch(()=>null);
        const nick = (myProfSnap && myProfSnap.exists() && myProfSnap.data().nick) || (me.displayName||'익명');
        await addDoc(collection(db,'markers', marker.id, 'comments'), {
          body, uid: me.uid, displayName: nick,
          createdAt: serverTimestamp(), deleted:false,
          reportPendingCount: 0, reportsBlocked: false
        });
        $cBody.value='';
        
        // ✅ 신뢰도 +5
        await addTrust(me.uid, 5, '댓글 작성');
        
        // ✅ 통계 업데이트
        await safeMergeDoc(['profiles', me.uid], { commentsCreated: increment(1) });

        
        // ✅ 일일 미션 체크
        const today = new Date().toISOString().split('T')[0];
        const mRef = doc(db,'profiles', me.uid, 'missions', 'daily');
        await setDoc(mRef, {
          commentsToday: increment(1),
          lastCommentDate: today
        }, {merge:true});
        
        await awardXP('comment');
        await checkAchievements(me.uid);
      };
    }

    function mediaTopEl(m){
      if (!m.media?.length) return '';
      const first=m.media[0];
      return (first.type==='video')
        ? `<video class="thumb" controls src="${first.url}" preload="metadata"></video>`
        : `<img class="thumb" src="${first.url}" loading="lazy" referrerpolicy="no-referrer" alt="thumb">`;
    }

    async function fetchMarkerPendingCount(markerId){
      try{
        const ms = await getDoc(doc(db,'markers', markerId));
        let cnt = (ms.exists() ? (ms.data().reportPendingCount||0) : 0);
        if (!cnt){
          const q = query(collection(db,'markers', markerId, 'reports'), where('status','==','pending'));
          const s = await getDocs(q); cnt = s.size||0;
        }
        return cnt;
      }catch(_e){ return 0; }
    }

    function openInfoWithSeq(m){
      const rec = markerMap.get(m.id);
      const seqNum = rec?.seq ?? null;
      openInfo(m, seqNum);
    }

    async function openInfo(m, seqNum){
      currentOpenId=m.id;
      
      // ✅ 조회수 증가
      await incrementViewCount(m.id);
      
      // ✅ 작성자의 총 조회수 업데이트
      if (m.authorUid){
        await safeMergeDoc(['profiles', m.authorUid], { totalViews: increment(1) });
      }
      
      $infoTitle.textContent=m.title||'(제목 없음)';
      $infoId.textContent = seqNum ? '#'+seqNum : '#-';
      const statusText = m.status || 'pending';

      const pinRepCnt = await fetchMarkerPendingCount(m.id);
      
      // ✅ 조회수 표시
      const viewCount = m.viewCount || 0;
      $pinViewCount.textContent = `조회 ${viewCount}`;

      // 작성자 닉/랭크/신뢰도 표시
      let authorDisp = '익명';
      try{
        if (m.authorUid){
          const disp = await getDisplayForUid(m.authorUid);
          authorDisp = `<span class="clickable" data-uid="${m.authorUid}">${fmtDisplay(disp.nick, disp.rankCode, disp.trust, disp.isAdmin)}</span>`;
        } else {
          authorDisp = m.displayName || '익명';
        }
      }catch{ authorDisp = m.displayName || '익명'; }

      $infoMeta.innerHTML = `
        <span>${labelFor(m.category)} · by ${authorDisp} · ${statusText}</span>
        ${pinRepCnt>0 ? `<span class="badge">신고 ${pinRepCnt}</span>`:''}
      `;
      
      // 유저 프로필 클릭 이벤트
      const authorLink = $infoMeta.querySelector('[data-uid]');
      if (authorLink){
        authorLink.onclick = ()=> openOtherProfile(authorLink.getAttribute('data-uid'));
      }

      $infoMediaTop.innerHTML = mediaTopEl(m);
      $infoBody.textContent = m.body||'';
      
      // ✅ 핀 반응 표시
      const pinReactions = await loadReactions('pin', m.id, null);
      $pinReactions.innerHTML = renderReactions(pinReactions);
      
      // 우클릭으로 반응 추가
      $infoBody.oncontextmenu = (e)=>{
        e.preventDefault();
        showReactionMenu(e.pageX, e.pageY, 'pin', m.id, null);
        return false;
      };

      if (POKEMON_CATS.includes(m.category) && Array.isArray(m.pokemon) && m.pokemon.length){
        $infoPk.style.display='flex';
        $infoPk.innerHTML = m.pokemon.map(n=>`<span class="tag" data-pk="${esc(n)}">${esc(n)}</span>`).join('');
        $infoPk.onclick = (e)=>{
          const t = e.target.closest('.tag[data-pk]'); if(!t) return;
          const name = t.getAttribute('data-pk');
          document.getElementById('qInput').value = name;
          setOnlyPokemonCats();
          applyTextFilter(name);
          alert(`"${name}" 출현 보고 핀만 표시합니다. (와일드/우두머리/메가)`);
        };
      } else { $infoPk.style.display='none'; $infoPk.innerHTML=''; }

      buildCarousel(m.media || []);

      const isMine = me && me.uid===m.authorUid;
      const canEdit = isMine && (m.status==='pending'||m.status===undefined);
      const hiddenNow = isHiddenByReport(m);
      
      // ✅ 확인 버튼 상태
      const rec = markerMap.get(m.id);
      if (rec){
        $btnConfirm.textContent = rec.confirmed ? '✓ 확인됨' : '✓ 확인';
      }

      $infoBtns.innerHTML = `
        <button id="btnReport" class="primary">핀 신고</button>
        ${canEdit ? `<button id="btnEdit">수정</button><button id="btnDel" class="warn">삭제</button>`:''}
        ${isAdmin ? `
            ${m.status==='pending'
              ? `<button id="btnAppr" class="primary">승인</button><button id="btnReject" class="warn">반려</button>`
              : ``}
            <button id="btnAdminDel" class="warn">관리자 삭제</button>
            <button id="btnReportDismiss" class="">신고 반려/차단</button>
            ${hiddenNow ? `<button id="btnUnhideNow">숨김 해제</button>`:''}
          ` : ``}
      `;

      const btnR=document.getElementById('btnReport');
      if (btnR) btnR.onclick = async ()=>{
        if (!me){ alert('로그인이 필요합니다'); return; }
        const reason = prompt('신고 사유를 입력해주세요'); if(!reason) return;
        try{
          const res = await reportMarker(m, reason);
          if (res.ok && !res.hid){ /* 안내는 reportMarker에서 */ }
          $info.style.display='none'; currentOpenId=null;
        }catch(err){ alert('신고 처리 중 오류: ' + (err?.message||err)); }
      };

      const btnE=document.getElementById('btnEdit');
      if (btnE) btnE.onclick=async()=>{
        if (!firebaseOk) return;
        const nt=prompt('제목 수정', m.title||''); if (nt===null) return;
        const nb=prompt('내용 수정', m.body||''); if (nb===null) return;
        await updateDoc(doc(db,'markers', m.id), { title:nt, body:nb });
      };

      const btnD=document.getElementById('btnDel');
      if (btnD) btnD.onclick=async()=>{
        if (!firebaseOk) return;
        if (!confirm('삭제할까요?')) return;
        await deleteDoc(doc(db,'markers', m.id));
        $info.style.display='none'; currentOpenId=null;
      };

      const btnAdminDel=document.getElementById('btnAdminDel');
      if (btnAdminDel) btnAdminDel.onclick = async ()=>{
        if (!firebaseOk) return;
        if (!confirm('이 핀을 완전히 삭제할까요?')) return;
        
        // ✅ 작성자 통계 업데이트
        if (m.authorUid){
          await safeMergeDoc(['profiles', m.authorUid], { pinsDeleted: increment(1) });
        }
        
        await deleteDoc(doc(db,'markers', m.id));
        $info.style.display='none'; currentOpenId=null;
      };

      const btnA=document.getElementById('btnAppr');
      if (btnA) btnA.onclick=async()=>{
        if (!firebaseOk) return;
        btnA.disabled=true; btnA.textContent='승인중...';
        try{ await updateDoc(doc(db,'markers', m.id), { status:'approved' }); }
        finally{ btnA.disabled=false; btnA.textContent='승인'; }
      };

      const btnRe=document.getElementById('btnReject');
      if (btnRe) btnRe.onclick=async()=>{
        if (!firebaseOk) return;
        btnRe.disabled=true; btnRe.textContent='반려중...';
        try{ await updateDoc(doc(db,'markers', m.id), { status:'rejected' }); }
        finally{ btnRe.disabled=false; btnRe.textContent='반려'; }
      };

      const btnReportDismiss = document.getElementById('btnReportDismiss');
      if (btnReportDismiss) btnReportDismiss.onclick = async ()=>{
        try{
          // ✅ 신고자에게 신뢰도 +15
          const reports = await getDocs(query(collection(db,'markers', m.id, 'reports'), where('status','==','pending')));
          for (const r of reports.docs){
            const reporterUid = r.data().uid;
            if (reporterUid) await addTrust(reporterUid, 15, '신고 반려');
          }
          
          try{
            const q = query(collection(db,'markers', m.id, 'reports'), where('status','==','pending'));
            const s = await getDocs(q);
            await Promise.all(s.docs.map(d=> updateDoc(d.ref, { status:'rejected', reviewedAt: serverTimestamp() })));
          }catch(e){ console.warn('reject pending reports failed', e); }
          await updateDoc(doc(db,'markers', m.id), { hiddenUntil: null, reportPendingCount: 0, reportsBlocked: true });
          try{
            const q2 = query(collection(db,'adminReports'), where('markerId','==', m.id));
            const s2 = await getDocs(q2);
            await Promise.all(s2.docs.map(d=> deleteDoc(d.ref)));
          }catch(e){ console.warn('reject pending reports failed', e); }
          const rec = markerMap.get(m.id);
          if (rec){ rec.data.hiddenUntil = null; rec.data.reportPendingCount=0; rec.data.reportsBlocked=true; applyVisibility(m.id); }
          alert('핀 신고를 반려하고, 추가 신고를 차단했습니다.');
        }catch(e){
          alert('처리 실패: ' + (e?.message||e));
        }
      };

      const btnUnhideNow = document.getElementById('btnUnhideNow');
      if (btnUnhideNow) btnUnhideNow.onclick = async ()=>{
        try{
          await updateDoc(doc(db,'markers', m.id), { hiddenUntil: null });
          const rec = markerMap.get(m.id);
          if (rec){ rec.data.hiddenUntil = null; applyVisibility(m.id); }
          alert('숨김을 해제했습니다.');
        }catch(e){
          alert('해제 실패: ' + (e?.message||e));
        }
      };

      $copyLinkBtn.onclick = async ()=>{
        const url = new URL(location.href);
        url.searchParams.set('mid', m.id);
        try{
          await navigator.clipboard.writeText(url.toString());
          alert('링크를 클립보드에 복사했습니다.');
        }catch{
          prompt('복사할 링크입니다. 수동으로 복사해주세요:', url.toString());
        }
      };

      $info.style.display='block';
      openComments(m);
    }

    const $infoClose=document.getElementById('infoClose');
    // 닉네임(작성자 표시 포함) 클릭 시 해당 유저 프로필 모달 열기 — 이벤트 위임
    document.addEventListener('click', (e)=>{
      const t = e.target.closest('[data-uid]');
      if (t) {
        const uid = t.getAttribute('data-uid');
        if (uid) openOtherProfile(uid);
     }
    });
        let currentOpenId=null;
    $infoClose.onclick=()=>{ $info.style.display='none'; currentOpenId=null; if (unsubComments){unsubComments();unsubComments=null;} };

    /* 딥링크 */
    let deepLinkTried = false;
    function tryOpenDeepLink(){
      if (deepLinkTried) return;
      const mid = new URL(location.href).searchParams.get('mid');
      if (!mid) { deepLinkTried = true; return; }
      const rec = markerMap.get(mid);
      if (rec){
        deepLinkTried = true;
        openInfoWithSeq(rec.data);
        map.panTo([rec.data.y, rec.data.x]);
      }
    }

    /* ---------------- 모드 전환 ---------------- */
    let mode = 'search';
    const btnSearch = document.getElementById('btnSearch');
    const btnPlace  = document.getElementById('btnPlace');

    const modalEl = document.getElementById('modal');
    const cancelBtn = document.getElementById('cancelBtn');
    const saveBtn   = document.getElementById('saveBtn');
    let pendingPos  = null;
    let _placeHandler = null;
    let _saveWired = false;

    // 모달 열고닫기 안전장치
    function openCreateModal(){
      if (!modalEl) return;
      document.getElementById('mTitle').value = '';
      document.getElementById('mBody').value  = '';
      // 기본 카테고리 디폴트 선택(원하면 바꿔도 됨)
      if (document.getElementById('mCat')) {
        document.getElementById('mCat').value = document.getElementById('mCat').value || TM_CAT;
      }
      modalEl.style.display = 'flex';
      }
    function closeCreateModal(){
      if (!modalEl) return;
      modalEl.style.display = 'none';
      pendingPos = null;
    }
    if (cancelBtn) cancelBtn.onclick = closeCreateModal;

    // 초기 진입 시 모달 강제 숨김 (접속 시 뜨던 문제 fix)
    if (modalEl) modalEl.style.display = 'none';

    function setMode(m){
      mode = m;
      btnSearch.classList.toggle('on', m === 'search');
      btnPlace.classList.toggle('on',  m === 'place');

      // 커서 표시
      map.getContainer().style.cursor = (m === 'place') ? 'crosshair' : '';

      // 이전 핸들러 제거
      if (_placeHandler){ map.off('click', _placeHandler); _placeHandler = null; }

      if (m === 'place'){
        _placeHandler = (e)=>{
          const ll = e.latlng;
          if (!isInside(ll)){ alert('지도를 벗어난 위치입니다.'); return; }
          pendingPos = { x: ll.lng, y: ll.lat };
          openCreateModal();
        };
        map.on('click', _placeHandler);
      }
    }

    btnSearch.onclick = ()=> setMode('search');
    btnPlace.onclick  = ()=> setMode('place');

    // 저장 버튼(중복 방지 + 좌표 필요)
    if (saveBtn && !_saveWired){
      _saveWired = true;
      let saving = false;
      saveBtn.addEventListener('click', async ()=>{
        if (saving) return;
        if (!firebaseOk){ alert('네트워크 차단/오프라인 상태입니다.'); return; }
        if (!pendingPos){ alert('지도를 클릭해 위치를 먼저 선택하세요.'); return; }

        const title = (document.getElementById('mTitle').value||'').trim();
        const body  = (document.getElementById('mBody').value||'').trim();
        const rawCat= (document.getElementById('mCat').value||'').trim();
        const cat   = resolveCategoryKey(rawCat);

        if (!title){ alert('제목을 입력하세요.'); return; }

        saving = true; saveBtn.disabled = true; saveBtn.textContent = '등록중…';
        try{
          const data = {
            title, body,
            category: cat,
            x: pendingPos.x, y: pendingPos.y,
            status: 'pending',
            authorUid: me?.uid || null,
            displayName: me?.displayName || '익명',
            createdAt: serverTimestamp(),
            media: []
          };
          const r = await addDoc(collection(db,'markers'), data);
          await safeMergeDoc(['profiles', me?.uid], { pinsCreated: increment(1) });
          await awardXP('pin');

          closeCreateModal();
          setMode('search');
          alert('핀 등록 완료! (검수 대기)');

          // 방금 등록한 핀 정보 패널 열기(로컬로라도)
          openInfo({ id: r.id, ...data }, null);
        }catch(e){
          alert('등록 실패: ' + (e?.message||e));
        }finally{
          saving = false; saveBtn.disabled = false; saveBtn.textContent = '등록';
        }
      });
    }

    // 페이지 최초 모드는 검색모드로 고정 (접속 시 모달 뜨던 문제 fix)
    setMode('search');

    /* ---------------- 입력/저장 ---------------- */
    const modal=document.getElementById('modal');
    const t=document.getElementById('mTitle');
    const b=document.getElementById('mBody');
    const imgsInp=document.getElementById('mImgs');
    const videoInp=document.getElementById('mVideo');
    
    // ✅ 추가 입력 필드
    const tmEditor = document.getElementById('tmEditor');
    const tmNumber = document.getElementById('tmNumber');
    const tmName = document.getElementById('tmName');
    const megaEditor = document.getElementById('megaEditor');
    const megaPokemon = document.getElementById('megaPokemon');
    const missionEditor = document.getElementById('missionEditor');
    const missionNumber = document.getElementById('missionNumber');
    const itemEditor = document.getElementById('itemEditor');
    const itemName = document.getElementById('itemName');

    document.getElementById('cancelBtn').onclick=()=>{ modal.style.display='none'; pending=null; };
    modal.addEventListener('click', (e)=>{ if(e.target===modal){ modal.style.display='none'; pending=null; } });
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal.style.display==='flex'){ modal.style.display='none'; pending=null; } });

    // 포켓몬 편집기
    const pkEditor = document.getElementById('pkEditor');
    const pkAddInput = document.getElementById('pkAddInput');
    const pkAddBtn = document.getElementById('pkAddBtn');
    const pkAddClear = document.getElementById('pkAddClear');
    const pkChips = document.getElementById('pkChips');
    let pkList = [];
    function redrawPkChips(){ pkChips.innerHTML = pkList.map((n,i)=>`<span class="tag" data-i="${i}">${esc(n)} ✕</span>`).join(''); }
    function addPk(){ const v=(pkAddInput.value||'').trim(); if(!v) return; if(!pkList.some(x=>normName(x)===normName(v))) pkList.push(v); pkAddInput.value=''; redrawPkChips(); }
    pkAddBtn.onclick = addPk;
    pkAddInput.addEventListener('keydown', e=>{ if(e.key==='Enter') addPk(); });
    pkAddClear.onclick = ()=>{ pkList=[]; redrawPkChips(); };

    // (카테고리 선택 초기화)
      catSel.value = CATEGORIES[0].key;
      const cat = catSel.value;
      pkEditor.style.display      = POKEMON_CATS.includes(cat) ? 'block' : 'none';
      tmEditor.style.display      = (cat === TM_CAT) ? 'block' : 'none';
      megaEditor.style.display    = (cat === MEGA_STONE_CAT) ? 'block' : 'none';
      missionEditor.style.display = MISSION_CATS.includes(cat) ? 'block' : 'none';
      itemEditor.style.display    = ITEM_CATS.includes(cat) ? 'block' : 'none';

      // 작성 모달 오픈
      modal.style.display = 'flex';
     

    let pending=null;
    map.on('click', (e)=>{
      if (mode !== 'place') return;

      // 사용자가 실제로 누른 클릭만 통과 (자동/스크립트/부수 효과 차단)
      if (!e?.originalEvent || !e.originalEvent.isTrusted) return;

      if (!me){ alert('로그인 후 등록할 수 있어요.'); return; }
      if (!isInside(e.latlng)){ alert('맵 바깥에는 등록할 수 없습니다'); return; }

      pending = e.latlng;
      // ... (나머지 기존 코드 동일)
      modal.style.display='flex';
      if (mode!=='place') return;
      if(!me){ alert('로그인 후 등록할 수 있어요.'); return; }
      if(!isInside(e.latlng)){ alert('맵 바깥에는 등록할 수 없습니다'); return; }
      t.value=''; b.value=''; imgsInp.value=''; videoInp.value='';
      tmNumber.value=''; tmName.value=''; megaPokemon.value=''; missionNumber.value=''; itemName.value='';
      pkList=[]; redrawPkChips();
      if (!catSel.value) catSel.value=CATEGORIES[0].key;
      
      const cat = catSel.value;
      pkEditor.style.display = POKEMON_CATS.includes(cat) ? 'block' : 'none';
      tmEditor.style.display = cat === TM_CAT ? 'block' : 'none';
      megaEditor.style.display = cat === MEGA_STONE_CAT ? 'block' : 'none';
      missionEditor.style.display = MISSION_CATS.includes(cat) ? 'block' : 'none';
      itemEditor.style.display = ITEM_CATS.includes(cat) ? 'block' : 'none';      
    });

    document.getElementById('saveBtn').onclick = async () => {
      if (!me || !pending) return;
      if (!firebaseOk) { alert('네트워크 차단으로 저장 불가'); return; }

      const imgFiles = imgsInp.files ? Array.from(imgsInp.files) : [];
      const vidFile  = (videoInp.files && videoInp.files[0]) ? videoInp.files[0] : null;

      const saveBtn = document.getElementById('saveBtn');
      const setBtn  = (t)=> saveBtn.textContent = t;
      const prevTxt = saveBtn.textContent;
      saveBtn.disabled = true;
      try {
        const pfSnap = await getDoc(doc(db,'profiles', me.uid)).catch(()=>null);
        const displayName = (pfSnap && pfSnap.exists() && pfSnap.data().nick) || (me.displayName || '익명');

        const media=[];
        for (let i=0;i<imgFiles.length;i++){
          const url = await globalThis.uploadSmart(imgFiles[i], 'markerMedia', setBtn, `이미지 ${i+1}/${imgFiles.length}`);
          media.push({type:'image', url});
        }
        if (vidFile){
          const url = await globalThis.uploadSmart(vidFile, 'markerMedia', setBtn, '동영상');
          media.push({type:'video', url});
        }

        const thumbUrl = media.length ? media[0].url : null;

        setBtn('저장 중…');
        const inPkCat = POKEMON_CATS.includes(catSel.value);
        const markerData = {
          x: pending.lng, y: pending.lat,
          title: t.value, body: b.value,
          category: catSel.value,
          media, thumbUrl,
          displayName, authorUid: me.uid,
          createdAt: serverTimestamp(),
          status: 'pending',
          hiddenUntil: null,
          reportPendingCount: 0, reportsBlocked: false,
          viewCount: 0,
          _localCreatedAt: Date.now(), // ✅ 보정용
          ...(inPkCat ? { pokemon: pkList, pokemonNorm: pkList.map(normName) } : {})
        };
        
        // ✅ 추가 필드 저장
        if (catSel.value === TM_CAT){
          markerData.tmNumber = tmNumber.value;
          markerData.tmName = tmName.value;
        }
        if (catSel.value === MEGA_STONE_CAT){
          markerData.megaPokemon = megaPokemon.value;
        }
        if (MISSION_CATS.includes(catSel.value)){
          markerData.missionNumber = missionNumber.value;
        }
        if (ITEM_CATS.includes(catSel.value)){
          markerData.itemName = itemName.value;
        }
        
        await addDoc(collection(db,'markers'), markerData);
        modal.style.display='none'; pending=null;
        setBtn('등록 완료!'); setTimeout(()=>{ saveBtn.disabled=false; setBtn(prevTxt); }, 700);

        // ✅ 신뢰도 +10
        await addTrust(me.uid, 10, '핀 등록');
        
        // ✅ 통계 업데이트
        await updateDoc(doc(db,'profiles', me.uid), {
          pinsCreated: increment(1)
        });
        
        // ✅ 주간 미션 체크
        const weekNum = getWeekNumber(new Date());
        const wRef = doc(db,'profiles', me.uid, 'missions', 'weekly');
        await setDoc(wRef, {
          currentWeek: weekNum,
          pinsThisWeek: increment(1)
        }, {merge:true});
        
        await awardXP('pin');
        await checkAchievements(me.uid);
      } catch (err) {
        alert('저장 실패: ' + (err?.message||err));
        saveBtn.disabled=false; setBtn(prevTxt);
      }
    };

    /* ---------------- 텍스트 매칭 ---------------- */
    function matchText(m){
      if (!textFilter) return true;
      const q = textFilter;
      const base = norm(`${m.title||''} ${m.body||''}`);
      if (base.includes(q)) return true;
      const qn = normName(q);
      if (Array.isArray(m.pokemonNorm) && m.pokemonNorm.some(p => p.includes(qn))) return true;
      return false;
    }

    // 초기 구독
    subscribeMarkers();
    subscribeReportedCommentsAdmin();
    // === 타 유저 프로필 열기 ===
    async function openOtherProfile(uid){
      if (!uid) return;
      if (!firebaseOk){ alert('오프라인 상태입니다.'); return; }

      try{
        const [pfSnap, adSnap] = await Promise.all([
          getDoc(doc(db,'profiles', uid)).catch(()=>null),
        getDoc(doc(db,'admins', uid)).catch(()=>null)
      ]);

      const d = (pfSnap && pfSnap.exists()) ? (pfSnap.data()||{}) : {};
        const isAdm = !!(adSnap && adSnap.exists());

      const nick  = d.nick || '익명';
      const rank  = isAdm ? '관리자' : (d.rankCode || 'Z');
      const trust = (d.trust !== undefined) ? d.trust : 10;
      const xp    = d.xp || 0;
      const views = d.totalViews || 0;

      document.getElementById('opNick').textContent  = nick;
        document.getElementById('opRank').textContent  = rank;
        document.getElementById('opTrust').textContent = trust;
        document.getElementById('opXp').textContent    = xp;
      document.getElementById('opViews').textContent = views;

      // 전시 업적
      const wrap = document.getElementById('opAchievementList');
        const displayed = d.achievementsDisplayed || [];
        const unlocked  = new Set(d.achievementsUnlocked || []);
        const byId = new Map(ACHIEVEMENTS.map(a=>[a.id,a]));
        const list = (displayed.length ? displayed : Array.from(unlocked).slice(0,3))
                      .map(id => byId.get(id))
                      .filter(Boolean);
      
        wrap.innerHTML = list.length
          ? list.map(a=>`<span class="achievement-badge ${a.tier}">${a.name}</span>`).join('')
          : '<div style="opacity:.7">전시된 업적이 없습니다</div>';
          const modal = document.getElementById('otherProfileModal');
          // 방문 시 무조건 닫혀 있게 강제
            modal.style.display = 'none';
            pending = null;

        modal.style.display = 'flex';
        document.getElementById('opClose').onclick = ()=>{ modal.style.display='none'; };
        modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; }, { once:true });
      }catch(e){
       console.warn('[openOtherProfile] failed', e);
       alert('프로필을 불러오지 못했습니다.');   
      }
    }

    /* ====== 프로필 UI ====== */
    const profileModal = document.getElementById('profileModal');
    const pfNick = document.getElementById('pfNick');
    const pfRank = document.getElementById('pfRank');
    const pfTrust = document.getElementById('pfTrust');
    const pfXpFill = document.getElementById('pfXpFill');
    const pfXpText = document.getElementById('pfXpText');
    const pfTotalViews = document.getElementById('pfTotalViews');
    const pfTotalReactions = document.getElementById('pfTotalReactions');
    const pfWho = document.getElementById('pfWho');
    const pfClose = document.getElementById('pfClose');
    const pfSave = document.getElementById('pfSave');
    const pfTrustHistory = document.getElementById('pfTrustHistory');
    const pfManageAchievements = document.getElementById('pfManageAchievements');
    const pfAchievementList = document.getElementById('pfAchievementList');
    
    function openProfile(force=false){
      if (!me){ alert('로그인이 필요합니다.'); return; }
      pfWho.textContent = `구글: ${me.displayName||'(이름 없음)'} · ${me.email||''}`;
      profileModal.style.display='flex';
      loadProfile(force);
    }
    
    async function loadProfile(){
      if (!firebaseOk || !me) return;
      const pfRef = doc(db,'profiles', me.uid);
      const s = await getDoc(pfRef);
      const d = s.exists()? (s.data()||{}) : { nick: me.displayName||'익명', xp:0, rankCode:'Z', trust:10 };
      pfNick.value = d.nick || (me.displayName||'익명');
      
      // ✅ 관리자는 랭크를 "관리자"로 표시, XP바 꽉 찬 상태, 남은 경험치 X
      if (isAdmin){
        pfRank.textContent = '관리자';
        pfXpFill.style.width = '100%';
        pfXpText.textContent = 'X';
      } else {
        pfRank.textContent = d.rankCode || 'Z';
        const calc = totalToRank(d.xp||0);
        const percent = calc.next > 0 ? Math.round((calc.cur / (calc.cur + calc.next)) * 100) : 100;
        pfXpFill.style.width = percent + '%';
        pfXpText.textContent = `${calc.cur} / ${calc.cur + calc.next} XP`;
      }
      
      pfTrust.textContent = d.trust !== undefined ? d.trust : 10;
      pfTrust.className = (d.trust||10) < 0 ? 'trust-negative' : '';
      pfTotalViews.textContent = d.totalViews || 0;
      pfTotalReactions.textContent = d.reactionsReceived || 0;
      
      // ✅ 전시 업적 표시
      const displayed = d.achievementsDisplayed || [];
      const unlocked = d.achievementsUnlocked || [];
      pfAchievementList.innerHTML = displayed.length > 0
        ? displayed.map(achId=>{
            const ach = ACHIEVEMENTS.find(a=>a.id===achId);
            return ach ? `<div class="achievement-badge ${ach.tier}">${ach.name}</div>` : '';
          }).join('')
        : '<div style="opacity:.7">전시된 업적이 없습니다</div>';
    }
    
    $btnProfile.onclick = ()=> openProfile();
    pfClose.onclick = ()=> profileModal.style.display='none';
    profileModal.addEventListener('click', (e)=>{ if(e.target===profileModal) profileModal.style.display='none'; });
    
    pfSave.onclick = async ()=>{
      if (!firebaseOk || !me) return;
      const nick = (pfNick.value||'').trim() || (me.displayName||'익명');
      const pfRef = doc(db,'profiles', me.uid);
      await setDoc(pfRef, { uid: me.uid, nick }, { merge:true });
      profileModal.style.display='none';
      await refreshTopName();
      alert('프로필이 저장되었습니다.');
    };
    
    pfTrustHistory.onclick = ()=> openTrustHistory();
    pfManageAchievements.onclick = ()=> openAchievementManagement();

    /* ====== 타 유저 프로필 모달 ====== */
    const otherProfileModal = document.getElementById('otherProfileModal');
    const opNick = document.getElementById('opNick');
    const opRank = document.getElementById('opRank');
    const opTrust = document.getElementById('opTrust');
    const opXp = document.getElementById('opXp');
    const opViews = document.getElementById('opViews');
    const opAchievementList = document.getElementById('opAchievementList');
    const opClose = document.getElementById('opClose');
    
    
    
    opClose.onclick = ()=> otherProfileModal.style.display='none';
    otherProfileModal.addEventListener('click', (e)=>{ if(e.target===otherProfileModal) otherProfileModal.style.display='none'; });

    /* ====== 신뢰도 내역 모달 ====== */
    const trustHistoryModal = document.getElementById('trustHistoryModal');
    const trustHistoryList = document.getElementById('trustHistoryList');
    const thClose = document.getElementById('thClose');
    
    async function openTrustHistory(){
      if (!firebaseOk || !me) return;
      const q = query(collection(db,'profiles', me.uid, 'trustHistory'), orderBy('timestamp','desc'), limit(50));
      const snap = await getDocs(q);
      
      if (snap.empty){
        trustHistoryList.innerHTML = '<div style="opacity:.7">내역이 없습니다</div>';
      } else {
        trustHistoryList.innerHTML = snap.docs.map(d=>{
          const data = d.data();
          const amountClass = data.amount >= 0 ? 'trust-positive' : 'trust-negative';
          return `
            <div style="background:#2a2a2a; padding:8px; margin:6px 0; border-radius:6px">
              <div><span class="${amountClass}">${data.amount >= 0 ? '+' : ''}${data.amount}</span> · ${esc(data.reason||'')}</div>
              <div style="font-size:11px; opacity:.7">${new Date(toMs(data.timestamp)).toLocaleString()} · 총 ${data.newTotal}</div>
            </div>
          `;
        }).join('');
      }
      
      trustHistoryModal.style.display='flex';
    }
    
    thClose.onclick = ()=> trustHistoryModal.style.display='none';
    trustHistoryModal.addEventListener('click', (e)=>{ if(e.target===trustHistoryModal) trustHistoryModal.style.display='none'; });

    /* ====== 업적 관리 모달 ====== */
    const achievementModal = document.getElementById('achievementModal');
    const achievementList = document.getElementById('achievementList');
    const achClose = document.getElementById('achClose');
    
    async function openAchievementManagement(){
      if (!firebaseOk || !me) return;
      const pfSnap = await getDoc(doc(db,'profiles', me.uid));
      const unlocked = pfSnap.exists() ? (pfSnap.data().achievementsUnlocked || []) : [];
      const displayed = pfSnap.exists() ? (pfSnap.data().achievementsDisplayed || []) : [];
      
      achievementList.innerHTML = ACHIEVEMENTS.map(ach=>{
        const isUnlocked = unlocked.includes(ach.id);
        const isDisplayed = displayed.includes(ach.id);
        const tierLabels = {normal:'노말', rare:'레어', epic:'에픽', legend:'레전드'};
        
        return `
          <div class="achievement-badge ${ach.tier}" style="display:flex; justify-content:space-between; align-items:center; opacity:${isUnlocked?1:0.3}; margin:8px 0">
            <div>
              <strong>${ach.name}</strong> (${tierLabels[ach.tier]})<br>
              <span style="font-size:11px">${ach.desc}</span>
            </div>
            ${isUnlocked ? `
              <button class="tbtn" style="margin:0" data-toggle="${ach.id}">
                ${isDisplayed ? '전시 해제' : '전시하기'}
              </button>
            ` : ''}
          </div>
        `;
      }).join('');
      
      achievementList.onclick = async (e)=>{
        const btn = e.target.closest('[data-toggle]');
        if (!btn) return;
        const achId = btn.getAttribute('data-toggle');
        const pfRef = doc(db,'profiles', me.uid);
        const pfSnap = await getDoc(pfRef);
        const currentDisplayed = pfSnap.data().achievementsDisplayed || [];
        
        if (currentDisplayed.includes(achId)){
          await updateDoc(pfRef, {
            achievementsDisplayed: arrayRemove(achId)
          });
        } else {
          if (currentDisplayed.length >= 3){
            alert('최대 3개까지만 전시할 수 있습니다');
            return;
          }
          await updateDoc(pfRef, {
            achievementsDisplayed: arrayUnion(achId)
          });
        }
        openAchievementManagement();
      };
      
      achievementModal.style.display='flex';
    }
    
    achClose.onclick = ()=> achievementModal.style.display='none';
    achievementModal.addEventListener('click', (e)=>{ if(e.target===achievementModal) achievementModal.style.display='none'; });

    /* ====== 관리자 메신저 모달 ====== */
    const messengerModal = document.getElementById('messengerModal');
    const chatBox = document.getElementById('chatBox');
    const msgInput = document.getElementById('msgInput');
    const msgSend = document.getElementById('msgSend');
    const msgClose = document.getElementById('msgClose');
    let unsubChat=null;

    function openMessenger(){
      if (!isAdmin){ alert('관리진 전용'); return; }
      messengerModal.style.display='flex';
      markSeenNow();
      if (!unsubChat){
        const qy = query(collection(db,'adminChat'), orderBy('createdAt','asc'));
        unsubChat = onSnapshot(qy, async snap=>{
          chatBox.innerHTML = '';
          for (const d of snap.docs){
            const v = d.data()||{};
            if (v.type==='notice'){
              chatBox.insertAdjacentHTML('beforeend', `
                <div class="sys-notice">
                  <h4>📢 공지: ${esc(v.title||'(제목 없음)')}</h4>
                  <p>${esc(v.body||'')}</p>
                </div>
              `);
            } else if (v.type==='suggestion'){
              // ✅ 건의 및 문의 카드
              chatBox.insertAdjacentHTML('beforeend', `
                <div class="sys-notice" style="background:#1a3a5f; cursor:pointer" data-suggest-id="${v.suggestionId}">
                  <h4>💡 새 건의: ${esc(v.title||'(제목 없음)')}</h4>
                  <p>${esc((v.body||'').slice(0,100))}${(v.body||'').length>100?'...':''}</p>
                </div>
              `);
            } else {
              const mine = v.uid===me?.uid;
              const disp = await getDisplayForUid(v.uid);
              chatBox.insertAdjacentHTML('beforeend', `
                <div class="chat-row ${mine?'me':'other'}">
                  <div>
                    <div class="bubble">${esc(v.body||'')}</div>
                    <div class="chat-meta">${esc(fmtDisplay(disp.nick, disp.rankCode, disp.trust, disp.isAdmin))} · ${new Date(toMs(v.createdAt||Date.now())).toLocaleString()}</div>
                  </div>
                </div>
              `);
            }
          }
          
          // 건의 카드 클릭 이벤트
          chatBox.querySelectorAll('[data-suggest-id]').forEach(card=>{
            card.onclick = (ev)=>{
              ev.preventDefault();
              const y = chatBox.scrollTop;
              openSuggestDetail(card.getAttribute('data-suggest-id'));
              setTimeout(()=> chatBox.scrollTop = y, 0);
            };
          });
          
          chatBox.scrollTop = chatBox.scrollHeight;
        });
      }
    }
    
    function closeMessenger(){ messengerModal.style.display='none'; }
    msgClose.onclick = closeMessenger;
    messengerModal.addEventListener('click', (e)=>{ if(e.target===messengerModal) closeMessenger(); });

    msgSend.onclick = async ()=>{
      const body = (msgInput.value||'').trim();
      if (!body) return;
      await addDoc(collection(db,'adminChat'), { uid: me?.uid||null, body, type:'text', createdAt: serverTimestamp() });
      msgInput.value='';
      markSeenNow();
    };

    $btnMsg.onclick = ()=> openMessenger();

    async function markSeenNow(){
      if (!firebaseOk || !me || !isAdmin) return;
      await setDoc(doc(db,'adminSeen', me.uid), { last: serverTimestamp() }, { merge:true });
      $msgBang.classList.remove('show');
    }
    
    function wireAdminMessenger(){
      // 중복 선언 방지: 이미 있으면 건드리지 않음
      globalThis.wireAdminMessenger ??= function wireAdminMessenger(){
        /* no-op: 관리자 메신저 미구현 방지 */
      };

      if (!firebaseOk || !isAdmin || !me) { $msgBang.classList.remove('show'); return; }
      const unsubs = [];
      Promise.all([
        getDoc(doc(db,'adminSeen', me.uid)).catch(()=>null)
      ]).then(([seen])=>{
        let last = toMs(seen?.data()?.last) || 0;
        unsubs.push(onSnapshot(query(collection(db,'adminChat'), orderBy('createdAt','asc')), snap=>{
          let hasNew=false;
          snap.forEach(d=>{
            const v=d.data()||{};
            const ct = toMs(v.createdAt||0) || 0;
            if (ct>last && v.uid!==me?.uid){ hasNew=true; }
          });
          $msgBang.classList.toggle('show', hasNew);
        }));
      });
    }

    /* ====== 공지 시스템 ====== */
    const noticeModal = document.getElementById('noticeModal');
    const noticeListModal = document.getElementById('noticeListModal');
    const ntListWrap = document.getElementById('ntListWrap');
    const ntNew = document.getElementById('ntNew');
    const btnNoticeList = document.getElementById('btnNoticeList');
    const noticeClose = document.getElementById('noticeClose');
    const ntListClose = document.getElementById('ntListClose');
    const noticeView = document.getElementById('noticeView');
    const noticeEdit = document.getElementById('noticeEdit');
    const noticeTitle = document.getElementById('noticeTitle');
    const noticeBody = document.getElementById('noticeBody');
    const noticeDate = document.getElementById('noticeDate');
    const noticeFiles = document.getElementById('noticeFiles');
    const noticeAdminBtns = document.getElementById('noticeAdminBtns');
    const noticeHide24 = document.getElementById('noticeHide24');
    const noticeDismiss = document.getElementById('noticeDismiss');
    const noticeViewCount = document.getElementById('noticeViewCount');
    const ntTitle = document.getElementById('ntTitle');
    const ntBody = document.getElementById('ntBody');
    const ntFiles = document.getElementById('ntFiles');
    const ntCancel = document.getElementById('ntCancel');
    const ntSave = document.getElementById('ntSave');

    let currentNoticeId = null;

    btnNoticeList.onclick = ()=> openNoticeList();

    function openNoticeList(){
      if (!firebaseOk){ alert('네트워크 필요'); return; }
      noticeListModal.style.display='flex';
      renderNoticeList();
      ntNew.style.display = isAdmin ? 'inline-block' : 'none';
      
      // ✅ 일일 미션: 공지 확인
      if (me){
        const today = new Date().toISOString().split('T')[0];
        const mRef = doc(db,'profiles', me.uid, 'missions', 'daily');
        setDoc(mRef, {
          noticeCheckedToday: true,
          lastNoticeCheckDate: today
        }, {merge:true});
      }
    }
    
    ntListClose.onclick = ()=> noticeListModal.style.display='none';
    noticeListModal.addEventListener('click', (e)=>{ if(e.target===noticeListModal) noticeListModal.style.display='none'; });

    async function renderNoticeList(){
      const qs = query(collection(db,'notices'), orderBy('createdAt','desc'));
      const snap = await getDocs(qs);
      ntListWrap.innerHTML = [...snap.docs].map(d=>{
        const v = d.data()||{};
        const dt = new Date(toMs(v.createdAt||Date.now())).toLocaleString();
        const viewCount = v.viewCount || 0;
        return `<div class="ritem" data-id="${d.id}">
          <div style="font-weight:600">${esc(v.title||'(제목 없음)')}</div>
          <div class="meta">${dt} · 조회 ${viewCount}</div>
          <div style="margin-top:6px"><button class="rbtn" data-open>열기</button></div>
        </div>`;
      }).join('') || `<div style="opacity:.7">등록된 공지가 없습니다.</div>`;
      ntListWrap.onclick = (e)=>{
        const card = e.target.closest('.ritem'); if(!card) return;
        if (e.target.matches('[data-open]')) openNotice(card.getAttribute('data-id'));
      };
    }

    async function openNotice(id){
      const s = await getDoc(doc(db,'notices', id));
      if (!s.exists()){ alert('삭제된 공지입니다'); return; }
      const v = s.data()||{};
      currentNoticeId = id;
      
      // ✅ 조회수 증가
      await safeMergeDoc(['notices', id], { viewCount: increment(1) });
      
      noticeEdit.style.display='none';
      noticeView.style.display='block';
      noticeModal.style.display='flex';
      noticeTitle.textContent = v.title||'(제목 없음)';
      noticeBody.textContent = v.body||'';
      noticeDate.textContent = new Date(toMs(v.createdAt||Date.now())).toLocaleString();
      noticeViewCount.textContent = `조회 ${(v.viewCount||0)+1}`;
      
      if (Array.isArray(v.files)&&v.files.length){
        noticeFiles.innerHTML = v.files.map(f=>`<div><a href="${f.url}" target="_blank" rel="noopener noreferrer">${esc(f.name||'파일')}</a></div>`).join('');
      } else noticeFiles.innerHTML='';

      if (isAdmin){
        noticeAdminBtns.innerHTML = `
          <button id="ntEdit" class="tbtn">수정</button>
          <button id="ntDel" class="tbtn">삭제</button>
        `;
        document.getElementById('ntEdit').onclick = ()=> editNotice(id, v);
        document.getElementById('ntDel').onclick = async ()=>{
          if (!confirm('이 공지를 삭제할까요?')) return;
          await deleteDoc(doc(db,'notices', id));
          noticeModal.style.display='none';
          renderNoticeList();
        };
      } else {
        noticeAdminBtns.innerHTML = '';
      }
    }
    
    noticeClose.onclick = ()=> noticeModal.style.display='none';
    noticeModal.addEventListener('click', (e)=>{ if(e.target===noticeModal) noticeModal.style.display='none'; });

    function editNotice(id, v){
      noticeEdit.style.display='block';
      noticeView.style.display='none';
      ntTitle.value = v.title||'';
      ntBody.value  = v.body||'';
      noticeModal.style.display='flex';
      currentNoticeId = id;
    }

    ntNew.onclick = ()=> {
      noticeEdit.style.display='block';
      noticeView.style.display='none';
      noticeModal.style.display='flex';
      ntTitle.value=''; ntBody.value=''; ntFiles.value='';
      currentNoticeId=null;
    };
    ntCancel.onclick = ()=> { noticeModal.style.display='none'; };

    ntSave.onclick = async ()=>{
      if (!firebaseOk || !isAdmin){ alert('권한 없음'); return; }
      if (!confirm('공지 작성시 유저 모두에게 보이게 됩니다. 이 내용이 맞습니까?')) return;
      const files = Array.from(ntFiles.files||[]);
      const uploaded = [];
      for (let i=0;i<files.length;i++){
        const url = await uploadSmart(files[i], 'noticeFiles', (t)=>{}, `파일 ${i+1}/${files.length}`);
        uploaded.push({ name: files[i].name, url });
      }
      const payload = {
        title: ntTitle.value||'(제목 없음)',
        body: ntBody.value||'',
        files: uploaded,
        authorUid: me?.uid||null,
        createdAt: serverTimestamp(),
        viewCount: 0
      };
      const docRef = currentNoticeId
        ? (await updateDoc(doc(db,'notices', currentNoticeId), payload), { id: currentNoticeId })
        : await addDoc(collection(db,'notices'), payload);
      noticeModal.style.display='none';
      if (!currentNoticeId){
        await addDoc(collection(db,'adminChat'), {
          type:'notice',
          noticeId: docRef.id,
          title: payload.title,
          body: payload.body,
          createdAt: serverTimestamp(),
          uid: me?.uid||null
        });
      }
      openNoticeList();
      renderNoticeList();
    };

    noticeHide24.onclick = async ()=>{
      if (!firebaseOk){ alert('로그인 시에만 유지됩니다. 비로그인 유저는 매 방문마다 공지가 표시됩니다.'); return; }
      if (!me){ alert('로그인 후 이용 가능합니다.'); return; }
      const until = new Date(Date.now()+24*3600*1000);
      await setDoc(doc(db,'noticeSuppress', me.uid), { until }, { merge:true });
      alert('24시간 동안 자동 팝업을 표시하지 않습니다.');
      noticeModal.style.display='none';
    };
    noticeDismiss.onclick = ()=> noticeModal.style.display='none';

    async function autoPopupLatestNotice(){
      if (!firebaseOk) return;
      const qs = query(collection(db,'notices'), orderBy('createdAt','desc'), limit(1));
      const s = await getDocs(qs);
      if (s.empty) return;
      const d = s.docs[0]; const v = d.data()||{};
      if (!me){
        openNotice(d.id);
        return;
      }
      try{
        const sup = await getDoc(doc(db,'noticeSuppress', me.uid));
        const until = toMs(sup?.data()?.until);
        if (until && until > Date.now()) return;
      }catch{}
      openNotice(d.id);
    }

    setTimeout(autoPopupLatestNotice, 1200);

    /* ====== 건의 및 문의 시스템 ====== */
    const btnSuggestList = document.getElementById('btnSuggestList');
    const suggestListModal = document.getElementById('suggestListModal');
    const sgListWrap = document.getElementById('sgListWrap');
    const sgNew = document.getElementById('sgNew');
    const sgListClose = document.getElementById('sgListClose');
    
    const suggestModal = document.getElementById('suggestModal');
    const sgView = document.getElementById('sgView');
    const sgEdit = document.getElementById('sgEdit');
    const sgClose = document.getElementById('sgClose');
    const sgTitle = document.getElementById('sgTitle');
    const sgBody = document.getElementById('sgBody');
    const sgDate = document.getElementById('sgDate');
    const sgReplies = document.getElementById('sgReplies');
    const sgReplyForm = document.getElementById('sgReplyForm');
    const sgReplyBody = document.getElementById('sgReplyBody');
    const sgReplySubmit = document.getElementById('sgReplySubmit');
    const sgEditTitle = document.getElementById('sgEditTitle');
    const sgEditBody = document.getElementById('sgEditBody');
    const sgEditCancel = document.getElementById('sgEditCancel');
    const sgEditSave = document.getElementById('sgEditSave');
    
    let currentSuggestId = null;
    
    btnSuggestList.onclick = ()=> openSuggestList();
    
    function openSuggestList(){
      if (!firebaseOk){ alert('네트워크 필요'); return; }
      suggestListModal.style.display='flex';
      renderSuggestList();
    }
    
    sgListClose.onclick = ()=> suggestListModal.style.display='none';
    suggestListModal.addEventListener('click', (e)=>{ if(e.target===suggestListModal) suggestListModal.style.display='none'; });
    
    async function renderSuggestList(){
      const qs = query(collection(db,'suggestions'), orderBy('createdAt','desc'));
      const snap = await getDocs(qs);
      sgListWrap.innerHTML = [...snap.docs].map(d=>{
        const v = d.data()||{};
        const dt = new Date(toMs(v.createdAt||Date.now())).toLocaleString();
        const replyCount = v.replyCount || 0;
        return `<div class="ritem" data-id="${d.id}">
          <div style="font-weight:600">${esc(v.title||'(제목 없음)')}</div>
          <div class="meta">${dt} · 답변 ${replyCount}개</div>
          <div style="margin-top:6px"><button class="rbtn" data-open>열기</button></div>
        </div>`;
      }).join('') || `<div style="opacity:.7">등록된 건의가 없습니다.</div>`;
      sgListWrap.onclick = (e)=>{
        const card = e.target.closest('.ritem'); if(!card) return;
        if (e.target.matches('[data-open]')) openSuggestDetail(card.getAttribute('data-id'));
      };
    }
    
    sgNew.onclick = ()=>{
      if (!me){ alert('로그인이 필요합니다'); return; }
      sgEdit.style.display='block';
      sgView.style.display='none';
      suggestModal.style.display='flex';
      sgEditTitle.value=''; sgEditBody.value='';
      currentSuggestId=null;
    };
    
    async function openSuggestDetail(id){
      const s = await getDoc(doc(db,'suggestions', id));
      if (!s.exists()){ alert('삭제된 건의입니다'); return; }
      const v = s.data()||{};
      currentSuggestId = id;
      
      sgEdit.style.display='none';
      sgView.style.display='block';
      suggestModal.style.display='flex';
      sgTitle.textContent = v.title||'(제목 없음)';
      sgBody.textContent = v.body||'';
      sgDate.textContent = new Date(toMs(v.createdAt||Date.now())).toLocaleString();
      
      // 답변 표시
      const repliesSnap = await getDocs(query(collection(db,'suggestions', id, 'replies'), orderBy('createdAt','asc')));
      if (repliesSnap.empty){
        sgReplies.innerHTML = '<div style="opacity:.7">답변이 없습니다</div>';
      } else {
        const isMine = me && me.uid === v.authorUid;
        sgReplies.innerHTML = (await Promise.all(repliesSnap.docs.map(async d=>{
          const r = d.data();
          if (r.isAdminReply && !isAdmin && !isMine) {
            return '<div class="citem"><div style="opacity:.7">관리자 전용 답변입니다</div></div>';
          }

          // ✅ 관리자 답변은 작성자와 관리자만 볼 수 있음
          if (!isAdmin && !isMine){
            return '<div class="citem"><div style="opacity:.7">숨겨진 댓글입니다</div></div>';
          }
          const disp = await getDisplayForUid(r.uid);
          return `<div class="citem">
            <div class="meta">${esc(fmtDisplay(disp.nick, disp.rankCode, disp.trust, disp.isAdmin))} · ${new Date(toMs(r.createdAt||Date.now())).toLocaleString()}</div>
            <div style="white-space:pre-wrap; margin-top:6px">${esc(r.body||'')}</div>
          </div>`;
        }))).join('');
      }
      
      sgReplyForm.style.display = isAdmin ? 'block' : 'none';
    }
    
    sgClose.onclick = ()=> suggestModal.style.display='none';
    suggestModal.addEventListener('click', (e)=>{ if(e.target===suggestModal) suggestModal.style.display='none'; });
    
    sgEditCancel.onclick = ()=> suggestModal.style.display='none';
    
    sgEditSave.onclick = async ()=>{
      if (!me){ alert('로그인이 필요합니다'); return; }
      const title = sgEditTitle.value.trim() || '(제목 없음)';
      const body = sgEditBody.value.trim();
      if (!body){ alert('내용을 입력해주세요'); return; }
      
      const docRef = await addDoc(collection(db,'suggestions'), {
        title, body,
        authorUid: me.uid,
        createdAt: serverTimestamp(),
        replyCount: 0
      });
      
      // ✅ 관리자 메신저에 카드 추가
      await addDoc(collection(db,'adminChat'), {
        type:'suggestion',
        suggestionId: docRef.id,
        title, body,
        createdAt: serverTimestamp(),
        uid: me.uid
      });
      
      // ✅ 통계 업데이트
      await updateDoc(doc(db,'profiles', me.uid), {
        suggestionsMade: increment(1)
      });
      
      // ✅ 주간 미션 체크
      const weekNum = getWeekNumber(new Date());
      const wRef = doc(db,'profiles', me.uid, 'missions', 'weekly');
      await setDoc(wRef, {
        currentWeek: weekNum,
        suggestionsThisWeek: increment(1)
      }, {merge:true});
      
      await checkAchievements(me.uid);
      
      suggestModal.style.display='none';
      alert('건의가 등록되었습니다');
      renderSuggestList();
    };
    
    sgReplySubmit.onclick = async ()=>{
      if (!isAdmin){ alert('관리자 전용'); return; }
      const body = sgReplyBody.value.trim();
      if (!body) return;
      
      await addDoc(collection(db,'suggestions', currentSuggestId, 'replies'), {
        body,
        uid: me.uid,
        createdAt: serverTimestamp(),
        isAdminReply: true
      });
      
      await updateDoc(doc(db,'suggestions', currentSuggestId), {
        replyCount: increment(1)
      });
      
      sgReplyBody.value='';
      openSuggestDetail(currentSuggestId);
    };

    /* ====== 미션 시스템 ====== */
    const missionsModal = document.getElementById('missionsModal');
    const missionsClose = document.getElementById('missionsClose');
    const dailyMissions = document.getElementById('dailyMissions');
    const weeklyMissions = document.getElementById('weeklyMissions');
    
    // ✅ 프로필 버튼에서 미션 열기
    document.addEventListener('keydown', (e)=>{
      if (e.key.toLowerCase() === 'q' && !['INPUT','TEXTAREA'].includes((e.target||{}).tagName)){
        e.preventDefault();
        openMissions();
      }
    });
    
    async function openMissions(){
      if (!me){ alert('로그인이 필요합니다'); return; }
      missionsModal.style.display='flex';
      await renderMissions();
    }
    
    missionsClose.onclick = ()=> missionsModal.style.display='none';
    missionsModal.addEventListener('click', (e)=>{ if(e.target===missionsModal) missionsModal.style.display='none'; });
    
    async function renderMissions(){
      if (!firebaseOk || !me) return;
      
      const today = new Date().toISOString().split('T')[0];
      const weekNum = getWeekNumber(new Date());
      
      const dRef = doc(db,'profiles', me.uid, 'missions', 'daily');
      const wRef = doc(db,'profiles', me.uid, 'missions', 'weekly');
      
      const [dSnap, wSnap] = await Promise.all([getDoc(dRef), getDoc(wRef)]);
      const dData = dSnap.exists() ? dSnap.data() : {};
      const wData = wSnap.exists() ? wSnap.data() : {};
      
      // 날짜가 바뀌면 초기화
      if (dData.lastLoginDate !== today){
        await setDoc(dRef, {
          loginToday: false,
          commentsToday: 0,
          noticeCheckedToday: false,
          lastLoginDate: today
        });
      }
      
      // 주가 바뀌면 초기화
      if (wData.currentWeek !== weekNum){
        await setDoc(wRef, {
          currentWeek: weekNum,
          loginDaysThisWeek: 0,
          pinsThisWeek: 0,
          suggestionsThisWeek: 0,
          reactionsThisWeek: 0,
          loginDates: []
        });
      }
      
      const pfRef = doc(db,'profiles', me.uid);
      const pfSnap = await getDoc(pfRef);
      const completedDaily = pfSnap.data()?.dailyMissionsCompleted || [];
      const completedWeekly = pfSnap.data()?.weeklyMissionsCompleted || [];
      
      // 일일 미션 렌더링
      dailyMissions.innerHTML = DAILY_MISSIONS.map(m=>{
        const completed = m.check(dData) || completedDaily.includes(m.id);
        return `
          <div class="mission-item ${completed?'completed':''}">
            <div>
              <strong>${m.name}</strong>
              <div class="mission-reward">+${m.xp} XP</div>
            </div>
            ${completed ? '<span style="color:#4caf50">✓</span>' : ''}
          </div>
        `;
      }).join('');
      
      // 주간 미션 렌더링
      weeklyMissions.innerHTML = WEEKLY_MISSIONS.map(m=>{
        const completed = m.check(wData) || completedWeekly.includes(m.id);
        return `
          <div class="mission-item ${completed?'completed':''}">
            <div>
              <strong>${m.name}</strong>
              <div class="mission-reward">+${m.xp} XP</div>
            </div>
            ${completed ? '<span style="color:#4caf50">✓</span>' : ''}
          </div>
        `;
      }).join('');
      
      // 완료된 미션 보상 지급
      for (const m of DAILY_MISSIONS){
        if (m.check(dData) && !completedDaily.includes(m.id)){
          await updateDoc(pfRef, {
            xp: increment(m.xp),
            dailyMissionsCompleted: arrayUnion(m.id)
          });
        }
      }
      
      for (const m of WEEKLY_MISSIONS){
        if (m.check(wData) && !completedWeekly.includes(m.id)){
          await updateDoc(pfRef, {
            xp: increment(m.xp),
            weeklyMissionsCompleted: arrayUnion(m.id)
          });
        }
      }
    }

    /* ====== 업적 리스트 (관리자) ====== */
    const achievementListModal = document.getElementById('achievementListModal');
    const achListContent = document.getElementById('achListContent');
    const achListClose = document.getElementById('achListClose');
    
    // ✅ 관리자 메신저와 공지 사이에 버튼 추가 (HTML에서 수동 추가 필요)
    if (isAdmin){
      const achievementListBtn = document.createElement('button');
      achievementListBtn.id = 'btnAchievementList';
      achievementListBtn.className = 'pill-btn';
      achievementListBtn.textContent = '업적 리스트';
      achievementListBtn.style.display = 'inline-block';
      achievementListBtn.onclick = ()=> openAchievementList();
      
      const topRight = document.querySelector('.top-right');
      const msgBtn = document.getElementById('btnMsg');
      topRight.insertBefore(achievementListBtn, msgBtn);
    }
    
    function openAchievementList(){
      if (!isAdmin){ alert('관리자 전용'); return; }
      achievementListModal.style.display='flex';
      
      const tierLabels = {normal:'노말', rare:'레어', epic:'에픽', legend:'레전드'};
      achListContent.innerHTML = ACHIEVEMENTS.map(ach=>`
        <div class="achievement-badge ${ach.tier}" style="margin:8px 0; padding:12px">
          <strong>${ach.name}</strong> (${tierLabels[ach.tier]} · +${ach.xp} XP)<br>
          <span style="font-size:12px; opacity:.8">${ach.desc}</span>
        </div>
      `).join('');
    }
    
    achListClose.onclick = ()=> achievementListModal.style.display='none';
    achievementListModal.addEventListener('click', (e)=>{ if(e.target===achievementListModal) achievementListModal.style.display='none'; });

    /* ===== 키보드 단축키 ===== */
    document.addEventListener('keydown', (e)=>{
      function closeIfOpen(id, openDisplay='flex') {
        const el = document.getElementById(id);
        if (el && el.style.display === openDisplay) {
          el.style.display = 'none';
          return true;
        }
        return false;
      }

      document.addEventListener('keydown', (e) => {
        if (e.key !== 'Escape') return;

        const modals = [
          'messengerModal','noticeModal','noticeListModal',
          'suggestModal','suggestListModal','missionsModal','achievementListModal'
        ];

        for (const id of modals) {
          if (closeIfOpen(id)) return;
        }

        if (info?.style.display === 'block') { infoClose?.click(); }
      });

      if (['INPUT','TEXTAREA'].includes((e.target||{}).tagName)) return;
      if (e.key === '/') { e.preventDefault(); qInput.focus(); }
      if (e.key.toLowerCase() === 's') { e.preventDefault(); side.style.display = (side.style.display==='block'?'none':'block'); }
      if (e.key.toLowerCase() === 'm') { e.preventDefault(); setMode(mode==='search'?'place':'search'); }
      if (e.key === 'Escape'){
        if (document.getElementById('modal').style.display==='flex') { document.getElementById('modal').style.display='none'; pending=null; return; }
        if (document.getElementById('profileModal').style.display==='flex') { document.getElementById('profileModal').style.display='none'; return; }
        if (document.getElementById('otherProfileModal').style.display==='flex') { document.getElementById('otherProfileModal').style.display='none'; return; }
        if (document.getElementById('trustHistoryModal').style.display==='flex') { document.getElementById('trustHistoryModal').style.display='none'; return; }
        if (document.getElementById('achievementModal').style.display==='flex') { document.getElementById('achievementModal').style.display='none'; return; }
        if (document.getElementById('messengerModal').style.display==='flex') { document.getElementById('messengerModal').style.display='none'; return; }
        if (document.getElementById('noticeModal').style.display==='flex') { document.getElementById('noticeModal').style.display='none'; return; }
        if (document.getElementById('noticeListModal').style.display==='flex') { document.getElementById('noticeListModal').style.display='none'; return; }
        if (document.getElementById('suggestModal').style.display==='flex') { document.getElementById('suggestModal').style.display='none'; return; }
        if (document.getElementById('suggestListModal').style.display==='flex') { document.getElementById('suggestListModal').style.display='none'; return; }
        if (document.getElementById('missionsModal').style.display==='flex') { document.getElementById('missionsModal').style.display='none'; return; }
        if (document.getElementById('achievementListModal').style.display==='flex') { document.getElementById('achievementListModal').style.display='none'; return; }
        if ($info.style.display==='block'){ $infoClose.click(); return; }
      }
    });

    /* ===== showReactionMenu 글로벌 함수 ===== */
    window.showReactionMenu = showReactionMenu;

    /* ===== 카테고리별 확인된 핀 로드 ===== */
    function loadConfirmedPins(){
      const confirmed = {};
      markerMap.forEach((rec, id)=>{
        if (rec.confirmed){
          const cat = rec.data.category;
          confirmed[cat] = (confirmed[cat] || 0) + 1;
        }
      });
      for (const [cat, count] of Object.entries(confirmed)){
        catConfirmed.set(cat, count);
      }
      updateAllCategoryProgress();
    }
    
    // 마커 로드 후 확인된 핀 집계
    setTimeout(loadConfirmedPins, 2000);

    // 페이지 로드 직후 한 틱 뒤에 강제 닫기 (실수로 열렸으면 잡아줌)
      setTimeout(()=>{
        if (mode !== 'place' && modal.style.display !== 'none'){
         modal.style.display = 'none';
          pending = null;
        }
      }, 0);


    console.log('✅ ZA 한글 공략 맵 초기화 완료');

    /* === ZA MAPS PATCH BUNDLE (drop-in) =========================================
    * 목적: 기존 HTML(동일 문서의 <script type="module">)에 이 블록만 붙여넣으면
    * - 상단 우측 버튼(공지/건의/메신저) 열기/닫기
    * - 프로필/신뢰도내역/업적관리/타유저프로필 모달 열기/닫기
    * - 상세패널 링크복사, 핀 오른쪽-클릭 반응 메뉴
    * - 검색/핀배치 모드 토글, 단축키, 사이드바 토글
    * 등이 바로 작동.
    * 기존 코드(Leaflet/Firebase/각종 유틸)와 충돌 없이 “후킹”만 한다.
    * 이 코드는 반드시 같은 <script type="module"> 내부 가장 마지막에 삽입.
    * ========================================================================== */

    (function(){
      // ----- 안전 헬퍼 -----
      const $ = (id)=> document.getElementById(id);
      const qs = (sel, root=document)=> root.querySelector(sel);
      const qsa = (sel, root=document)=> Array.from(root.querySelectorAll(sel));
      const on = (el, ev, fn)=> el && el.addEventListener(ev, fn);

      // 기존 스코프 값들 접근 (있으면 사용, 없으면 안전한 기본값)
      const LS = globalThis.LS || { save:()=>{}, load:()=>null };
      const map = globalThis.map || null;

      // ----- 모달 공통 -----
      function showModal(id){ const el=$(id); if(el){ el.style.display='flex'; trapFocus(el); } }
      function hideModal(id){ const el=$(id); if(el){ el.style.display='none'; releaseFocus(); } }
      function toggleModal(id){ const el=$(id); if(!el) return; (el.style.display==='flex')?hideModal(id):showModal(id); }

      // 포커스 트랩(접근성)
      let lastFocus=null;
      function trapFocus(container){
      lastFocus = document.activeElement;
        const focusables = qsa('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])', container)
         .filter(el=>!el.hasAttribute('disabled'));
        if (focusables[0]) focusables[0].focus();
        function loop(e){
          if(e.key!=='Tab') return;
          const first = focusables[0], last = focusables[focusables.length-1];
          if(e.shiftKey && document.activeElement===first){ last.focus(); e.preventDefault(); }
          else if(!e.shiftKey && document.activeElement===last){ first.focus(); e.preventDefault(); }
      }
        container.__trapHandler = loop;
        container.addEventListener('keydown', loop);
    }
      function releaseFocus(){
        if (lastFocus && document.body.contains(lastFocus)) lastFocus.focus();
        qsa('#modal,#profileModal,#messengerModal,#noticeModal,#noticeListModal,#suggestModal,#suggestListModal,#achievementModal,#missionsModal,#trustHistoryModal,#otherProfileModal,#achievementListModal')
          .forEach(m=>{
            if (m.__trapHandler) { m.removeEventListener('keydown', m.__trapHandler); m.__trapHandler=null; }
          });
      lastFocus=null;
      }

      // ----- 상단 우측 버튼: 공지/건의/메신저 -----
      on($('btnNoticeList'), 'click', ()=> showModal('noticeListModal'));
      on($('btnSuggestList'), 'click', ()=> showModal('suggestListModal'));
      on($('btnMsg'),        'click', ()=> showModal('messengerModal'));

      // 공지 목록 닫기/새 공지
      on($('ntListClose'), 'click', ()=> hideModal('noticeListModal'));
      on($('ntNew'), 'click', ()=> { hideModal('noticeListModal'); showModal('noticeModal'); });

      // 공지 본문 뷰/닫기
      on($('noticeClose'), 'click', ()=> hideModal('noticeModal'));
      on($('noticeDismiss'), 'click', ()=> hideModal('noticeModal'));
      on($('noticeHide24'), 'click', ()=>{
        try { LS.save('notice_hide_until', Date.now()+24*3600*1000); }catch{}
        hideModal('noticeModal');
      });

      // 건의/문의 목록 닫기 & 작성하기
      on($('sgListClose'), 'click', ()=> hideModal('suggestListModal'));
      on($('sgNew'), 'click', ()=> { hideModal('suggestListModal'); showModal('suggestModal'); });

      // 건의/문의 상세 닫기
      on($('sgClose'), 'click', ()=> hideModal('suggestModal'));

      // 관리자 메신저 닫기
      on($('msgClose'), 'click', ()=> hideModal('messengerModal'));

      // ----- 프로필/신뢰도/업적/타 유저 프로필 -----
      on($('btnProfile'), 'click', ()=> showModal('profileModal'));
      on($('pfClose'), 'click', ()=> hideModal('profileModal'));
      on($('thClose'), 'click', ()=> hideModal('trustHistoryModal'));
      on($('pfTrustHistory'), 'click', ()=> showModal('trustHistoryModal'));

      //업적 관리(내)
      on($('pfManageAchievements'), 'click', ()=> showModal('achievementModal'));
      on($('achClose'), 'click', ()=> hideModal('achievementModal'));

      // 전체 업적(관리자용 리스트) 모달(있을 때)
      on($('achListClose'), 'click', ()=> hideModal('achievementListModal'));

      // 타 유저 프로필
      on($('opClose'), 'click', ()=> hideModal('otherProfileModal'));

      // 미션 모달 (버튼이 별도로 있다면 연결)
      const btnMissions = $('btnMissions'); // 선택 요소(없으면 무시)
      if (btnMissions) on(btnMissions, 'click', ()=> showModal('missionsModal'));
      on($('missionsClose'), 'click', ()=> hideModal('missionsModal'));

      // ----- 사이드바 & 모드 토글 -----
      const side = $('side');
      const btnSearch = $('btnSearch');
      const btnPlace = $('btnPlace');

      function setMode(mode){ // 'search' | 'place'
        if (!btnSearch || !btnPlace) return;
        if (mode==='search'){
          btnSearch.classList.add('on'); btnPlace.classList.remove('on');
          if (side) side.style.display = 'block';
        }else{
          btnPlace.classList.add('on'); btnSearch.classList.remove('on');
          if (side) side.style.display = 'none';
        }
        try { LS.save('ui_mode', mode); }catch{}
    }
      // 초기 모드 복원
      const savedMode = (LS.load('ui_mode','search')||'search');
      setMode(savedMode);

      on(btnSearch, 'click', ()=> setMode('search'));
      on(btnPlace,  'click', ()=> setMode('place'));

      // 단축키: S=검색모드, M=핀모드, /=검색 포커스, ESC=모달/상세 닫기
      on(document, 'keydown', (e)=>{
        const tag = (e.target && e.target.tagName)||'';
        const inInput = /INPUT|TEXTAREA|SELECT/.test(tag);
        if (e.key==='s' || e.key==='S'){ if(!inInput){ e.preventDefault(); setMode('search'); } }
        if (e.key==='m' || e.key==='M'){ if(!inInput){ e.preventDefault(); setMode('place'); } }
        if (e.key==='/'){ if(!inInput){ e.preventDefault(); $('qInput')?.focus(); } }
        if (e.key==='Escape'){
          // 열려있는 모달/상세 닫기
          const openMod = qsa('#modal,#profileModal,#messengerModal,#noticeModal,#noticeListModal,#suggestModal,#suggestListModal,#achievementModal,#missionsModal,#trustHistoryModal,#otherProfileModal,#achievementListModal')
            .find(el=> el.style.display==='flex');
          if (openMod) { hideModal(openMod.id); return; }
          const info = $('info');
          if (info && info.style.display!=='none'){ qs('#infoClose', info)?.click(); }
        }
      });

      // ----- 상세패널: 링크복사 & 핀 반응(right-click) -----
      const copyBtn = $('copyLinkBtn');
      if (copyBtn){
        on(copyBtn, 'click', ()=>{
          try{
            const idTag = $('infoId')?.textContent?.trim() || '#-';
            // currentOpenId는 메인 스크립트에서 유지
            const mid = (globalThis.currentOpenId || '').trim();
            const url = new URL(location.href);
            if (mid) url.searchParams.set('pin', mid);
            // 보이는 번호만 있는 경우에도 일단 복사
            navigator.clipboard.writeText(url.toString())
              .then(()=> alert('링크가 복사되었습니다'))
              .catch(()=> alert('링크 복사에 실패했습니다'));
          }catch{
            alert('클립보드 접근이 차단되었어요');
          }
        });
      }

      // 핀 전체에 대한 반응 메뉴: 상세 상단 영역 우클릭 시
      const infoPane = $('info');
      if (infoPane){
        on(infoPane, 'contextmenu', (e)=>{
          // 댓글 개별 우클릭은 본문 렌더 쪽에서 이미 처리.
          // 상세 패널 빈 곳 우클릭 시, 현재 열린 핀에 반응 달기
          const menu = $('reactionMenu');
          if (!menu) return;
          const pinId = globalThis.currentOpenId;
          if (!pinId) return;
          e.preventDefault();
          if (typeof globalThis.showReactionMenu === 'function'){
            globalThis.showReactionMenu(e.pageX, e.pageY, 'pin', pinId, null);
          }
        });
      }

      // 반응 메뉴 바깥 클릭으로 닫기(보호)
      const reactionMenu = $('reactionMenu');
      if (reactionMenu){
        on(document, 'click', (e)=>{
          if (reactionMenu.style.display==='block' && !reactionMenu.contains(e.target)){
            reactionMenu.style.display='none';
          }
        });
      }

      // ----- “공지 24시간 숨김” 적용(있다면) -----
      try{
        const until = LS.load('notice_hide_until', 0) || 0;
        if (Date.now() < until){
          // 공지 열림을 시도할 때마다 막을 수 있지만,
          // 여기선 시작 시 목록 모달을 강제로 닫는 정도로 처리
          const nl = $('noticeListModal'); if (nl) nl.style.display='none';
          const nv = $('noticeModal'); if (nv) nv.style.display='none';
        }
      }catch{}

      // ----- 접근성: 모달 배경 클릭으로 닫기 -----
      qsa('#modal,#profileModal,#messengerModal,#noticeModal,#noticeListModal,#suggestModal,#suggestListModal,#achievementModal,#missionsModal,#trustHistoryModal,#otherProfileModal,#achievementListModal')
        .forEach(m=>{
          on(m, 'click', (e)=>{ if (e.target===m) hideModal(m.id); });
        });

      // ----- 사이드: 인기검색어 버튼 키보드 접근성 강화 -----
      const qTrend = $('qTrending');
      if (qTrend){
        qTrend.addEventListener('keydown', (e)=>{
          const b = e.target.closest('[data-sug]');
          if (!b) return;
          if (e.key==='Enter' || e.key===' '){ b.click(); e.preventDefault(); }
        });
      }

      // ----- 줌 컨트롤 숨김을 보완하는 축소/확대 단축키(+/-) -----
      on(document, 'keydown', (e)=>{
        if (!map) return;
        if (e.target && /INPUT|TEXTAREA|SELECT/.test(e.target.tagName)) return;
        if (e.key==='+'){ map.zoomIn(); }
        else if (e.key==='-'){ map.zoomOut(); }
      });

      // ----- 작은 토스트 유틸(필요시) -----
      if (typeof globalThis.toast !== 'function'){
        globalThis.toast = (msg)=>{
          const t = document.createElement('div');
          t.textContent = msg;
          Object.assign(t.style, {
            position:'fixed', left:'50%', bottom:'24px', transform:'translateX(-50%)',
            background:'#111c', color:'#fff', padding:'8px 12px', borderRadius:'8px',
            zIndex: 4000, backdropFilter:'blur(4px)'
          });
          document.body.appendChild(t);
          setTimeout(()=> t.remove(), 1800);
        };
      }

      // ----- 안전: showReactionMenu가 없으면 최소 구현 -----
      if (typeof globalThis.showReactionMenu !== 'function'){
        globalThis.showReactionMenu = (x,y,type,targetId,parentId)=>{
          const menu = $('reactionMenu'); if(!menu) return;
          menu.style.left = x+'px'; menu.style.top = y+'px'; menu.style.display='block';
          // 선택 처리 자체는 메인 구현(이미 HTML에 존재)에게 맡김
        };
      }

      // 끝
    })();
    
  </script>
</body>
</html>
