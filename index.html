<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>ZA 한글 공략 맵</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height:100%; margin:0; }
    #map { position: relative; z-index: 0; background:#e9eaec; }
    .bar{
      position:fixed; left:10px; top:10px; z-index:1400;
      background:#111a; color:#fff; padding:8px 10px; border-radius:10px; font-size:14px;
      display:flex; gap:8px; align-items:center;
    }
    .bar button{margin:0}
    #adminBadge{display:none;background:#ffd54f;color:#111;padding:2px 6px;border-radius:8px}
    .tbtn{background:#2a2f3a;color:#ddd;border:0;border-radius:8px;padding:6px 10px;cursor:pointer}
    .tbtn.on{background:#3d6cff;color:#fff}
    /* 좌측 검색 사이드(화면 1/5) */
    #side{
      position:fixed; z-index:1300; left:10px; top:60px; bottom:10px;
      width:20vw; min-width:240px; max-width:420px;
      display:none; background:#1c1f27; color:#d6d9e0; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.25);
      padding:12px; overflow:auto;
    }
    #side h3{margin:6px 0 10px 4px; font-size:16px; color:#fff}
    .flt-wrap{display:flex; flex-wrap:wrap; gap:8px}
    .flt{
      border:1px solid #303645; background:#202532; color:#c9cfdd; padding:6px 10px;
      border-radius:999px; cursor:pointer; font-size:13px;
    }
    .flt.on{background:#3d6cff; border-color:#3d6cff; color:#fff}
    .hr{height:1px; background:#2a3040; margin:12px 0}
    .inp{width:100%; box-sizing:border-box; background:#1117; color:#eef; border:1px solid #303645; border-radius:10px; padding:8px}
    .row{display:flex; gap:8px; align-items:center}

    /* 신고 관리 모드 전용 리스트 */
    .rlist{display:grid; gap:8px}
    .ritem{background:#1f2430;border:1px solid #2f3647;border-radius:10px;padding:10px}
    .ritem .meta{font-size:12px;color:#9fb0c0;margin-top:4px}
    .ritem .act{display:flex;gap:8px;margin-top:8px}
    .rbtn{background:#2a2f3a;color:#fff;border:0;padding:6px 10px;border-radius:8px;cursor:pointer}
    .rbtn.warn{background:#ff5252}

    /* 우하단 상세 패널 */
    #info{position:fixed; right:10px; bottom:10px; width:420px; max-height:75%;
      overflow:auto; z-index:1500; display:none; background:#1e1e1e; color:#ddd;
      border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.35);}
    #info header{display:flex; align-items:center; gap:8px; padding:10px 12px; border-bottom:1px solid #333}
    #info .thumb{width:100%; max-height:260px; object-fit:cover; background:#000}
    #info .pad{padding:12px}
    #info .meta{font-size:12px; color:#aaa}
    #info .btns{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px}
    #info button{background:#2a2a2a; color:#fff; border:0; padding:6px 10px; border-radius:8px; cursor:pointer}
    #info button.primary{background:#3d6cff}
    #info button.warn{background:#ff5252}
    #info .media video{width:100%; max-height:260px}
    #info .media img{width:100%; max-height:260px; object-fit:cover}
    #info .idtag{background:#263238; color:#cfd8dc; padding:2px 6px; border-radius:6px; font-size:11px}
    .pk-tags{display:flex; flex-wrap:wrap; gap:6px; margin-top:6px}
    .pk-tags .tag{background:#223; border:1px solid #345; color:#cfe; padding:2px 8px; border-radius:999px; font-size:12px}
    /* 본문 아래 캐러셀 */
    .carousel{ position:relative; width:100%; margin-top:12px; background:#141414; border-radius:10px; overflow:hidden }
    .carousel .inner{ display:flex; transition: transform .3s ease }
    .carousel .item{ min-width:100%; display:flex; align-items:center; justify-content:center; background:#000 }
    .carousel .item img, .carousel .item video{ width:100%; max-height:420px; object-fit:contain; background:#000 }
    .carousel .nav{
      position:absolute; top:50%; transform:translateY(-50%);
      background:#000a; color:#fff; border:0; width:38px; height:38px; border-radius:50%; cursor:pointer;
      display:flex; align-items:center; justify-content:center; font-size:18px;
    }
    .carousel .prev{ left:8px } .carousel .next{ right:8px }
    .carousel .dots{ position:absolute; left:0; right:0; bottom:6px; display:flex; justify-content:center; gap:6px }
    .carousel .dot{ width:8px; height:8px; border-radius:50%; background:#6a6a6a; }
    .carousel .dot.on{ background:#fff }
    /* 댓글 */
    #comments{ margin-top:12px; }
    #comments .cform textarea{ width:100%; box-sizing:border-box; background:#111; color:#eee; border:1px solid #333; border-radius:8px; padding:8px }
    #comments .cform .row{ display:flex; gap:8px; margin-top:8px }
    #comments .cform button{ background:#3d6cff; border:0; color:#fff; padding:6px 10px; border-radius:8px }
    #comments .clist{ margin-top:10px; display:grid; gap:10px }
    .citem{ background:#151515; border:1px solid #2a2a2a; border-radius:10px; padding:10px }
    .citem .meta{ font-size:12px; color:#aaa; display:flex; gap:8px; align-items:center }
    .citem .act{ display:flex; gap:8px; margin-top:6px }
    .citem .btn{ background:#2a2a2a; color:#fff; border:0; padding:4px 8px; border-radius:8px; cursor:pointer }
    .citem .btn.warn{ background:#ff5252 }
    /* 입력 모달 */
    #modal{display:none; position:fixed; inset:0; background:#0008; align-items:center; justify-content:center; z-index:1500;}
    #panel{background:#1e1e1e;color:#fff;padding:16px;border-radius:12px;width:380px}
    #panel input,#panel textarea,#panel select{width:100%; box-sizing:border-box}
    small.muted{color:#a0a7b4}
  </style>
</head>
<body>
  <!-- 외부 스크립트 차단 경고 -->
  <div id="blockWarn" style="display:none;position:fixed;inset:0;background:#000a;z-index:3000;
  align-items:center;justify-content:center;color:#fff;padding:20px;text-align:center">
    외부 스크립트가 차단되어 페이지가 작동하지 않습니다.<br>
    광고차단/보안DNS/브라우저 보호기능을 끄고 새로고침 해주세요.
  </div>
  <script> setTimeout(()=>{ if(!window.L){ document.getElementById('blockWarn').style.display='flex'; } }, 1500); </script>

  <div class="bar">
    <span id="who">로그인 안 됨</span>
    <button id="login">Google 로그인</button>
    <button id="logout" style="display:none">로그아웃</button>
    <span id="adminBadge">관리자</span>
    <span style="width:1px;height:20px;background:#2f3545;margin:0 6px"></span>
    <button id="btnSearch" class="tbtn on">검색 모드</button>
    <button id="btnPlace"  class="tbtn">핀 배치 모드</button>
    <button id="btnAdminReport" class="tbtn" style="display:none">신고 관리 모드</button>
  </div>

  <!-- 좌측 사이드 -->
  <aside id="side">
    <!-- (A) 일반/관리자 공통: 상단 섹션은 모드에 따라 교체 표시 -->
    <div id="sideCats">
      <h3>카테고리 필터</h3>
      <div class="flt-wrap" id="fltList"></div>

      <h3>특수 레이어</h3>
      <div class="flt-wrap">
        <button id="fltWild" class="flt on">와일드 존</button>
        <button id="fltAll" class="flt">전체 선택</button>
        <button id="fltNone" class="flt">전체 해제</button>
        <!-- 관리자 전용: 승인 대기 핀 & 신고 목록(레이어) -->
        <button id="fltPending" class="flt" style="display:none">승인 대기 핀</button>
        <button id="fltReported" class="flt" style="display:none">신고 레이어</button>
      </div>
    </div>

    <!-- (B) 신고 관리 모드: 필터 대신 신고된 댓글 목록 -->
    <div id="sideReports" style="display:none">
      <h3>신고된 댓글</h3>
      <div id="repCommentList" class="rlist"></div>
      <div class="hr"></div>
      <div style="font-size:12px;opacity:.8">최근 48시간 내 접수·대기 중인 댓글 신고만 노출됩니다.</div>
    </div>

    <div class="hr"></div>
    <h3>통합 검색</h3>
    <div class="row" style="align-items:stretch">
      <input id="qInput" class="inp" placeholder="제목/내용에서 검색" />
      <button id="qSearch" class="flt">검색</button>
      <button id="qClear" class="flt">초기화</button>
    </div>
    <div style="margin-top:8px; font-size:12px; opacity:.85">최근 7일 인기 검색어</div>
    <div id="qTrending" class="flt-wrap" style="margin-top:6px"></div>
  </aside>

  <div id="map"></div>

  <!-- 우하단 상세 패널 -->
  <aside id="info">
    <header>
      <h3 id="infoTitle">(제목)</h3>
      <span id="infoId" class="idtag">#-</span>
      <button id="infoClose">닫기</button>
    </header>
    <div class="media" id="infoMediaTop"></div>
    <div class="pad">
      <div class="meta" id="infoMeta"></div>
      <div id="infoPk" class="pk-tags"></div>
      <div id="infoBody" style="white-space:pre-wrap; margin-top:8px"></div>

      <!-- 본문 아래 캐러셀 -->
      <div id="infoCarousel" class="carousel" style="display:none">
        <div class="inner" id="carInner"></div>
        <button class="nav prev" id="carPrev">‹</button>
        <button class="nav next" id="carNext">›</button>
        <div class="dots" id="carDots"></div>
      </div>

      <!-- 댓글 -->
      <div id="comments">
        <div class="cform" id="cForm" style="display:none">
          <textarea id="cBody" rows="3" placeholder="댓글을 입력하세요"></textarea>
          <div class="row"><button id="cSubmit">댓글 등록</button></div>
        </div>
        <div class="clist" id="cList"></div>
      </div>

      <div class="btns" id="infoBtns" style="margin-top:12px"></div>
    </div>
  </aside>

  <!-- 마커 입력 모달 -->
  <div id="modal">
    <div id="panel">
      <h3>마커 추가 (검수 대기)</h3>
      <input id="mTitle" class="inp" placeholder="제목" />
      <textarea id="mBody" class="inp" rows="4" placeholder="공략/설명(줄바꿈 가능)"></textarea>

      <label style="display:block;margin-top:6px">닉네임 표시</label>
      <div class="row">
        <select id="mNickSel" class="inp">
          <option value="me">내 구글 닉네임</option>
          <option value="anon">익명</option>
          <option value="custom">커스텀</option>
        </select>
        <input id="mNickCustom" class="inp" placeholder="커스텀 닉네임" style="display:none;"/>
      </div>

      <label style="display:block;margin-top:8px">카테고리</label>
      <select id="mCat" class="inp"></select>
      <small class="muted">카테고리 아이콘은 Firestore <code>categories/{카테고리키}.iconUrl</code>로 전역 변경</small>

      <!-- 포켓몬 지정(와일드/우두머리/메가) -->
      <div id="pkEditor" style="display:none; margin-top:10px">
        <label>포켓몬(여러 개 가능)</label>
        <div class="row" style="align-items:stretch">
          <input id="pkAddInput" class="inp" placeholder="포켓몬 이름 입력 후 추가" />
          <button id="pkAddBtn" class="flt">추가</button>
          <button id="pkAddClear" class="flt">초기화</button>
        </div>
        <div id="pkChips" class="pk-tags" style="margin-top:6px"></div>
      </div>

      <label style="display:block;margin-top:8px">사진(여러장 가능)</label>
      <input id="mImgs" class="inp" type="file" accept="image/*" multiple />
      <label style="display:block;margin-top:8px">동영상(1개 권장)</label>
      <input id="mVideo" class="inp" type="file" accept="video/*" />
      <div style="margin-top:12px; text-align:right">
        <button id="cancelBtn">취소</button>
        <button id="saveBtn">등록</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script type="module">
    /* ---------------- 유틸/폴리필 ---------------- */
    if (!globalThis.CSS) globalThis.CSS = {};
    if (!CSS.escape) CSS.escape = s => String(s).replace(/["'\\\s]/g, m => '\\' + m);
    const esc = (s)=> (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
    const nowMs = ()=> Date.now();
    const HIDE_MS = 48 * 3600 * 1000;
    const toMs = (t)=>{
      if (!t) return null;
      if (t.toMillis) return t.toMillis();
      if (t.seconds)  return t.seconds*1000;
      if (typeof t === 'number') return t;
      const d = new Date(t); return isNaN(d) ? null : d.getTime();
    };
    const norm = s => (s||'').toLowerCase();
    const normName = s => (s||'').trim().toLowerCase();
    const fieldKey = s => normName(s).replace(/[.#$/\[\]\/]/g,'_');

    /* ---------------- Leaflet ---------------- */
    const IMG_URL = "za_world_map_clean_fixed.png";
    const IMG_W = 2048, IMG_H = 2048;
    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -2, maxZoom: 4 });
    const bounds = [[0,0],[IMG_H,IMG_W]];
    L.imageOverlay(IMG_URL, bounds).addTo(map);
    map.fitBounds(bounds);
    const isInside = (latlng)=> map.getBounds().contains(latlng);

    // Wild 전용 pane
    map.createPane('wildPane');
    map.getPane('wildPane').style.zIndex = 450;
    map.getPane('wildPane').style.pointerEvents = 'none';

    // 와일드 존 오버레이(필요시 추가)
    const WILD_ZONES = [ /* { url:'wild/a.png', bounds:[[y1,x1],[y2,x2]], opacity:0.65 } */ ];
    const wildLayer = L.layerGroup().addTo(map);
    let wildVisible = true;

    // 관리자 전용 토글 상태
    let showPendingOnly = false;    // 승인 대기 핀만
    let showReportedOnly = false;   // (일반 모드용) 신고 레이어 토글
    let adminReportMode = false;    // ★ 신고 관리 모드 (관리자만)

    /* ---------------- Firebase: 동적 import ---------------- */
    let firebaseOk = true;
    let app, auth, db, st;
    let GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, signOut, onAuthStateChanged;
    let collection, collectionGroup, addDoc, serverTimestamp, onSnapshot,
        orderBy, query, doc, updateDoc, deleteDoc, where, getDocs, getDoc, setDoc, increment;
    let ref, getDownloadURL, uploadBytesResumable, uploadBytes;

    try {
      const [appMod, authMod, fsMod, stMod] = await Promise.all([
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js"),
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js"),
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js"),
        import("https://www.gstatic.com/firebasejs/10.14.1/firebase-storage.js"),
      ]);
      const firebaseConfig = {
        apiKey: "AIzaSyCam7y7qNINoxBlTeGx7CDlP8Y77pXFMWA",
        authDomain: "za-maps-32982.firebaseapp.com",
        projectId: "za-maps-32982",
        storageBucket: "za-maps-32982.firebasestorage.app",
        messagingSenderId: "804333155537",
        appId: "1:804333155537:web:504bc3ee175e3678bc81f0",
        measurementId: "G-GTRK8JEZFM"
      };
      app = appMod.initializeApp(firebaseConfig);
      auth = authMod.getAuth(app);
      db   = fsMod.getFirestore(app);
      st   = stMod.getStorage(app);
      ({ GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, signOut, onAuthStateChanged } = authMod);
      ({ collection, collectionGroup, addDoc, serverTimestamp, onSnapshot, orderBy, query, doc, updateDoc, deleteDoc, where, getDocs, getDoc, setDoc, increment } = fsMod);
      ({ ref, getDownloadURL, uploadBytesResumable, uploadBytes } = stMod);
    } catch (e) {
      firebaseOk = false;
      console.warn("[Firebase] 동적 import 실패 — 오프라인 모드", e);
    }

    /* ---------------- 업로드 유틸 ---------------- */
    const safeName = (name)=> name.normalize('NFKD').replace(/[^\w.\-]+/g,'_').replace(/_+/g,'_').slice(-80);
    globalThis.uploadSmart = async function uploadSmart(file, folder, onProgress, label='업로드'){
      if (!firebaseOk) throw new Error('Firebase unavailable');
      const uid = (me && me.uid) || 'anon';
      const fname = `${Date.now()}_${safeName(file.name)}`;
      const path  = `${folder}/${uid}/${fname}`;
      const r     = ref(st, path);
      try{
        onProgress?.(`${label}…`);
        await uploadBytes(r, file);
        return await getDownloadURL(r);
      }catch(e1){
        console.warn('[upload] simple 실패 → resumable', e1);
      }
      const task = uploadBytesResumable(r, file);
      await new Promise((resolve, reject)=>{
        task.on('state_changed',
          s=> onProgress?.(`${label}… ${Math.round(s.bytesTransferred/s.totalBytes*100)}%`),
          reject, resolve);
      });
      return await getDownloadURL(r);
    };

    /* ---------------- 카테고리 ---------------- */
    const CATEGORIES = [
      {key:'홀로베이터',     label:'홀로베이터',     defaultIcon:'holovator.png'},
      {key:'와일드 존',       label:'와일드 존',       defaultIcon:'wild_zone.png'},
      {key:'중요한 장소',     label:'중요한 장소',     defaultIcon:'poi.png'},
      {key:'부티크',         label:'부티크',         defaultIcon:'boutique.png'},
      {key:'포켓몬 센터',     label:'포켓몬 센터',     defaultIcon:'pokemon_center.png'},
      {key:'카페',           label:'카페',           defaultIcon:'cafe.png'},
      {key:'레스토랑',       label:'레스토랑',       defaultIcon:'restaurant.png'},
      {key:'헤어 살롱',       label:'헤어 살롱',       defaultIcon:'hair_salon.png'},
      {key:'컬러풀한 나사',   label:'컬러풀한 나사',   defaultIcon:'colorful_screw.png'},
      {key:'기술머신',       label:'기술머신',       defaultIcon:'tm.png'},
      {key:'메가스톤',       label:'메가스톤',       defaultIcon:'mega_stone.png'},
      {key:'중요 아이템',     label:'중요 아이템',     defaultIcon:'key_item.png'},
      {key:'포켓몬 볼',       label:'포켓몬 볼',       defaultIcon:'poke_ball.png'},
      {key:'회복 아이템',     label:'회복 아이템',     defaultIcon:'medicine.png'},
      {key:'보물',           label:'보물',           defaultIcon:'treasure.png'},
      {key:'기타 아이템',     label:'기타 아이템',     defaultIcon:'other_item.png'},
      {key:'메인 임무',       label:'메인 임무',       defaultIcon:'main_mission.png'},
      {key:'사이드 임무',     label:'사이드 임무',     defaultIcon:'side_mission.png'},
      {key:'승급전',         label:'승급전',         defaultIcon:'promotion_match.png'},
      {key:'사다리',         label:'사다리',         defaultIcon:'ladder.png'},
      {key:'NPC',            label:'NPC',            defaultIcon:'npc.png'},
      {key:'기타',           label:'기타',           defaultIcon:'misc.png'},
      {key:'우두머리 포켓몬', label:'우두머리 포켓몬', defaultIcon:'alpha_pokemon.png'},
      {key:'메가 포켓몬',     label:'메가 포켓몬',     defaultIcon:'mega_pokemon.png'},
    ];
    const catSel = document.getElementById('mCat');
    catSel.innerHTML = CATEGORIES.map(c=>`<option value="${c.key}">${c.label}</option>`).join('');

    const categoryIconOverride = new Map();
    if (firebaseOk){
      onSnapshot(collection(db,'categories'), snap=>{
        categoryIconOverride.clear();
        snap.forEach(d=>{ const v=d.data()?.iconUrl; if (v) categoryIconOverride.set(d.id, v); });
      });
    }
    const labelFor=(key)=> CATEGORIES.find(c=>c.key===key)?.label || key;
    const defaultIconFor=(key)=> {
      const def = CATEGORIES.find(c=>c.key===key)?.defaultIcon;
      return def ? `icons/${def}` : `icons/default.png`;
    };

    /* ---------------- 로그인/관리자 상태 ---------------- */
    const $who = document.getElementById('who');
    const $login = document.getElementById('login');
    const $logout = document.getElementById('logout');
    const $adminBadge = document.getElementById('adminBadge');
    const $btnPendingOnly = document.getElementById('fltPending');
    const $btnReportedOnly = document.getElementById('fltReported');
    const $btnAdminReport = document.getElementById('btnAdminReport']);
    let me=null, isAdmin=false;

    $login.onclick = async (e) => {
      if (!firebaseOk) { alert('네트워크 차단으로 로그인 불가'); return; }
      try{ await signInWithPopup(auth, new GoogleAuthProvider()); }
      catch{ await signInWithRedirect(auth, new GoogleAuthProvider()); }
    };
    $logout.onclick = ()=>{ if(firebaseOk) signOut(auth); };

    if (firebaseOk) getRedirectResult(auth).catch(()=>{});

    function resubscribe(){ subscribeMarkers(); subscribeAdminReportFeeds(); }

    if (firebaseOk){
      onAuthStateChanged(auth, async (user)=>{
        me=user||null;
        document.getElementById('who').textContent=me?(me.displayName || '로그인됨'):'로그인 안 됨';
        document.getElementById('login').style.display=me?'none':'inline-block';
        document.getElementById('logout').style.display=me?'inline-block':'none';
        isAdmin=false; $adminBadge.style.display='none';
        $btnPendingOnly.style.display='none'; showPendingOnly=false; $btnPendingOnly.classList.remove('on');
        $btnReportedOnly.style.display='none'; showReportedOnly=false; $btnReportedOnly.classList.remove('on');
        $btnAdminReport.style.display='none'; setAdminReportMode(false);

        if (me){
          onSnapshot(doc(db,'admins', me.uid), s=>{
            isAdmin = s.exists();
            $adminBadge.style.display = isAdmin ? 'inline-block' : 'none';
            $btnPendingOnly.style.display = isAdmin ? 'inline-block' : 'none';
            $btnReportedOnly.style.display = isAdmin ? 'inline-block' : 'none';
            $btnAdminReport.style.display = isAdmin ? 'inline-block' : 'none';
            resubscribe();
          }, ()=>{
            isAdmin=false; $adminBadge.style.display='none';
            $btnPendingOnly.style.display='none';
            $btnReportedOnly.style.display='none';
            $btnAdminReport.style.display='none';
            setAdminReportMode(false);
            resubscribe();
          });
        } else {
          resubscribe();
        }
      });
    }

    /* ---------------- 아이콘 캐시 ---------------- */
    const iconCache = new Map();
    function iconUrlForCat(cat){ return categoryIconOverride.get(cat) || defaultIconFor(cat); }
    function iconFor(cat){
      const url = iconUrlForCat(cat);
      const key = `${url}|32x42`;
      if (!iconCache.has(key)) {
        iconCache.set(key, L.icon({ iconUrl: url, iconSize:[32,42], iconAnchor:[16,42] }));
      }
      return iconCache.get(key);
    }

    /* ---------------- 카테고리 그룹 & 토글 ---------------- */
    const catGroups = new Map();
    const catVisible = new Map();
    function ensureCatGroup(key){
      if (!catGroups.has(key)) {
        catGroups.set(key, L.layerGroup().addTo(map));
        catVisible.set(key, true);
      }
      return catGroups.get(key);
    }
    function setCategoryVisible(key, visible){
      catVisible.set(key, visible);
      const g = ensureCatGroup(key);
      if (visible) { if (!map.hasLayer(g)) g.addTo(map); }
      else { if (map.hasLayer(g)) map.removeLayer(g); }
      const btn = document.querySelector(`.flt[data-cat="${CSS.escape(key)}"]`);
      if (btn){ btn.classList.toggle('on', visible); }
      applyAllVisibility();
      recomputeSeqs();
    }
    function setAllCats(v){ CATEGORIES.forEach(c=> setCategoryVisible(c.key, v)); }
    function setWildVisible(v){
      wildVisible = v;
      if (v){ if (!map.hasLayer(wildLayer)) wildLayer.addTo(map); }
      else { if (map.hasLayer(wildLayer)) map.removeLayer(wildLayer); }
      document.getElementById('fltWild').classList.toggle('on', v);
    }

    // 좌측 필터 UI
    const side = document.getElementById('side');
    const sideCats = document.getElementById('sideCats');
    const sideReports = document.getElementById('sideReports');
    const repCommentList = document.getElementById('repCommentList');
    const fltList = document.getElementById('fltList');

    function buildFilters(){
      fltList.innerHTML = CATEGORIES.map(c=>`<button class="flt on" data-cat="${c.key}">${c.label}</button>`).join('');
      fltList.onclick = (e)=>{
        const b = e.target.closest('.flt[data-cat]');
        if (!b) return;
        const key = b.getAttribute('data-cat');
        const next = !catVisible.get(key);
        setCategoryVisible(key, next);
      };
      document.getElementById('fltWild').onclick = ()=> setWildVisible(!wildVisible);
      document.getElementById('fltAll').onclick  = ()=> setAllCats(true);
      document.getElementById('fltNone').onclick = ()=> setAllCats(false);

      $btnPendingOnly.onclick = ()=>{
        if (!isAdmin) return;
        showPendingOnly = !showPendingOnly;
        $btnPendingOnly.classList.toggle('on', showPendingOnly);
        applyAllVisibility(); recomputeSeqs();
      };
      $btnReportedOnly.onclick = ()=>{
        if (!isAdmin) return;
        showReportedOnly = !showReportedOnly;
        $btnReportedOnly.classList.toggle('on', showReportedOnly);
        applyAllVisibility(); recomputeSeqs();
      };

      $btnAdminReport.onclick = ()=>{
        if (!isAdmin) return;
        setAdminReportMode(!adminReportMode);
      };
    }
    buildFilters();

    function setAdminReportMode(v){
      adminReportMode = !!v;
      side.style.display = 'block';
      sideCats.style.display = adminReportMode ? 'none' : 'block';
      sideReports.style.display = adminReportMode ? 'block' : 'none';
      document.getElementById('btnAdminReport').classList.toggle('on', adminReportMode);
      applyAllVisibility();
      recomputeSeqs();
    }

    /* ---------------- 통합 검색(제목/본문) + 랭킹 ---------------- */
    const qInput   = document.getElementById('qInput');
    const qSearch  = document.getElementById('qSearch');
    const qClear   = document.getElementById('qClear');
    const qTrendEl = document.getElementById('qTrending');

    let textFilter = ''; // lowercased
    function applyTextFilter(q){
      textFilter = norm(q||'');
      applyAllVisibility(); // 검색어 변경 시 즉시 반영
      recomputeSeqs();
    }
    qSearch.onclick = ()=> { const q = qInput.value.trim(); applyTextFilter(q); if (q) logQuery(q).catch(()=>{}); };
    qInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ qSearch.click(); }});
    qClear.onclick = ()=>{ qInput.value=''; applyTextFilter(''); };

    function dateKey(d=new Date()){
      const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), da=String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${da}`;
    }
    async function logQuery(q){
      if (!firebaseOk) return;
      const normed = fieldKey(q);
      const refD = doc(db,'searchDaily', dateKey());
      await setDoc(refD, {
        updatedAt: serverTimestamp(),
        [`counts.${normed}`]: increment(1),
        [`labels.${normed}`]: q
      }, { merge:true });
    }
    function lastNDaysKeys(n){
      const arr=[]; const now=new Date();
      for(let i=0;i<n;i++){ const d=new Date(now.getTime()-i*24*3600*1000); arr.push(dateKey(d)); }
      return arr;
    }
    async function refreshTrending(){
      if (!firebaseOk) { qTrendEl.innerHTML=''; return; }
      const keys = lastNDaysKeys(7);
      const counts = new Map(); const labels = new Map();
      for (const k of keys){
        const s = await getDoc(doc(db,'searchDaily', k));
        if (!s.exists()) continue;
        const data = s.data();
        const cs = data?.counts || {}; const ls = data?.labels || {};
        for (const [normKey, c] of Object.entries(cs)){
          counts.set(normKey, (counts.get(normKey)||0) + (c||0));
          if (ls[normKey]) labels.set(normKey, ls[normKey]);
        }
      }
      const tops = [...counts.entries()].sort((a,b)=>b[1]-a[1]).slice(0,5).map(([n])=> labels.get(n) || n);
      qTrendEl.innerHTML = tops.map(t=>`<button class="flt" data-sug="${esc(t)}">${esc(t)}</button>`).join('');
    }
    qTrendEl.onclick = (e)=>{
      const b=e.target.closest('[data-sug]'); if(!b) return;
      const q=b.getAttribute('data-sug'); qInput.value=q; qSearch.click();
    };
    refreshTrending(); setInterval(refreshTrending, 3600*1000);

    /* ---------------- 신고 피드(관리자 모드용) — 교체된 섹션 ---------------- */
    let reportedMarkerSet = new Set(); // 최근 48h 내 marker pending 신고 존재
    let reportedComments = [];        // {markerId, commentId, body?, reason?, createdAt}

    let unsubRepMarkers = null;
    let unsubRepComments = null;

    function within48h(ts){
      const ms = toMs(ts);
      if (!ms) return true;
      return (nowMs() - ms) <= HIDE_MS;
    }

    function clearReportFeeds(){
      reportedMarkerSet = new Set();
      reportedComments = [];
      renderReportedComments();
      applyAllVisibility();
      if (unsubRepMarkers){unsubRepMarkers(); unsubRepMarkers=null;}
      if (unsubRepComments){unsubRepComments(); unsubRepComments=null;}
    }

    function subscribeAdminReportFeeds(){
      if (!firebaseOk || !isAdmin){
        clearReportFeeds();
        return;
      }

      // --- 1) 신고된 마커: reports 그룹(pending) 구독
      if (unsubRepMarkers){unsubRepMarkers(); unsubRepMarkers=null;}
      const qRM = query(collectionGroup(db,'reports'), where('status','==','pending'));
      unsubRepMarkers = onSnapshot(qRM, snap=>{
        const next = new Set();
        snap.forEach(d=>{
          const data = d.data()||{};
          const path = d.ref.path.split('/'); // markers/{m}/reports/{r} | markers/{m}/comments/{c}/reports/{r}
          const isMarkerReport = data.type==='marker' || (path[0]==='markers' && path[2]==='reports');
          if (!isMarkerReport) return;
          if (!within48h(data.createdAt)) return;
          const markerId = (path[0]==='markers') ? path[1] : (data.markerId || null);
          if (markerId) next.add(markerId);
        });
        reportedMarkerSet = next;
        applyAllVisibility();
        recomputeSeqs();
      }, err=>{
        console.warn('[reported markers] collectionGroup error', err);
      });

      // --- 2) 신고된 댓글: 우선 reports 그룹(pending) 시도, 실패/0건이면 폴백
      if (unsubRepComments){unsubRepComments(); unsubRepComments=null;}
      const qRC = query(collectionGroup(db,'reports'), where('status','==','pending'));
      unsubRepComments = onSnapshot(qRC, async snap=>{
        let items = [];
        const fetches = [];
        snap.forEach(d=>{
          const data = d.data()||{};
          const path = d.ref.path.split('/');
          const isCommentReport = data.type==='comment' || (path.length>=6 && path[2]==='comments' && path[4]==='reports');
          if (!isCommentReport) return;
          if (!within48h(data.createdAt)) return;
          const markerId = (path[0]==='markers') ? path[1] : (data.markerId || null);
          const commentId= (path[2]==='comments') ? path[3] : (data.commentId || null);
          if (!markerId || !commentId) return;

          const item = {
            id: d.id, markerId, commentId,
            reason: data.reason || '',
            createdAt: toMs(data.createdAt) || Date.now(),
            body: '(불러오는 중…)'
          };
          items.push(item);

          // 댓글 본문 불러오기 (권한 안되면 폴백에서 채워짐)
          fetches.push(
            getDoc(doc(db,'markers', markerId, 'comments', commentId))
              .then(cs=>{ item.body = cs.exists() ? (cs.data()?.body || '(본문 없음)') : '(삭제됨)'; })
              .catch(()=>{ item.body='(로드 실패)'; })
          );
        });

        if (fetches.length === 0) { // 읽기권한/인덱스 문제 또는 0건
          await subscribeReportedCommentsFallback();
          return;
        }

        await Promise.all(fetches);
        reportedComments = items.sort((a,b)=>b.createdAt - a.createdAt);
        renderReportedComments();
      }, async err=>{
        console.warn('[reported comments] collectionGroup error', err);
        await subscribeReportedCommentsFallback(); // 에러 시 폴백
      });
    }

    // 폴백: 숨김 적용된 댓글(hiddenUntil > now)을 그룹쿼리로 수집
    async function subscribeReportedCommentsFallback(){
      try{
        const qHidden = query(collectionGroup(db,'comments'), where('hiddenUntil','>', new Date()));
        const snap = await getDocs(qHidden);
        const items = [];
        const now = nowMs();
        snap.forEach(d=>{
          const path = d.ref.path.split('/'); // markers/{m}/comments/{c}
          if (!(path[0]==='markers' && path[2]==='comments')) return;
          const markerId = path[1];
          const commentId= path[3];
          const data = d.data()||{};
          const hu = toMs(data.hiddenUntil);
          if (!hu) return;
          if ((hu - now) <= 0) return; // 이미 해제 제외
          const approxCreated = hu - HIDE_MS; // 대략적인 발생 시각

          items.push({
            id: `${markerId}_${commentId}`,
            markerId, commentId,
            reason: '(사유 미확인)',
            createdAt: approxCreated,
            body: data.body || '(본문 없음)'
          });
        });
        reportedComments = items.sort((a,b)=>b.createdAt - a.createdAt);
        renderReportedComments();
      }catch(err){
        console.warn('[fallback comments] error', err);
        reportedComments = [];
        renderReportedComments();
      }
    }

    function renderReportedComments(){
      if (!adminReportMode){
        repCommentList.innerHTML='';
        return;
      }
      if (!reportedComments.length){
        repCommentList.innerHTML = `<div style="opacity:.7">표시할 신고된 댓글이 없습니다.</div>`;
        return;
      }
      repCommentList.innerHTML = reportedComments.map(rc=>`
        <div class="ritem" data-mid="${esc(rc.markerId)}" data-cid="${esc(rc.commentId)}">
          <div style="font-weight:600">#${rc.markerId.slice(0,6)}… · 댓글</div>
          <div style="white-space:pre-wrap;margin-top:6px">${esc(rc.body || '')}</div>
          ${rc.reason ? `<div class="meta">사유: ${esc(rc.reason)}</div>`:''}
          <div class="meta">${new Date(rc.createdAt).toLocaleString()}</div>
          <div class="act">
            <button class="rbtn" data-jump>해당 핀 보기</button>
            <button class="rbtn" data-dismiss>신고 반려</button>
          </div>
        </div>
      `).join('');

      repCommentList.onclick = async (e)=>{
        const card = e.target.closest('.ritem'); if (!card) return;
        const markerId = card.getAttribute('data-mid');
        const commentId= card.getAttribute('data-cid');

        if (e.target.matches('[data-jump]')){
          const rec = markerMap.get(markerId);
          if (rec){
            openInfoWithSeq(rec.data);
            setTimeout(()=>{
              const el = document.getElementById('c-'+commentId);
              if (el) el.scrollIntoView({behavior:'smooth', block:'center'});
            }, 400);
          }else{
            alert('해당 핀을 지도에서 찾을 수 없습니다.');
          }
          return;
        }

        if (e.target.matches('[data-dismiss]')){
          try{
            // 보고서가 안보이는 환경도 고려: 1) 보이는 report는 rejected, 2) 숨김 해제
            try{
              const q = query(collection(db,'markers', markerId, 'comments', commentId, 'reports'), where('status','==','pending'));
              const s = await getDocs(q);
              await Promise.all(s.docs.map(d=> updateDoc(d.ref, { status:'rejected', reviewedAt: serverTimestamp() })));
            }catch(_e){ /* 무시: 권한/인덱스 이슈 가능 */ }
            await updateDoc(doc(db,'markers', markerId, 'comments', commentId), { hiddenUntil: null });
            alert('해당 댓글 신고를 반려했습니다.');
          }catch(err){
            alert('반려 처리 실패: ' + (err?.message||err));
          }
        }
      };
    }

    /* ---------------- 마커 구독/렌더 ---------------- */
    const markerMap=new Map(); // id -> {group, marker, data, seq}
    let unsubMain=null, unsubPending=null;

    function subscribeMarkers(){
      if (!firebaseOk) return;
      if (unsubMain){unsubMain();} if (unsubPending){unsubPending();}
      markerMap.forEach(({group, marker})=> group.removeLayer(prev.marker));
      markerMap.clear();

      const qApproved=query(collection(db,'markers'), where('status','==','approved'));
      unsubMain=onSnapshot(qApproved, s=>{
        s.docChanges().forEach(renderChange);
        recomputeSeqs();
      });

      if (isAdmin){
        const qPending=query(collection(db,'markers'), where('status','==','pending'));
        unsubPending=onSnapshot(qPending, s=>{
          s.docChanges().forEach(renderChange);
          recomputeSeqs();
        });
      }
    }

    function renderChange(ch){
      const id=ch.doc.id;
      if (ch.type==='removed'){
        const prev=markerMap.get(id);
        if(prev){ prev.group.removeLayer(prev.marker); markerMap.delete(id); }
        return;
      }
      const m={id, ...ch.doc.data()};
      if (Array.isArray(m.pokemon) && !Array.isArray(m.pokemonNorm)){
        m.pokemonNorm = m.pokemon.map(normName);
      }

      if (markerMap.has(id)){
        const prev=markerMap.get(id);
        prev.group.removeLayer(prev.marker);
        markerMap.delete(id);
      }
      const group = ensureCatGroup(m.category);
      const mk=L.marker([m.y, m.x], { icon: iconFor(m.category) }).addTo(group);
      mk.on('click', ()=>openInfoWithSeq(m));
      markerMap.set(id, {group, marker: mk, data:m, seq:null});
      applyVisibility(id);
    }

    function isHiddenByReport(m){ return toMs(m.hiddenUntil) > nowMs(); }
    function isReportedPin(m){
      // 신고 관리 모드에서 보일 핀 판단: 최근 48h 신고가 있거나(hiddenUntil) pending report set에 포함
      return isHiddenByReport(m) || reportedMarkerSet.has(m.id);
    }

    function applyVisibility(id){
      const rec = markerMap.get(id);
      if (!rec) return;
      const {group, marker, data:m} = rec;

      // 신고 관리 모드: 신고된 핀만
      if (adminReportMode){
        const ok = isAdmin && isReportedPin(m);
        if (ok){ if (!group.hasLayer(marker)) marker.addTo(group); }
        else   { if (group.hasLayer(marker)) group.removeLayer(marker); }
        return;
      }

      const catOn = catVisible.get(m.category) !== false;
      const hiddenForUser = isHiddenByReport(m) && !isAdmin;
      const txtOk = matchText(m);

      // 기본 승인 상태 필터
      const statusOk = isAdmin ? (showPendingOnly ? m.status==='pending' : true) : (m.status==='approved');

      // (일반 모드) 신고 레이어: 숨김 적용된 핀만 보기 (관리자 시)
      const isHidden = isHiddenByReport(m);
      const reportedOk = isAdmin ? (showReportedOnly ? isHidden : true) : true;

      const ok = catOn && !hiddenForUser && txtOk && statusOk && reportedOk;
      if (ok){ if (!group.hasLayer(marker)) marker.addTo(group); }
      else   { if (group.hasLayer(marker)) group.removeLayer(marker); }
    }
    function applyAllVisibility(){ markerMap.forEach((_, id)=> applyVisibility(id)); }

    // 48시간 경과 자동 복귀(1분마다 재평가)
    setInterval(()=> { applyAllVisibility(); recomputeSeqs(); }, 60*1000);

    async function reportMarker(m, reason){
      if (!firebaseOk) return { ok:false, hid:false };

      try{
        const rep = {
          type:'marker', markerId: m.id, commentId: null,
          uid: me?.uid || null, reason,
          status:'pending', createdAt: serverTimestamp()
        };
        await addDoc(collection(db,'markers', m.id, 'reports'), rep);
      }catch(err){
        console.error('[report:addDoc] 실패', err);
        throw err;
      }

      let hidApplied = false;
      try{
        const until = new Date(Date.now() + HIDE_MS);
        await updateDoc(doc(db,'markers', m.id), { hiddenUntil: until });
        const rec = markerMap.get(m.id);
        if (rec){ rec.data.hiddenUntil = until; applyVisibility(m.id); recomputeSeqs(); }
        hidApplied = true;
      }catch(err){
        console.warn('[report:update hiddenUntil] 권한 부족 또는 실패 — 숨김 미적용', err);
      }
      return { ok:true, hid:hidApplied };
    }

    /* ---------- 동적 시퀀스(고유번호) 재계산 ---------- */
    function visibleForSeq(m){
      if (!m) return false;
      if (adminReportMode) return isAdmin && isReportedPin(m);
      if (isHiddenByReport(m) && !isAdmin) return false;
      if (catVisible.get(m.category) === false) return false;
      if (!matchText(m)) return false;
      const statusOk = isAdmin ? (showPendingOnly ? m.status==='pending' : true) : (m.status==='approved');
      const isHidden = isHiddenByReport(m);
      const reportedOk = isAdmin ? (showReportedOnly ? isHidden : true) : true;
      return !!(statusOk && reportedOk);
    }

    function recomputeSeqs(){
      const items = [];
      markerMap.forEach(({data}, id)=>{
        if (visibleForSeq(data)){
          const created = toMs(data.createdAt) ?? 0;
          items.push({ id, created });
        }
      });
      items.sort((a,b)=> (a.created||0) - (b.created||0));
      const seqById = new Map();
      for (let i=0;i<items.length;i++) seqById.set(items[i].id, i+1);

      markerMap.forEach((rec, id)=>{ rec.seq = seqById.get(id) ?? null; });
      if (currentOpenId && markerMap.has(currentOpenId)){
        const rec = markerMap.get(currentOpenId);
        document.getElementById('infoId').textContent = rec.seq ? '#'+rec.seq : '#-';
      }
    }

    /* ---------------- 상세 패널 + 캐러셀 + 댓글 ---------------- */
    const $info=document.getElementById('info');
    const $infoTitle=document.getElementById('infoTitle');
    const $infoId=document.getElementById('infoId');
    const $infoMeta=document.getElementById('infoMeta');
    const $infoBody=document.getElementById('infoBody');
    const $infoMediaTop=document.getElementById('infoMediaTop');
    const $infoBtns=document.getElementById('infoBtns');
    const $infoPk=document.getElementById('infoPk');

    const $carousel=document.getElementById('infoCarousel');
    const $carInner=document.getElementById('carInner');
    const $carPrev=document.getElementById('carPrev');
    const $carNext=document.getElementById('carNext');
    const $carDots=document.getElementById('carDots');
    let carIdx = 0, carItems = [];
    function buildCarousel(media){
      const rest = (media||[]).slice(1);
      if (!rest.length){ $carousel.style.display='none'; return; }
      $carousel.style.display='block';
      carItems = rest; carIdx = 0;
      $carInner.innerHTML = rest.map(m=>`<div class="item">${
        m.type==='video' ? `<video controls src="${m.url}"></video>` : `<img src="${m.url}" alt="">`
      }</div>`).join('');
      $carDots.innerHTML = rest.map((_,i)=>`<div class="dot ${i===0?'on':''}" data-i="${i}"></div>`).join('');
      updateCarousel();
    }
    function updateCarousel(){
      const w = $carousel.clientWidth || 1;
      $carInner.style.transform = `translateX(${-carIdx * w}px)`;
      [...$carDots.children].forEach((d,i)=> d.classList.toggle('on', i===carIdx));
    }
    window.addEventListener('resize', updateCarousel);
    $carPrev.onclick = ()=>{ if (carItems.length){ carIdx = (carIdx - 1 + carItems.length) % carItems.length; updateCarousel(); } };
    $carNext.onclick = ()=>{ if (carItems.length){ carIdx = (carIdx + 1) % carItems.length; updateCarousel(); } };
    $carDots.onclick = (e)=>{ const d = e.target.closest('.dot'); if (!d) return; carIdx = +d.getAttribute('data-i') || 0; updateCarousel(); };

    // 댓글
    const $cForm = document.getElementById('cForm');
    const $cBody = document.getElementById('cBody');
    const $cSubmit = document.getElementById('cSubmit');
    const $cList = document.getElementById('cList');
    let unsubComments = null;

    function openComments(marker){
      if (!firebaseOk) { $cForm.style.display='none'; $cList.innerHTML=''; return; }
      if (unsubComments){ unsubComments();unsubComments=null; }
      $cForm.style.display = me ? 'block':'none';
      $cBody.value='';
      const qC = query(collection(db,'markers', marker.id, 'comments'), orderBy('createdAt','asc'));
      unsubComments = onSnapshot(qC, snap=>{
        const now = nowMs(); const items = [];
        snap.forEach(d=>{
          const c = { id:d.id, ...d.data() };
          const hidden = c.hiddenUntil ? (toMs(c.hiddenUntil) > now) : false;
          if (c.deleted) return; if (hidden) return;
          items.push(c);
        });
        $cList.innerHTML = items.map(c => `
          <div class="citem" id="c-${c.id}">
            <div class="meta">${c.displayName || '익명'} · ${new Date(toMs(c.createdAt||Date.now())).toLocaleString()}</div>
            <div class="body" style="white-space:pre-wrap; margin-top:6px">${esc(c.body||'')}</div>
            <div class="act">
              <button class="btn" data-crep="${c.id}">신고</button>
              ${(isAdmin || me?.uid===c.uid) ? `<button class="btn warn" data-cdel="${c.id}">삭제</button>`:''}
            </div>
          </div>`).join('');

        $cList.querySelectorAll('[data-crep]').forEach(btn=>{
          btn.onclick = async ()=>{
            if (!me){ alert('로그인이 필요합니다'); return; }
            const cid = btn.getAttribute('data-crep');
            const reason = prompt('댓글 신고 사유를 입력해주세요'); if (!reason) return;
            const rep = { type:'comment', markerId: marker.id, commentId: cid, uid: me.uid, reason,
                          status:'pending', createdAt: serverTimestamp() };
            await addDoc(collection(db,'markers', marker.id, 'comments', cid, 'reports'), rep);
            await updateDoc(doc(db,'markers', marker.id, 'comments', cid), { hiddenUntil: new Date(Date.now()+HIDE_MS) });
            alert('신고가 접수되었습니다.');
          };
        });
        $cList.querySelectorAll('[data-cdel]').forEach(btn=>{
          btn.onclick = async ()=>{
            const cid = btn.getAttribute('data-cdel');
            if (!confirm('댓글을 삭제할까요?')) return;
            await updateDoc(doc(db,'markers', marker.id, 'comments', cid), { deleted:true });
          };
        });
      });

      $cSubmit.onclick = async ()=>{
        if (!me) { alert('로그인 후 작성할 수 있어요.'); return; }
        const body = ($cBody.value||'').trim();
        if (!body) return;
        await addDoc(collection(db,'markers', marker.id, 'comments'), {
          body, uid: me.uid, displayName: me.displayName || '익명',
          createdAt: serverTimestamp(), deleted:false
        });
        $cBody.value='';
      };
    }

    function mediaTopEl(m){
      if (!m.media?.length) return '';
      const first=m.media[0];
      return (first.type==='video')
        ? `<video class="thumb" controls src="${first.url}"></video>`
        : `<img class="thumb" src="${first.url}" alt="thumb">`;
    }

    function openInfoWithSeq(m){
      const rec = markerMap.get(m.id);
      const seqNum = rec?.seq ?? null;
      openInfo(m, seqNum);
    }

    async function adminDismissAllReports(markerId){
      try{
        const qR = query(collection(db,'markers', markerId, 'reports'), where('status','==','pending'));
        const snap = await getDocs(qR);
        const updates=[];
        snap.forEach(d=> updates.push(updateDoc(d.ref, { status:'rejected', reviewedAt: serverTimestamp() })));
        await Promise.all(updates);
      }catch(e){
        console.warn('[신고 반려] report 업데이트 실패', e);
      }
      try{
        await updateDoc(doc(db,'markers', markerId), { hiddenUntil: null });
      }catch(e){
        console.warn('[신고 반려] hiddenUntil 초기화 실패', e);
      }
    }

    async function adminEditOrDelete(marker){
      const choice = prompt('관리자 작업을 선택하세요: edit / delete', 'edit');
      if (!choice) return;
      if (choice.toLowerCase()==='delete'){
        if (!confirm('이 핀을 완전히 삭제할까요?')) return;
        await deleteDoc(doc(db,'markers', marker.id));
        $info.style.display='none'; currentOpenId=null;
        return;
      }
      if (choice.toLowerCase()==='edit'){
        const newTitle = prompt('제목 수정', marker.title||'');
        if (newTitle===null) return;
        const newBody  = prompt('내용 수정', marker.body||'');
        if (newBody===null) return;
        try{
          await updateDoc(doc(db,'markers', marker.id), { title:newTitle, body:newBody });
          alert('수정되었습니다.');
        }catch(e){
          alert('수정 실패: ' + (e?.message||e));
        }
      }
    }

    function openInfo(m, seqNum){
      currentOpenId=m.id;
      $infoTitle.textContent=m.title||'(제목 없음)';
      $infoId.textContent = seqNum ? '#'+seqNum : '#-';
      const statusText = m.status || 'pending';
      $infoMeta.textContent = `${labelFor(m.category)} · by ${m.displayName||'익명'} · ${statusText}`;
      $infoMediaTop.innerHTML = mediaTopEl(m);
      $infoBody.textContent = m.body||'';

      const pkCats = ['와일드 존','우두머리 포켓몬','메가 포켓몬'];
      if (pkCats.includes(m.category) && Array.isArray(m.pokemon) && m.pokemon.length){
        $infoPk.style.display='flex';
        $infoPk.innerHTML = m.pokemon.map(n=>`<span class="tag">${esc(n)}</span>`).join('');
      } else { $infoPk.style.display='none'; $infoPk.innerHTML=''; }

      buildCarousel(m.media || []);

      const isMine = me && me.uid===m.authorUid;
      const canEdit = isMine && (m.status==='pending'||m.status===undefined);
      const isReported = isReportedPin(m);

      $infoBtns.innerHTML = `
        <button id="btnReport" class="primary">핀 신고</button>
        ${canEdit ? `<button id="btnEdit">수정</button><button id="btnDel" class="warn">삭제</button>`:''}
        ${isAdmin ? `
            ${m.status==='pending'
              ? `<button id="btnAppr" class="primary">승인</button><button id="btnReject" class="warn">반려</button>`
              : ``}
            <button id="btnAdminDel" class="warn">관리자 삭제</button>
            ${isReported ? `
              <button id="btnAdminEditCombo">삭제 및 수정</button>
              <button id="btnReportDismiss">신고 반려</button>
            ` : ``}
          ` : ``}
      `;

      const btnR=document.getElementById('btnReport');
      if (btnR) btnR.onclick = async ()=>{
        if (!me){ alert('로그인이 필요합니다'); return; }
        const reason = prompt('신고 사유를 입력해주세요'); if(!reason) return;
        try{
          const r = await reportMarker(m, reason);
          if (r.ok){
            alert(r.hid ? '신고가 접수되었습니다. (임시 숨김 적용)' : '신고가 접수되었습니다. (권한 제한으로 즉시 숨김은 미적용)');
            $info.style.display='none'; currentOpenId=null;
          }
        }catch(err){
          const msg = err?.message || String(err);
          if (/permission|insufficient/i.test(msg)){
            alert('신고 저장 권한이 없어 접수에 실패했습니다.\n(로그인 상태 및 Firestore 규칙을 확인해주세요)');
          }else{
            alert('신고 처리 중 오류: ' + msg);
          }
        }
      };

      const btnE=document.getElementById('btnEdit');
      if (btnE) btnE.onclick=async()=>{
        if (!firebaseOk) return;
        const nt=prompt('제목 수정', m.title||''); if (nt===null) return;
        const nb=prompt('내용 수정', m.body||''); if (nb===null) return;
        await updateDoc(doc(db,'markers', m.id), { title:nt, body:nb });
      };

      const btnD=document.getElementById('btnDel');
      if (btnD) btnD.onclick=async()=>{
        if (!firebaseOk) return;
        if (!confirm('삭제할까요?')) return;
        await deleteDoc(doc(db,'markers', m.id));
        $info.style.display='none'; currentOpenId=null;
      };

      const btnAdminDel=document.getElementById('btnAdminDel');
      if (btnAdminDel) btnAdminDel.onclick = async ()=>{
        if (!firebaseOk) return;
        if (!confirm('이 핀을 완전히 삭제할까요?')) return;
        await deleteDoc(doc(db,'markers', m.id));
        $info.style.display='none'; currentOpenId=null;
      };

      const btnA=document.getElementById('btnAppr');
      if (btnA) btnA.onclick=async()=>{
        if (!firebaseOk) return;
        btnA.disabled=true; btnA.textContent='승인중...';
        try{ await updateDoc(doc(db,'markers', m.id), { status:'approved' }); }
        finally{ btnA.disabled=false; btnA.textContent='승인'; }
      };

      const btnRe=document.getElementById('btnReject');
      if (btnRe) btnRe.onclick=async()=>{
        if (!firebaseOk) return;
        btnRe.disabled=true; btnRe.textContent='반려중...';
        try{ await updateDoc(doc(db,'markers', m.id), { status:'rejected' }); }
        finally{ btnRe.disabled=false; btnRe.textContent='반려'; }
      };

      const btnAdminEditCombo = document.getElementById('btnAdminEditCombo');
      if (btnAdminEditCombo) btnAdminEditCombo.onclick = ()=> adminEditOrDelete(m);

      const btnReportDismiss = document.getElementById('btnReportDismiss');
      if (btnReportDismiss) btnReportDismiss.onclick = async ()=>{
        if (!firebaseOk) return;
        btnReportDismiss.disabled = true; btnReportDismiss.textContent = '처리중...';
        try{
          await adminDismissAllReports(m.id);
          alert('신고가 반려되었습니다. 숨김이 해제됩니다.');
          const rec = markerMap.get(m.id);
          if (rec){ rec.data.hiddenUntil = null; applyVisibility(m.id); recomputeSeqs(); }
        }catch(e){
          alert('신고 반려 실패: ' + (e?.message||e));
        }finally{
          btnReportDismiss.disabled = false; btnReportDismiss.textContent = '신고 반려';
        }
      };

      $info.style.display='block';
      openComments(m);
    }

    const $infoClose=document.getElementById('infoClose');
    let currentOpenId=null;
    $infoClose.onclick=()=>{ $info.style.display='none'; currentOpenId=null; if (unsubComments){unsubComments();unsubComments=null;} };

    /* ---------------- 모드 전환 ---------------- */
    let mode='search';
    const btnSearch=document.getElementById('btnSearch');
    const btnPlace =document.getElementById('btnPlace');
    function setMode(m){
      mode=m;
      btnSearch.classList.toggle('on', m==='search');
      btnPlace.classList.toggle('on',  m==='place');
      if (!adminReportMode) side.style.display = (m==='search') ? 'block':'none';
    }
    btnSearch.onclick=()=> setMode('search');
    btnPlace.onclick =()=> {
      const msg = '핀 배치모드에서 배치하게 된 핀은 심사를 거쳐 모두에게 공개됩니다.\n신중히, 사실만을 작성하여 주세요.\n\n핀 배치모드로 전환하시겠습니까?';
      if (confirm(msg)) setMode('place');
    };
    setMode('search'); // 기본 검색모드

    /* ---------------- 입력/저장 ---------------- */
    const modal=document.getElementById('modal');
    const t=document.getElementById('mTitle');
    const b=document.getElementById('mBody');
    const nickSel=document.getElementById('mNickSel');
    const nickCus=document.getElementById('mNickCustom');
    const imgsInp=document.getElementById('mImgs');
    const videoInp=document.getElementById('mVideo');

    document.getElementById('cancelBtn').onclick=()=>{ modal.style.display='none'; pending=null; };
    modal.addEventListener('click', (e)=>{ if(e.target===modal){ modal.style.display='none'; pending=null; } });
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal.style.display==='flex'){ modal.style.display='none'; pending=null; }});
    nickSel.onchange=()=> nickCus.style.display=(nickSel.value==='custom')?'block':'none';

    // 포켓몬 편집기
    const pkEditor = document.getElementById('pkEditor');
    const pkAddInput = document.getElementById('pkAddInput');
    const pkAddBtn = document.getElementById('pkAddBtn');
    const pkAddClear = document.getElementById('pkAddClear');
    const pkChips = document.getElementById('pkChips');
    let pkList = [];
    function redrawPkChips(){ pkChips.innerHTML = pkList.map((n,i)=>`<span class="tag" data-i="${i}">${esc(n)} ✕</span>`).join(''); }
    function addPk(){ const v=(pkAddInput.value||'').trim(); if(!v) return; if(!pkList.some(x=>normName(x)===normName(v))) pkList.push(v); pkAddInput.value=''; redrawPkChips(); }
    pkAddBtn.onclick = addPk;
    pkAddInput.addEventListener('keydown', e=>{ if(e.key==='Enter') addPk(); });
    pkAddClear.onclick = ()=>{ pkList=[]; redrawPkChips(); };

    const pokemonCats = ['와일드 존','우두머리 포켓몬','메가 포켓몬'];
    catSel.addEventListener('change', ()=>{ pkEditor.style.display = pokemonCats.includes(catSel.value) ? 'block' : 'none'; });

    let pending=null;
    map.on('click', (e)=>{
      if (mode!=='place') return;
      if(!me){ alert('로그인 후 등록할 수 있어요.'); return; }
      if(!isInside(e.latlng)){ alert('맵 바깥에는 등록할 수 없습니다'); return; }
      pending=e.latlng;
      t.value=''; b.value=''; imgsInp.value=''; videoInp.value='';
      pkList=[]; redrawPkChips();
      if (!catSel.value) catSel.value=CATEGORIES[0].key;
      pkEditor.style.display = pokemonCats.includes(catSel.value) ? 'block' : 'none';
      modal.style.display='flex';
    });

    document.getElementById('saveBtn').onclick = async () => {
      if (!me || !pending) return;
      if (!firebaseOk) { alert('네트워크 차단으로 저장 불가'); return; }
      const imgFiles = imgsInp.files ? Array.from(imgsInp.files) : [];
      const vidFile  = (videoInp.files && videoInp.files[0]) ? videoInp.files[0] : null;
      if (imgFiles.length === 0 && !vidFile) { alert('사진 또는 동영상을 최소 1개 이상 업로드해야 합니다.'); return; }
      const saveBtn = document.getElementById('saveBtn');
      const setBtn  = (t)=> saveBtn.textContent = t;
      const prevTxt = saveBtn.textContent;
      saveBtn.disabled = true;
      try {
        let displayName='익명';
        if (nickSel.value==='me') displayName = me.displayName || '익명';
        else if (nickSel.value==='custom') displayName = (nickCus.value||'').trim() || '익명';

        const media=[];
        for (let i=0;i<imgFiles.length;i++){
          const url = await globalThis.uploadSmart(imgFiles[i], 'markerMedia', setBtn, `이미지 ${i+1}/${imgFiles.length}`);
          media.push({type:'image', url});
        }
        if (vidFile){
          const url = await globalThis.uploadSmart(vidFile, 'markerMedia', setBtn, '동영상');
          media.push({type:'video', url});
        }
        const thumbUrl = media[0].url;

        setBtn('저장 중…');
        const inPkCat = pokemonCats.includes(catSel.value);
        await addDoc(collection(db,'markers'), {
          x: pending.lng, y: pending.lat,
          title: t.value, body: b.value,
          category: catSel.value,
          media, thumbUrl,
          displayName, authorUid: me.uid,
          createdAt: serverTimestamp(),
          status: 'pending',
          hiddenUntil: null,
          ...(inPkCat ? { pokemon: pkList, pokemonNorm: pkList.map(normName) } : {})
        });
        modal.style.display='none'; pending=null;
        setBtn('등록 완료!'); setTimeout(()=>{ saveBtn.disabled=false; setBtn(prevTxt); }, 700);
      } catch (err) {
        console.error('[SAVE ERROR]', err);
        const msg = err?.message || String(err);
        if (msg.includes('CORS') || msg.includes('preflight')) {
          alert('업로드가 CORS로 차단되었습니다.\n\n• Storage 버킷 활성화/일치 확인\n• 브라우저 차단 확장 해제, localhost 사용\n• Auth 허용 도메인에 127.0.0.1/localhost 추가');
        } else if (msg.includes('permission') || msg.includes('unauthorized')) {
          alert('권한 오류: Firestore/Storage 보안 규칙을 점검하세요.');
        } else {
          alert('저장 실패: ' + msg);
        }
        saveBtn.disabled=false; setBtn(prevTxt);
      }
    };

    /* ---------------- 통합 검색 매칭 (제목/본문 + 포켓몬 태그) ---------------- */
    function matchText(m){
      if (!textFilter) return true;
      const q = textFilter;
      const base = norm(`${m.title||''} ${m.body||''}`);
      if (base.includes(q)) return true;
      const qn = normName(q);
      if (Array.isArray(m.pokemonNorm) && m.pokemonNorm.some(p => p.includes(qn))) return true;
      return false;
    }
  </script>
</body>
</html>
